<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KeepMoving</title>
  <subtitle>KP_小新的技术Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.keepmovingxin.com/"/>
  <updated>2016-05-23T05:09:11.000Z</updated>
  <id>http://blog.keepmovingxin.com/</id>
  
  <author>
    <name>KP_小新</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 常用命令用法：程序员的场景</title>
    <link href="http://blog.keepmovingxin.com/2016/05/20/Git-Workflow/"/>
    <id>http://blog.keepmovingxin.com/2016/05/20/Git-Workflow/</id>
    <published>2016-05-20T14:41:28.000Z</published>
    <updated>2016-05-23T05:09:11.000Z</updated>
    
    <content type="html">&lt;p&gt;Git 相比 Subversion，无论概念上还是使用上，复杂度其实是高出一个等级的。为什么这么说？分别看下 &lt;code&gt;git help -a&lt;/code&gt; 和 &lt;code&gt;svn help&lt;/code&gt; 命令清单的对比，单按这个来看，就如果要掌握所有命令的用法，Git 的学习曲线绝对是比 Subversion 高的。尽管如此，但还是有越来越多项目开始用 Git 来做源码管理了。&lt;/p&gt;
&lt;p&gt;实际中，我们用到的的 Git 命令还是很有限的，可能也就 &lt;code&gt;git help&lt;/code&gt; 中那些而已。下面就类似 &lt;a href=&quot;http://blog.keepmovingxin.com/2016/05/20/SVN-Workflow/&quot;&gt;SVN命令用法：程序员的场景&lt;/a&gt; 一样，结合实际场景说下 Git 的常用命令用法。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;“新人报道”&quot;&gt;&lt;a href=&quot;#“新人报道”&quot; class=&quot;headerlink&quot; title=&quot;“新人报道”&quot;&gt;&lt;/a&gt;“新人报道”&lt;/h3&gt;&lt;p&gt;你刚入职一家公司，或新加入某个团队，立马参与到一个项目中，那么就得获取项目代码，开始你的项目生涯。这个时候一般你需要克隆一份项目代码，下面都以 GitHub 上的项目地址为例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone git@github.com:akun/pm.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;之后就进入项目目录，运行项目中的构建脚本，然后就可以熟悉代码，展开具体工作了。&lt;br&gt;当然，有的时候，有一个新项目是由你发起的，你要将初始化的项目工程放到 Git 版本仓库中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir pm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd pm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ touch README.md&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add README.md&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Git 是分布式的版本控制系统，所以刚才的操作，算是已经在你本地版本控制起来了，为了推送本地仓库到远程仓库，就还得执行：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git remote add origin git@github.com:akun/pm.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push -u origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一般这个时候都会设置下 &lt;code&gt;~/.gitconfig&lt;/code&gt; 或 &lt;code&gt;.git/config&lt;/code&gt; 中的配置，最基本的就是用户名和邮箱&lt;br&gt;确认当前的 Git 配置信息：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --list&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置用户名和邮箱：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config user.name akun&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config user.email admin@example.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;刚才的命令只是对 .git/config 生效，如果想全局生效，也就是 ~/.gitconfig，就得加上 –global 参数，比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.name akun&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.email admin@example.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;日常工作&quot;&gt;&lt;a href=&quot;#日常工作&quot; class=&quot;headerlink&quot; title=&quot;日常工作&quot;&gt;&lt;/a&gt;日常工作&lt;/h3&gt;&lt;p&gt;当你已经逐渐融入了一个项目，可能一天的工作场景或完成某个任务的工作周期是这样的：&lt;/p&gt;
&lt;h4 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h4&gt;&lt;p&gt;无论是清早或下午或晚上，开始了你的一天工作，你首先会更新你的工作目录：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cd ~/projects/pm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout develop  # 我想在 develop 分支上开始一天的工作&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;更新方式一：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all  # 从远程仓库获取所有分支的代码变更&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;更新方式二：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rebase  # 默认就衍合 develop 分支的代码了&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;更新方式三，可以认为是 fetch 和 merge 的合集：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull  # 懒得理解 fetch 和 merge 就直接 pull 吧&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样你就可以在最新的项目代码基础上工作了。&lt;br&gt;注解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git pull –rebase 相当于是前面的方式二的合集&lt;/li&gt;
&lt;li&gt;有关 “fetch + merge” VS “fetch + rebase” VS pull 的差异后续单独写一篇文章说明&lt;/li&gt;
&lt;li&gt;这里说的三种方式，可能每个人或团队都有自己的习惯吧&lt;/li&gt;
&lt;li&gt;想了解 Git 中的“衍合”，可以实践下这个文档：&lt;a href=&quot;http://git-scm.com/book/zh/Git-分支-分支的衍合&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git-分支-分支的衍合&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;修改&quot;&gt;&lt;a href=&quot;#修改&quot; class=&quot;headerlink&quot; title=&quot;修改&quot;&gt;&lt;/a&gt;修改&lt;/h4&gt;&lt;p&gt;可能你写了一个新的模块，需要纳入项目的版本控制：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git add tools.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你发现某个模块已经陈旧了，不再使用了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git rm utils.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rm --cached utils.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你发现一个模块的命名不太合理，需要改名：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git mv model.py models.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你要创建一个新的较大的模块，需要归档为目录的方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir groups&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ touch groups/__init__.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add groups/__init__.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注解&lt;br&gt;Git 不支持空文件加加入版本控制，非得必要咋办，后续的其它场景会简单说明下&lt;br&gt;可能你发现要写的模块代码布局类似于旧的模块，直接复制个代码模版：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cp users/tests.py groups/tests.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add groups/tests.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注解&lt;br&gt;Git 没有自带的所谓 cp 命令&lt;br&gt;当然，其实最常见的情况其实还是打开编辑器，比如 Vim，修改已经存在的代码，这个就跟 Git 命令无关了。&lt;/p&gt;
&lt;h4 id=&quot;检查&quot;&gt;&lt;a href=&quot;#检查&quot; class=&quot;headerlink&quot; title=&quot;检查&quot;&gt;&lt;/a&gt;检查&lt;/h4&gt;&lt;p&gt;忙碌的一天过去了，或者一个任务完成了，这个时候一般会将你的工作成果，也就是代码更新到版本仓库（分为本地版本仓库和远程版本仓库）。&lt;br&gt;习惯上会先检查下修改状态：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看到一些 Git 状态信息，确认是修改了哪些文件，之后一般会自己 code review 一下代码的改动，可能有的人会习惯直接用 Git 方式来查看：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git diff&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里的 diff 只是查看其中“工作目录”和“暂存区域”的区别。要查看“暂存区域”和“本地仓库”的区别，可以用：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git diff --staged  # 或 git diff --cached&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注解&lt;/p&gt;
&lt;p&gt;最好理解下三个区的概念，以代码角度来理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作目录：&lt;code&gt;git clone&lt;/code&gt; 后获得的一份本地的代码，也包括新编辑的，尚未加入版本控制的代码&lt;/li&gt;
&lt;li&gt;暂存区域：&lt;code&gt;git add&lt;/code&gt; 后暂存起来，尚未 &lt;code&gt;git commit&lt;/code&gt; 的代码&lt;/li&gt;
&lt;li&gt;本地仓库：&lt;code&gt;git commit&lt;/code&gt; 后正式被版本控制记录起来的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看下图，能更好的理解这三个区&lt;/p&gt;
&lt;p&gt;然后本地运行下相关的单元测试，确认是否有问题。一般来说这个时候，没有什么特殊情况，就直接进入“提交”甚至是“推送”阶段了，然后结束一个工作日或工作周期，但难免会有些特殊情况出现。&lt;/p&gt;
&lt;h4 id=&quot;取消修改&quot;&gt;&lt;a href=&quot;#取消修改&quot; class=&quot;headerlink&quot; title=&quot;取消修改&quot;&gt;&lt;/a&gt;取消修改&lt;/h4&gt;&lt;p&gt;当你 code review 完后，发现有些改动不满意；或者运行完单元测试，发现有些测试用例没通过，你可能会进行取消这些修改的操作。&lt;br&gt;如果还没 add，那么可以：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -- main.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为了避免刚好跟分支名重合，所以加了两个斜杠（虽然概率很低），如果已经 add 了，但还没 commit，那么可以：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git reset HEAD main.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;万一刚提交完毕，也就是已经 commit 了，才发现代码有问题，比如：忘记把某个文件提交了，这个时候咋办？Git 好处是可以覆盖上一次提交，那么可以：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git add tests.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit --amend&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面还只是简单的撤销操作，Git 还能支持更高级的重写历史功能，想掌握高级技能的可以实践下这个文档：&lt;a href=&quot;http://git-scm.com/book/zh/Git-工具-重写历史&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git-工具-重写历史&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;解决冲突&quot;&gt;&lt;a href=&quot;#解决冲突&quot; class=&quot;headerlink&quot; title=&quot;解决冲突&quot;&gt;&lt;/a&gt;解决冲突&lt;/h4&gt;&lt;p&gt;有时候同别人合作写一个模块的代码，会把对方代码合并或衍合过来，比如：对方修复了某个缺陷，你刚好也需要这个修复；再比如：对方完成了某个特性，你也刚好需要用下这 个特性等等各种情况。&lt;br&gt;大多数情况，代码的合并或衍合不会冲突，但也有冲突的情况，分两种情况说明，第一种是合并操作时候有冲突：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge bugfix/remove_error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 这个时候就提示你代码冲突了，处理完冲突的代码后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff  # code review 下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add remove.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 日志中就多了一条合并操作的日志了&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另一种是衍合操作时有冲突：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rebase bugfix/remove_error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 这个时候就提示你代码冲突了，处理完冲突的代码后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff  # code review 下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rebase --continue  # 有时候会 git rebase --skip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 直到不用再 rebase 为止&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;提交到本地版本仓库&quot;&gt;&lt;a href=&quot;#提交到本地版本仓库&quot; class=&quot;headerlink&quot; title=&quot;提交到本地版本仓库&quot;&gt;&lt;/a&gt;提交到本地版本仓库&lt;/h4&gt;&lt;p&gt;最后，一切确认没问题了：code review 完毕，自己觉得代码满意了；有可能也合并完别人的修改并且没有冲突了；运行单元测试也通过了。那么就提交代码吧：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;推送到远程版本仓库&quot;&gt;&lt;a href=&quot;#推送到远程版本仓库&quot; class=&quot;headerlink&quot; title=&quot;推送到远程版本仓库&quot;&gt;&lt;/a&gt;推送到远程版本仓库&lt;/h4&gt;&lt;p&gt;Git 中的 commit 只是提交到自己本地的版本控制仓库，如果想分享你的代码提交，还需要推送到远程的版本控制仓库：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;在分支工作&quot;&gt;&lt;a href=&quot;#在分支工作&quot; class=&quot;headerlink&quot; title=&quot;在分支工作&quot;&gt;&lt;/a&gt;在分支工作&lt;/h3&gt;&lt;p&gt;Git 分支很灵活，用 Git 的合作开发模式方式也很灵活，如何更好得使用 Git 分支来合作开发，可以参考这篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中文翻译版本一：&lt;a href=&quot;http://www.juvenxu.com/2010/11/28/a-successful-git-branching-model/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.juvenxu.com/2010/11/28/a-successful-git-branching-model/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文翻译版本二：&lt;a href=&quot;http://www.oschina.net/translate/a-successful-git-branching-model&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oschina.net/translate/a-successful-git-branching-model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;英文原文：&lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nvie.com/posts/a-successful-git-branching-model/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能后续也会写一篇专门的以 Git 为例的源代码的管理和发布相关主题的文章。&lt;/p&gt;
&lt;p&gt;下面说下在分支工作的常见的实际场景，按顺序：&lt;/p&gt;
&lt;h4 id=&quot;创建新的本地分支&quot;&gt;&lt;a href=&quot;#创建新的本地分支&quot; class=&quot;headerlink&quot; title=&quot;创建新的本地分支&quot;&gt;&lt;/a&gt;创建新的本地分支&lt;/h4&gt;&lt;p&gt;确定要新开个分支来写代码，这里以贡献新特性为例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b features/batch_remove&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -a  # 确认已经在新分支中工作了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git log  # 可以确认是基于刚才的分支新分出来的&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里已经隐含了自动切换到新分支的动作了。&lt;/p&gt;
&lt;h4 id=&quot;在新的本地分支工作&quot;&gt;&lt;a href=&quot;#在新的本地分支工作&quot; class=&quot;headerlink&quot; title=&quot;在新的本地分支工作&quot;&gt;&lt;/a&gt;在新的本地分支工作&lt;/h4&gt;&lt;p&gt;类似，“日常工作”中的工作周期操作，这个时候，你就可以在新分支中进行大刀阔斧的工作了，直到分支中代码符合要求。&lt;/p&gt;
&lt;h4 id=&quot;推送成为作为远程分支&quot;&gt;&lt;a href=&quot;#推送成为作为远程分支&quot; class=&quot;headerlink&quot; title=&quot;推送成为作为远程分支&quot;&gt;&lt;/a&gt;推送成为作为远程分支&lt;/h4&gt;&lt;p&gt;如果想把分支分享给别人，可以推送到远程版本库，这样别人可以根据需要来把你的分支代码更新到他自己的本地仓库，例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin features/batch_remove&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;合并或衍合远程分支&quot;&gt;&lt;a href=&quot;#合并或衍合远程分支&quot; class=&quot;headerlink&quot; title=&quot;合并或衍合远程分支&quot;&gt;&lt;/a&gt;合并或衍合远程分支&lt;/h4&gt;&lt;p&gt;在分支中工作一段时间后，确认相关的功能代码、测试代码、文档等都提交完毕了，单元测试通过，大家 code review 一致认为没问题，审核通过，最后该分支的持续集成（CI）完整 build 通过。这个时候，就可以进行合并的操作了。&lt;/p&gt;
&lt;p&gt;其实前面也提过类似操作，这里再类似重复一遍，如果用合并：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge features/batch_remove&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 如果没提示冲突，那就合并成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 如果这个时候就提示你代码冲突了，处理完冲突的代码后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff  # code review 下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add batch.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 日志中就多了一条合并操作的日志了&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果用衍合：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rebase features/batch_remove&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 如果没提示冲突，那就衍合成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 如果这个时候就提示你代码冲突了，处理完冲突的代码后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff  # code review 下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rebase --continue  # 有时候会 git rebase --skip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 直到不用再 rebase 为止&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里也提下直接合并本地分支，有时候你创建的分支只是自己用用，没有共享给别人，因为本地已经有了这份分支代码了，那么就省去 &lt;code&gt;git fetch&lt;/code&gt; 操作，类似上述方式合并或衍合代码就行。&lt;/p&gt;
&lt;p&gt;对比 Subversion 的分支合并操作，实在是简化不少。&lt;/p&gt;
&lt;h4 id=&quot;删除分支&quot;&gt;&lt;a href=&quot;#删除分支&quot; class=&quot;headerlink&quot; title=&quot;删除分支&quot;&gt;&lt;/a&gt;删除分支&lt;/h4&gt;&lt;p&gt;如果确认工作完毕的分支不再需要了，那就记得及时清理掉，删除远程分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin :features/batch_remove&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删除本地分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -d features/batch_remove&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;顺便说下，一段时间后，一定有一堆别人的分支，然后你 &lt;code&gt;git fetch&lt;/code&gt; 下来了，这样就出现在本地的分支清单中，但远程版本库中已经删除了，如果想本地分支清单干净些，可以在 &lt;code&gt;git fetch&lt;/code&gt; 时候这样执行：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all -p&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Ship-it&quot;&gt;&lt;a href=&quot;#Ship-it&quot; class=&quot;headerlink&quot; title=&quot;Ship it&quot;&gt;&lt;/a&gt;Ship it&lt;/h3&gt;&lt;p&gt;可能在平时的研发分支工作一段时间后，并且测试完毕，大家觉得符合发布条件了。终于可以进入到版本发布阶段的工作了。&lt;/p&gt;
&lt;h4 id=&quot;创建发布分支&quot;&gt;&lt;a href=&quot;#创建发布分支&quot; class=&quot;headerlink&quot; title=&quot;创建发布分支&quot;&gt;&lt;/a&gt;创建发布分支&lt;/h4&gt;&lt;p&gt;一般来说这个时候已经将在某个发布分支上工作了，比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b release-1.2 develop  # develop 就是平时的研发分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ release.sh 1.2  # 比如有个执行发布脚本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;打标签&quot;&gt;&lt;a href=&quot;#打标签&quot; class=&quot;headerlink&quot; title=&quot;打标签&quot;&gt;&lt;/a&gt;打标签&lt;/h4&gt;&lt;p&gt;确定可以发布了，就开始打标签吧，比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge --no-ff release-1.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git tag -a v1.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git tag  # 确认下打上了标签了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin v1.2  # 推送标签到远程版本库&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;正式发布&quot;&gt;&lt;a href=&quot;#正式发布&quot; class=&quot;headerlink&quot; title=&quot;正式发布&quot;&gt;&lt;/a&gt;正式发布&lt;/h4&gt;&lt;p&gt;发布又是一个比较复杂的主题，比如：能快速发布、快速回滚（包括数据回滚）、灰度发布等等，在构建发布工具中会详细进行介绍，这里就简单罗列下。&lt;/p&gt;
&lt;p&gt;一般来说，根据实际情况，可以记录下来发布相关的操作过程。很多环节可以写脚本将来的人工操作改成自动化操作。以后只要执行发布脚本执行一键发布就可以了。&lt;/p&gt;
&lt;h3 id=&quot;其它场景&quot;&gt;&lt;a href=&quot;#其它场景&quot; class=&quot;headerlink&quot; title=&quot;其它场景&quot;&gt;&lt;/a&gt;其它场景&lt;/h3&gt;&lt;p&gt;可能还有很多别的场景，比较零散，但也算经常用到。&lt;br&gt;code review 查看代码，要知道对应代码是由谁写的，好询问了解具体代码的思路：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git blame&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;跟踪问题时候，会查看日志，更方便历史代码定位：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;觉得完整的 Git 命令太长，想用类似 Subversion 的缩写命令，可以用 &lt;code&gt;alias&lt;/code&gt;，比如配置文件中可以写上：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[alias]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    br = branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ci = commit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    co = checkout&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    diffs = diff --staged&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    st = status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lg = log --graph --abbrev-commit --decorate --format=format:&amp;apos;%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n&amp;apos;&amp;apos;          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)&amp;apos; --all&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有时候合并或衍合代码，但本地有修改了一半的代码没有提交，可以先暂存起来：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git stash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 合并或衍合完毕代码后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git stash pop  # 恢复刚才修改了一半的代码&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;原来的一个项目想拆分多个项目，又想保留版本仓库记录，可以用下 &lt;code&gt;git subtree split&lt;/code&gt;，例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git subtree split --prefix=plugins/sqli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Git 不支持空文件夹加入版本控制，变通方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir downloads&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ vim downloads/.gitignore  # 增加 * 和 !.gitignore 这两条规则&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;永远别忘了-help&quot;&gt;&lt;a href=&quot;#永远别忘了-help&quot; class=&quot;headerlink&quot; title=&quot;永远别忘了 help&quot;&gt;&lt;/a&gt;永远别忘了 help&lt;/h3&gt;&lt;p&gt;对于习惯命令行下编程的程序员来说，多看帮助总是好的，直接执行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git help&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到 Git 的常用命令，如果想看到更全的 Git 命令，可以执行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git help -a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;单独查看某个命令的帮助，可以执行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git help add  # 比如 add 命令&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;会发现更多的命令，这个相比 Subversion 的命令更多，所以看起来也更复杂些，不过Git 本身也比 Subversion 更灵活、更好，比如：分支的使用、历史提交修改等。&lt;/p&gt;
&lt;h3 id=&quot;好习惯&quot;&gt;&lt;a href=&quot;#好习惯&quot; class=&quot;headerlink&quot; title=&quot;好习惯&quot;&gt;&lt;/a&gt;好习惯&lt;/h3&gt;&lt;p&gt;这里顺带说下几个使用 Git 的好习惯，但有的其实跟 Git 联系也不算大，只是顺带提下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持工作目录干净。或者说工作目录中的代码变更就为了完成一个任务，即一次只做一件事。完成任务后，就直接 &lt;code&gt;git commit&lt;/code&gt; 提交到本地版本仓库的某个分支中，而不用担心其它任务作出的代码变更无提交。并且，对于分支切换更方便，而不用担心代码被覆盖或冲突的问题。&lt;/li&gt;
&lt;li&gt;Git 的日志信息足够有效。足够有效的意思，是说这次提交作出的变更摘要，只要别人阅读了日志就能知道大概，如果为了深入了解变更细节才会去查看具体代码变更。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit&lt;/code&gt; 前 code review。code review 本身就是个好习惯，提交前确认是一种更为严谨的方式，如果觉得自己 code review 发现不了什么问题，那么随便从身边抓个会代码的，跟别人讲解下代码变更的内容，说不定会发现你没考虑到的问题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit&lt;/code&gt; 前跑单元测试。写单元测试本身也是个不错的习惯，如果项目本身已经有了完备的单元测试覆盖了，那么你对代码的修改，应该能通过单元测试，所以提交前执行一遍是否通过。如果没通过，就得看下是功能代码写的有问题，还是测试代码有问题，比如：功能需求或接口设计有变化，而测试代码没有同步更新。&lt;/li&gt;
&lt;li&gt;有代码变更及时提交。有 Git 这种版本控制工具，本身就是为了记录研发过程，避免意外导致代码丢失，如果为了完成某个任务需要很长时间，代码也很久没有提交，风险太高。这个时候，一般会自己开个分支，而将代码提交到分支中，既解决代码要及时提交的问题，又解决代码提交频繁，可能造成代码不稳定影响别人的问题，因为那个分支只有你自己在工作。而这一点，Git 分支的功能更为强大，更加鼓励多开分支。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h3&gt;&lt;p&gt;这些场景覆盖的 Git 命令其实很有限，如果要完整的熟悉，那就 git help 以及阅读下《Git Pro》这本官方推荐的入门书，有个系统的学习，基础才会更加牢固。&lt;/p&gt;
&lt;h3 id=&quot;后续&quot;&gt;&lt;a href=&quot;#后续&quot; class=&quot;headerlink&quot; title=&quot;后续&quot;&gt;&lt;/a&gt;后续&lt;/h3&gt;&lt;p&gt;另外，这里只是以程序员的场景来简单介绍 Git 使用，对于系统管理员，可能有一部分职责是作为 Git 版本仓库管理员，日常也会遇到的各种场景吧，后续也会简单介绍。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;原文：&lt;a href=&quot;http://pm.readthedocs.io/vcs/git/usage.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://pm.readthedocs.io/vcs/git/usage.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git-scm.com/book/zh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://git-scm.com/book/zh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://source.android.com/source/developing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://source.android.com/source/developing.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.oschina.net/translate/a-successful-git-branching-model&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oschina.net/translate/a-successful-git-branching-model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Git 相比 Subversion，无论概念上还是使用上，复杂度其实是高出一个等级的。为什么这么说？分别看下 &lt;code&gt;git help -a&lt;/code&gt; 和 &lt;code&gt;svn help&lt;/code&gt; 命令清单的对比，单按这个来看，就如果要掌握所有命令的用法，Git 的学习曲线绝对是比 Subversion 高的。尽管如此，但还是有越来越多项目开始用 Git 来做源码管理了。&lt;/p&gt;
&lt;p&gt;实际中，我们用到的的 Git 命令还是很有限的，可能也就 &lt;code&gt;git help&lt;/code&gt; 中那些而已。下面就类似 &lt;a href=&quot;http://blog.keepmovingxin.com/2016/05/20/SVN-Workflow/&quot;&gt;SVN命令用法：程序员的场景&lt;/a&gt; 一样，结合实际场景说下 Git 的常用命令用法。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://blog.keepmovingxin.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>SVN命令用法：程序员的场景</title>
    <link href="http://blog.keepmovingxin.com/2016/05/20/SVN-Workflow/"/>
    <id>http://blog.keepmovingxin.com/2016/05/20/SVN-Workflow/</id>
    <published>2016-05-20T14:31:59.000Z</published>
    <updated>2016-05-24T02:34:52.000Z</updated>
    
    <content type="html">&lt;p&gt;SVN有不少命令，其实常用的也就那么几个，可以结合下实际的使用场景，来说明下SVN的命令用法。&lt;br&gt;当然可能对很多人来说，最实用的熟悉方式，就是直接运行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn help (?, h)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就入门了，但为了更好的记忆，有个实际场景也是个不错的选择。&lt;br&gt;注解：括号中的是该命令的缩写或别名，有的可以少打几个字母，后面也有类似描述。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;“新人报道”&quot;&gt;&lt;a href=&quot;#“新人报道”&quot; class=&quot;headerlink&quot; title=&quot;“新人报道”&quot;&gt;&lt;/a&gt;“新人报道”&lt;/h3&gt;&lt;p&gt;你刚入职一家公司，或新加入某个团队，立马参与到一个项目中，项目代号Norther，那么就得获取项目代码，开始你的项目生涯。这个时候一般你需要签出项目代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn checkout (co) https://scms.ship.it/svn/norther/trunk norther&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认工作目录的SVN信息，说明已经纳入版本控制了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/projects/norther&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn info&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认没问题了，就运行项目中的构建脚本，然后就可以熟悉代码，展开具体工作了。&lt;br&gt;当然，有的时候，有一个新项目是由你发起的，你要将初始化的项目工程放到SVN版本仓库中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn import souther https://scms.ship.it/svn&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认项目已经在版本仓库中了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn list (ls) https://scms.ship.it/svn/souther/trunk&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;应该就可以看到Souther项目的根目录结构了。&lt;/p&gt;
&lt;h3 id=&quot;日常工作&quot;&gt;&lt;a href=&quot;#日常工作&quot; class=&quot;headerlink&quot; title=&quot;日常工作&quot;&gt;&lt;/a&gt;日常工作&lt;/h3&gt;&lt;p&gt;当你已经逐渐融入了一个项目，可能一天的工作场景或完成某个任务的工作周期是这样的：&lt;/p&gt;
&lt;h4 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h4&gt;&lt;p&gt;无论是清早或下午或晚上，开始了你的一天工作，你首先会更新你的工作目录：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/projects/norther&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn update (up)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样你就可以在最新的项目代码基础上工作了。&lt;/p&gt;
&lt;h4 id=&quot;修改&quot;&gt;&lt;a href=&quot;#修改&quot; class=&quot;headerlink&quot; title=&quot;修改&quot;&gt;&lt;/a&gt;修改&lt;/h4&gt;&lt;p&gt;可能你写了一个新的模块，需要纳入项目的版本控制：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn add tools.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你发现某个模块已经陈旧了，不再使用了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn delete (del, remove, rm) utils.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你发现一个模块的命名不太合理，需要改名：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn move (mv) model.py models.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你要创建一个新的较大的模块，需要归档为目录的方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn mkdir groups&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你发现要写的模块代码布局类似于旧的模块，直接复制个代码模版：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn copy (cp) users/tests.py groups/tests.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然，其实最常见的情况其实还是打开编辑器，比如Vim，修改已经存在的代码，这个就跟SVN命令无关了。&lt;/p&gt;
&lt;h4 id=&quot;检查&quot;&gt;&lt;a href=&quot;#检查&quot; class=&quot;headerlink&quot; title=&quot;检查&quot;&gt;&lt;/a&gt;检查&lt;/h4&gt;&lt;p&gt;忙碌的一天过去了，或者一个任务完成了，这个时候一般会将你的工作成果，也就是代码更新到版本仓库。&lt;br&gt;习惯上会先检查下修改状态：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn status (stat, st)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看到一些SVN状态位信息，确认是修改了哪些文件，之后一般会自己code review一下代码的改动，可能有的人会习惯直接用SVN方式来查看：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn diff (di)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后本地运行下相关的单元测试，确认是否有问题。一般来说这个时候，没有什么特殊情况，就直接进入“提交”阶段了，然后结束一个工作日或工作周期，但难免会有些特殊情况出现。&lt;/p&gt;
&lt;h4 id=&quot;取消修改&quot;&gt;&lt;a href=&quot;#取消修改&quot; class=&quot;headerlink&quot; title=&quot;取消修改&quot;&gt;&lt;/a&gt;取消修改&lt;/h4&gt;&lt;p&gt;当你code review完后，发现有些改动不满意，你可能又会取消这些修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn revert main.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;解决冲突&quot;&gt;&lt;a href=&quot;#解决冲突&quot; class=&quot;headerlink&quot; title=&quot;解决冲突&quot;&gt;&lt;/a&gt;解决冲突&lt;/h4&gt;&lt;p&gt;当你打算提交时候，习惯上一般会再次更新自己的工作目录，现在合并下别人的工作成果（如果有的话）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn update (up)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能这个时候更新完代码，你对某个模块的代码有改动，别人也改动了同一个模块的代码，可能就会产生代码冲突。&lt;/li&gt;
&lt;li&gt;也可能有的人没这习惯，就直接提交代码，发现提交没有成功，一看，原来是别人提交的代码刚好也改动了你提交的代码，也产生了冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论哪种情况，就是代码冲突了，需要解决冲突，一般会人工确认代码合并，处理冲突的代码，是选择别人的处理，还是自己的处理，还是要额外处理，处理完毕后，执行命令，比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn resolve main.py --accept working&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另外，也有个resolved命令，用来删除“冲突”状态，但官方说被上面命令替换了，不推荐使用了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn resolved main.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;提交&quot;&gt;&lt;a href=&quot;#提交&quot; class=&quot;headerlink&quot; title=&quot;提交&quot;&gt;&lt;/a&gt;提交&lt;/h4&gt;&lt;p&gt;最后，一切确认没问题了：code review完毕，自己觉得代码满意了；然后也合并完别人的修改并且没有冲突了；运行单元测试也通过了。那么就提交代码吧：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn commit (ci)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;在分支工作&quot;&gt;&lt;a href=&quot;#在分支工作&quot; class=&quot;headerlink&quot; title=&quot;在分支工作&quot;&gt;&lt;/a&gt;在分支工作&lt;/h3&gt;&lt;p&gt;在 &lt;a href=&quot;http://zhengkun.info/2013/09/01/vcs-svn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源代码的管理和发布：以SVN为例&lt;/a&gt; 这篇文章中，介绍的SVN开发模式中，涉及分支的概念，一般来说会有以下3种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贡献新特性。也就是说，为了增加新的功能，或者对旧功能的改进等等。&lt;/li&gt;
&lt;li&gt;“除虫”。就是日常说的缺陷修复。&lt;/li&gt;
&lt;li&gt;发布阶段（发布分支）-&amp;gt;旧版本维护（旧版本维护分支）。这个概念稍微复杂，trunk研发到某个阶段，代码符合某个版本发布条件了，就会新建1个发布分支，测试没问题了，就在这个分支上进行发布；发布完成后，这个版本的维护就在这个维护分支上进行了；这个时候trunk已经进行最新版本的研发了，所以说这个分支是个旧版本维护分支。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述说的3种分支情况，前两个分支的生命周期比较短，新特性搞定或“除虫”完毕，合并代码到trunk后就结束自己的生命周期了。&lt;/p&gt;
&lt;p&gt;最后一种情况，生命周期相对较长，如果这个分支需要维护的版本还要支持，那么就得一直存在，直到不再维护为止。&lt;/p&gt;
&lt;p&gt;下面说下在分支工作的实际场景，按顺序：&lt;/p&gt;
&lt;h4 id=&quot;创建新分支&quot;&gt;&lt;a href=&quot;#创建新分支&quot; class=&quot;headerlink&quot; title=&quot;创建新分支&quot;&gt;&lt;/a&gt;创建新分支&lt;/h4&gt;&lt;p&gt;当上述3种场景发生，确定要新开个分支来写代码，先复制trunk到分支，这里以贡献新特性为例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn copy (cp) https://scms.ship.it/svn/norther/trunk https://scms.ship.it/svn/norther/branches/feature1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;切换到新分支&quot;&gt;&lt;a href=&quot;#切换到新分支&quot; class=&quot;headerlink&quot; title=&quot;切换到新分支&quot;&gt;&lt;/a&gt;切换到新分支&lt;/h4&gt;&lt;p&gt;一般来说这个时候本地的工作目录是trunk，确定本地工作目录是干净的，为后续在分支工作，以及合并分支做好准备，避免可能的各种代码冲突或工作成果代码被覆盖等情况出现。&lt;/p&gt;
&lt;p&gt;确认当前所在的SVN工作目录，比如，可能是在trunk的SVN路径：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn info&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认工作目录干净：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn status (st)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;切换到刚才新创建的分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn switch (sw) https://scms.ship.it/svn/norther/branches/feature1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认切换后的SVN工作目录，应该就是在刚才新创建的分支的SVN路径了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn info&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;在新分支工作&quot;&gt;&lt;a href=&quot;#在新分支工作&quot; class=&quot;headerlink&quot; title=&quot;在新分支工作&quot;&gt;&lt;/a&gt;在新分支工作&lt;/h4&gt;&lt;p&gt;类似，“日常工作”中的工作周期操作，这个时候，你就可以在新分支中进行大刀阔斧的工作了，直到分支中代码符合合并到trunk的的条件了。&lt;/p&gt;
&lt;h4 id=&quot;合并分支到trunk&quot;&gt;&lt;a href=&quot;#合并分支到trunk&quot; class=&quot;headerlink&quot; title=&quot;合并分支到trunk&quot;&gt;&lt;/a&gt;合并分支到trunk&lt;/h4&gt;&lt;p&gt;在分支中工作一段时间后，确认相关的功能代码、测试代码、文档等都提交完毕了，单元测试通过，大家code review一致认为没问题，审核通过，最后该分支的持续集成（CI）完整build通过。这个时候，就可以进行合并到trunk的操作了。&lt;/p&gt;
&lt;p&gt;确保下面操作是在工作目录的根目录下进行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/projects/norther/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认分支工作目录干净，没有需要提交的代码了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn status (st)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;切换工作目录回trunk，如果由于代码变动大有冲突，就解决冲突，特别如果有目录变动很可能有目录冲突：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn switch (sw) https://scms.ship.it/svn/norther/trunk&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认切换后的SVN工作目录是trunk：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn info&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;先在本地合并分支的代码，合并过程可能会有代码冲突，解决冲突，合并会指定版本范围，一般都是分支建立时候的版本号到分支工作完毕时候最后一次提交的版本号：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn merge -r9527:9549 https://scms.ship.it/svn/norther/branches/feature1 .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认本地代码变更，code review一下，执行下单元测试：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn status (st)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn diff (di)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认代码没问题，正式提交代码到trunk，SVN的提交日志说明下合并信息：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn commit (ci)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;删除分支&quot;&gt;&lt;a href=&quot;#删除分支&quot; class=&quot;headerlink&quot; title=&quot;删除分支&quot;&gt;&lt;/a&gt;删除分支&lt;/h4&gt;&lt;p&gt;如果确认工作完毕的分支不再需要了，那就记得及时清理掉：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn delete (del, remove, rm) https://scms.ship.it/svn/norther/branches/feature1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Ship-it&quot;&gt;&lt;a href=&quot;#Ship-it&quot; class=&quot;headerlink&quot; title=&quot;Ship it&quot;&gt;&lt;/a&gt;Ship it&lt;/h3&gt;&lt;p&gt;在上面说的发布分支工作一段时间后，并且测试完毕，大家觉得符合发布条件了。终于可以进入到版本发布阶段的工作了。&lt;br&gt;具体故事场景可以看 源代码的管理和发布：以SVN为例 这篇文章，有对“发布分支”的介绍。&lt;br&gt;一般来说这个时候已经将trunk复制一份到了发布分支了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn copy (cp) https://scms.ship.it/svn/norther/trunk https://scms.ship.it/branches/1.0.x&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;打标签&quot;&gt;&lt;a href=&quot;#打标签&quot; class=&quot;headerlink&quot; title=&quot;打标签&quot;&gt;&lt;/a&gt;打标签&lt;/h4&gt;&lt;p&gt;复制最新的发布分支为标签：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn copy (cp) https://scms.ship.it/svn/norther/branches/1.0.x https://scms.ship.it/svn/norther/tags/1.0.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;正式发布&quot;&gt;&lt;a href=&quot;#正式发布&quot; class=&quot;headerlink&quot; title=&quot;正式发布&quot;&gt;&lt;/a&gt;正式发布&lt;/h4&gt;&lt;p&gt;发布又是一个比较复杂的主题，比如：能快速发布、快速回滚（包括数据回滚）、灰度发布等等，在 构建发布工具 中会详细进行介绍，这里就简单罗列下。&lt;/p&gt;
&lt;p&gt;情况1：完整包。导出代码，然后执行打包命令，进行完整安装：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn export https://scms.ship.it/svn/norther/tags/1.0.0 norther&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;情况2：补丁升级包。相对复杂，可能会综合运用下列命令，制作补丁安装升级包：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn status (st)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn diff (di)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn patch&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;情况3：线上更新。一般不太推荐，需要注意不要泄露“.svn”，特别是旧版本的SVN，每个目录下都有“.svn”。可能会用到下列命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn update (up)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn switch (sw) https://scms.ship.it/svn/norther/tags/1.0.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一般来说，根据实际情况，可以记录下来发布相关的操作过程。很多环节可以写脚本将原来的人工操作改成自动化操作。以后只要执行发布脚本执行一键发布就可以了。&lt;/p&gt;
&lt;h3 id=&quot;其它场景&quot;&gt;&lt;a href=&quot;#其它场景&quot; class=&quot;headerlink&quot; title=&quot;其它场景&quot;&gt;&lt;/a&gt;其它场景&lt;/h3&gt;&lt;p&gt;可能还有很多别的场景，比较零散，但也算经常用到。&lt;/p&gt;
&lt;p&gt;code review查看代码，要知道对应代码是由谁写的，好询问了解具体代码的思路：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn blame (praise, annotate, ann)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;跟踪问题时候，会查看日志，更方便历史代码定位：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;经常碰到代码锁定或很多诡异情况：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn cleanup&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;编辑特定属性，比如：定义忽略规则；依赖其它SVN路径等等&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn propedit (pedit, pe) svn:ignore .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn propedit (pedit, pe) svn:externals .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;SVN客户端更新，使用新的SVN客户端了，有时候会发现本地工作目录SVN相关信息陈旧，会提示你升级：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn upgrade&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;好习惯&quot;&gt;&lt;a href=&quot;#好习惯&quot; class=&quot;headerlink&quot; title=&quot;好习惯&quot;&gt;&lt;/a&gt;好习惯&lt;/h3&gt;&lt;p&gt;这里顺带说下几个使用SVN的好习惯，但有的其实跟SVN联系也不算大，只是顺带提下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持工作目录干净。或者说工作目录中的代码变更就为了完成一个任务，即一次只做一件事。完成任务后，就直接&lt;code&gt;svn commit (ci)&lt;/code&gt;提交到版本仓库，而不用担心其它任务作出的代码变更无提交。并且，对于分支和trunk间切换更方便，而不用担心代码被覆盖或冲突的问题。&lt;/li&gt;
&lt;li&gt;SVN的日志信息足够有效。足够有效的意思，是说这次提交作出的变更摘要，只要别人阅读了日志就能知道大概，如果为了深入了解变更细节才会去查看具体代码变更。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn commit (ci)&lt;/code&gt;前先&lt;code&gt;svn update (up)&lt;/code&gt;。可能不更新提交也没问题，但也有可能会相关代码被别人改动了，而提交不了，为了避免这种情况，先本地更新完毕，确保别人的改动不影响你对代码修改的意图。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn commit (ci)&lt;/code&gt;前code review。code review本身就是个好习惯，提交前确认是一种更为严谨的方式，如果觉得自己code review发现不了什么问题，那么随便从身边抓个会代码的，跟别人讲解下代码变更的内容，说不定会发现你没考虑到的问题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn commit (ci)&lt;/code&gt;前跑单元测试。写单元测试本身也是个不错的习惯，如果项目本身已经有了完备的单元测试覆盖了，那么你对代码的修改，应该能通过单元测试，所以提交前执行一遍是否通过。如果没通过，就得看下是功能代码写的有问题，还是测试代码有问题，比如：功能需求或接口设计有变化，而测试代码没有同步更新。&lt;/li&gt;
&lt;li&gt;有代码变更及时提交。有SVN这种版本控制工具，本身就是为了记录研发过程，避免意外导致代码丢失，如果为了完成某个任务需要很长时间，代码也很久没有提交，风险太高。这个时候，一般会自己开个分支，而将代码提交到分支中，既解决代码要及时提交的问题，又解决代码提交频繁，可能造成代码不稳定影响别人的问题，因为那个分支只有你自己在工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h3&gt;&lt;p&gt;这些场景覆盖的SVN命令其实很有限，如果要完整的熟悉，那就&lt;code&gt;svn help&lt;/code&gt;以及阅读下SVN的官方手册，有个系统的学习，基础才会更加牢固。&lt;/p&gt;
&lt;h3 id=&quot;后续&quot;&gt;&lt;a href=&quot;#后续&quot; class=&quot;headerlink&quot; title=&quot;后续&quot;&gt;&lt;/a&gt;后续&lt;/h3&gt;&lt;p&gt;另外，这里只是以程序员的场景来简单介绍SVN使用，对于系统管理员，可能有一部分职责是作为SVN版本仓库管理员，日常也会遇到的各种场景吧，后续也会简单介绍。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;原文：&lt;a href=&quot;http://pm.readthedocs.io/vcs/svn/usage.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://pm.readthedocs.io/vcs/svn/usage.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.subversion.org.cn/svnbook/1.4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.subversion.org.cn/svnbook/1.4/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;SVN有不少命令，其实常用的也就那么几个，可以结合下实际的使用场景，来说明下SVN的命令用法。&lt;br&gt;当然可能对很多人来说，最实用的熟悉方式，就是直接运行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn help (?, h)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就入门了，但为了更好的记忆，有个实际场景也是个不错的选择。&lt;br&gt;注解：括号中的是该命令的缩写或别名，有的可以少打几个字母，后面也有类似描述。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="SVN" scheme="http://blog.keepmovingxin.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>(译)tolua参考手册--accessing C/C++ code from Lua</title>
    <link href="http://blog.keepmovingxin.com/2016/05/14/Cocos2dx-tolua++/"/>
    <id>http://blog.keepmovingxin.com/2016/05/14/Cocos2dx-tolua++/</id>
    <published>2016-05-14T14:09:28.000Z</published>
    <updated>2016-05-23T02:40:50.000Z</updated>
    
    <content type="html">&lt;p&gt;项目使用Cocos2dx+lua框架做的，用到luabinding实现C++代码绑定到lua层使用，所以学习一下tolua++工具的原理和使用，在这做个记录。&lt;/p&gt;
&lt;p&gt;tolua++是tolua的扩展版本，是一款能够集成C/C++与lua代码的工具。在面向C++方面，tolua++包含了一些新的特性比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持&lt;code&gt;std::string&lt;/code&gt;作为基本类型（这个可以由一个命令行选项关闭）&lt;/li&gt;
&lt;li&gt;支持类模板&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tecgraf.puc-rio.br/~celes/tolua/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tolua&lt;/a&gt;这款工具，极大的简化了C/C++代码与lua代码的集成。基于一个干净的头文件（或者从实际头文件中提取），tolua会自动生成从lua访问C/C++功能的绑定代码。使用Lua API和标记方法设施，tolua解析C/C++常数，外部变量、函数、类和方法绑定到Lua。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/tolua-3.2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;tolua如何工作-How-tolua-works&quot;&gt;&lt;a href=&quot;#tolua如何工作-How-tolua-works&quot; class=&quot;headerlink&quot; title=&quot;tolua如何工作 (How tolua works)&quot;&gt;&lt;/a&gt;tolua如何工作 (How tolua works)&lt;/h3&gt;&lt;p&gt;使用tolua，我们需要创建一个package文件（译者注：pkg文件），即一个从C/C++实际头文件整理后的头文件，列举出我们想导出到lua环境中的那些常量、变量、函数、类以及方法，然后tolua会解析该文件并且创建自动绑定C/C++代码到lua的C/C++文件，如果将创建的文件同我们的应用链接起来，我们就可以从lua中访问指定的C/C++代码。&lt;/p&gt;
&lt;p&gt;让我们先看一些例子。如果我们指定下面的c头文件作为输入到tolua:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define FALSE 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define TRUE 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enum &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; POINT = 100, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; LINE, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; POLYGON&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object* createObejct (int type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void drawObject (Object* obj, double red, double green, double blue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int isSelected (Object* obj);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;会自动生成一个绑定上面代码到Lua层的C文件。这样，我们在lua代码里就可以访问C代码。如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myLine = createObject(LINE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if isSelected(myLine) == TRUE then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  drawObject(myLine, 1.0, 0.0, 0.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  drawObject(myLine, 1.0, 1.0, 1.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此外，考虑下面类似C++头文件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define FALSE 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define TRUE 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Shape&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void draw (void);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void draw (double red, double green, double blue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int isSelected (void);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Line : public Shape&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Line (double x1, double y1, double x2, double y2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ~Line (void);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果将上面的C++头文件输入给tolua，会自定生成一个Lua层访问C++代码的C++文件。这样，就可以使用如下Lua代码访问C++:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myLine = Line:new (0,0,1,1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if myLine:isSelected() == TRUE then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; myLine:draw(1.0,0.0,0.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; myLine:draw()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myLine:delete()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;传给tolua的package文件(.pkg)不是原本的C/C++头文件，而是手动处理过的版本。例如，外部代码访问的C++方法应该是public的，但并没有public修饰。tolua并没有实现对C/C++代码的完全解析，但它能够导出一些声明用于描述的功能到Lua层。因此，tolua将会提取出用户指定的代码以用于解析头文件。&lt;/p&gt;
&lt;h3 id=&quot;tolua的使用-How-to-use-toLua&quot;&gt;&lt;a href=&quot;#tolua的使用-How-to-use-toLua&quot; class=&quot;headerlink&quot; title=&quot;tolua的使用 (How to use toLua)&quot;&gt;&lt;/a&gt;tolua的使用 (How to use toLua)&lt;/h3&gt;&lt;p&gt;tolua由两部分代码组成：可执行程序和静态库（an executable and a library）。可执行程序用于解析，读入package文件，然后输出C/C++代码，该代码提供了从lua层访问C/C++层的绑定。如果package文件是与C++类似的代码（例如包括类的定义），就会生成一份C++代码。如果package文件是与C类似的代码（例如不包括类），就会生成一份C代码。tolua可接受一些选项。运行&lt;code&gt;tolua -h&lt;/code&gt;显示当前可接受的选项。例如，要解析一个名为&lt;code&gt;myfile.pkg&lt;/code&gt;生成一个名为&lt;code&gt;myfile.c&lt;/code&gt;的绑定代码，我们需要输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tolua -o myfile.c myfile.pkg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生成的代码必须编译并和应用程序链接，才能提供给Lua进行访问。每个被解析的文件代表导出到Lua的package。默认情况下，package的名称就是输入文件的根名称（例子中为&lt;code&gt;myfile&lt;/code&gt;），用户可以指定一个不同的名称给package：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tolua -n pkgname -o myfile.c myfile.pkg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;package还应该明确的初始化。为了从C/C++代码中初始化package，我们必须声明和调用初始化函数。初始化函数被定义为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int tolua_pkgname_open (void);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中pkgname表示绑定的package名称。如果我们使用C++，我们可以选择自动初始化：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tolua -a -n pkgname -o myfile.c myfile.pkg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当前tolua版本还导出绑定的关闭功能，可称为解绑定package：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void tolua_pkgname_close (void);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还有，&lt;code&gt;open&lt;/code&gt;和&lt;code&gt;close&lt;/code&gt;功能的原型可以输出一个头文件，通过&lt;code&gt;-H&lt;/code&gt;选项设置。&lt;/p&gt;
&lt;p&gt;tolua生成的绑定代码使用了一系列tolua库里面的函数。因此，这个库同样需要被链接到应用程序中。&lt;code&gt;tolua.h&lt;/code&gt;也是有必须要编译生成的代码。。&lt;/p&gt;
&lt;p&gt;应用程序无需绑定任何package文件也可以使用tolua的面向对象框架。在这种情况下，应用程序必须调用tolua初始化函数（此函数被任何package文件初始化函数调用）：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int tolua_open (void);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果要使用多个Lua状态(&lt;code&gt;Lua state&lt;/code&gt;)，设置一个Lua状态(&lt;code&gt;Lua state&lt;/code&gt;)后，我们需要调用一个函数来恢复tolua内部状态:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void tolua_restorestate (void);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;tolua的一些基本概念-Basic-Concepts&quot;&gt;&lt;a href=&quot;#tolua的一些基本概念-Basic-Concepts&quot; class=&quot;headerlink&quot; title=&quot;tolua的一些基本概念 (Basic Concepts)&quot;&gt;&lt;/a&gt;tolua的一些基本概念 (Basic Concepts)&lt;/h3&gt;&lt;p&gt;使用tolua的第一步就是创建package文件。我们从真正的头文件入手，将想要暴露给lua的特性转换成tolua可以理解的格式。tolua能够理解的格式就是一些简单的C/C++声明。我们从下面几个方面来讨论：&lt;/p&gt;
&lt;h4 id=&quot;文件包含&quot;&gt;&lt;a href=&quot;#文件包含&quot; class=&quot;headerlink&quot; title=&quot;文件包含&quot;&gt;&lt;/a&gt;文件包含&lt;/h4&gt;&lt;p&gt;一个package文件可以包含另外的package文件。一般格式是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$&amp;lt;include_file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;基本类型-Basic-types&quot;&gt;&lt;a href=&quot;#基本类型-Basic-types&quot; class=&quot;headerlink&quot; title=&quot;基本类型 (Basic types)&quot;&gt;&lt;/a&gt;基本类型 (Basic types)&lt;/h4&gt;&lt;p&gt;tolua会自动映射C/C++的基本类型到lua的基本类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;char&lt;/code&gt;,&lt;code&gt;int&lt;/code&gt;,&lt;code&gt;float&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;类型被映射为lua中的&lt;code&gt;number&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char*&lt;/code&gt;被映射为lua中的&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void*&lt;/code&gt;被映射为lua中的&lt;code&gt;userdata&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C/C++中的数据类型前面可能有修饰语（如unsigned, static, short, const等等）。然而我们要注意到tolua会忽略基本类型前面的修饰语const。因此，我们给lua传递一个基本类型常量然后再从lua中传递回给C/C++代码，常量到非常量的转换会被悄悄的完成。&lt;/p&gt;
&lt;p&gt;C/C++函数也可以对lua对象进行明确的操作。&lt;code&gt;lua_Object&lt;/code&gt;被认为是一个基本类型，任何lua值都符合。&lt;/p&gt;
&lt;p&gt;tolua++新特性：C++中的&lt;code&gt;string&lt;/code&gt;类型同样被认为是基本类型，会被当作值传递给lua(使用c_str()方法)。这个功能可以使用命令行选项&lt;code&gt;-S&lt;/code&gt;进行关闭。&lt;/p&gt;
&lt;h4 id=&quot;用户定义的类型-User-defined-types&quot;&gt;&lt;a href=&quot;#用户定义的类型-User-defined-types&quot; class=&quot;headerlink&quot; title=&quot;用户定义的类型 (User defined types)&quot;&gt;&lt;/a&gt;用户定义的类型 (User defined types)&lt;/h4&gt;&lt;p&gt;在package文件里的所有其他类型都会被认为是用户自定义类型。它们会映射到lua的userdata类型。lua只能存储指向用户自定义类型的指针；但是，tolua会自动采取措施来处理引用和值。例如，如果一个函数或方法返回一个用户定义类型的值，当这个值返回给lua的时候，tolua会分配一个克隆对象，同时会设置垃圾收集标记，以便在lua不再使用该对象时会自动释放。&lt;/p&gt;
&lt;p&gt;对于用户定义类型，常量是被保留的，因此将用户自定义类型的非常量作为常量传递给一个函数时，会产生类型不匹配的错误。&lt;/p&gt;
&lt;h4 id=&quot;NULL和nil-NULL-and-nil&quot;&gt;&lt;a href=&quot;#NULL和nil-NULL-and-nil&quot; class=&quot;headerlink&quot; title=&quot;NULL和nil (NULL and nil)&quot;&gt;&lt;/a&gt;NULL和nil (NULL and nil)&lt;/h4&gt;&lt;p&gt;C/C++的NULL或0指针映射到lua中的nil类型。反之，nil却可以被指定为任何C/C++指针类型。这对任何类型都有效：&lt;code&gt;char*&lt;/code&gt;, &lt;code&gt;void*&lt;/code&gt;以及用户自定义类型指针。&lt;/p&gt;
&lt;h4 id=&quot;宏定义类型-Typedefs&quot;&gt;&lt;a href=&quot;#宏定义类型-Typedefs&quot; class=&quot;headerlink&quot; title=&quot;宏定义类型 (Typedefs)&quot;&gt;&lt;/a&gt;宏定义类型 (Typedefs)&lt;/h4&gt;&lt;p&gt;tolua还接受简单类型定义的package文件。任何发生的一种定义是由tolua映射后的基类型。他们是非常有用的，因为几个包定义基本的C/C++类型自己的类型。例如，可以定义一个真正代表两个类型。在这种情况下,真正的可以用来指定变量类型package文件由tolua解释，但前提是我们包括以下定义之前使用的实际类型&lt;code&gt;real&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef double real;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;否则，&lt;code&gt;real&lt;/code&gt;将被解释为一个用户定义的类型和不会被映射到Lua数字(&lt;code&gt;numbers&lt;/code&gt;)。&lt;br&gt;包含&lt;code&gt;real&lt;/code&gt;的头文件(Including real header files)&lt;/p&gt;
&lt;p&gt;在package文件中，我们必须指定哪个是真正(&lt;code&gt;real&lt;/code&gt;)的头文件,应包含生成的代码可以访问常量,变量,函数,类具有约束。package文件中的任意行开始&lt;code&gt;$ (except $&amp;lt;...&amp;gt;, $[ , and $] lines)&lt;/code&gt;插入到生成绑定C/C++代码没有任何变化，但 &lt;code&gt;$&lt;/code&gt; 本身的消除。我们使用这个特性，包括真正(&lt;code&gt;real&lt;/code&gt;)的头文件。所以，我们的package文件通常会入手一套 &lt;code&gt;$&lt;/code&gt; 开始行指定的文件必须包括在内，也就是说，这些文件是基于package文件。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* specify the files to be included */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$#include &amp;quot;header1.h&amp;quot;                 // include first header&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$#include &amp;quot;header2.h&amp;quot;                 // include second header&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;额外说明，tolua还接受注释，使用C或C++惯例,包内的文件。也可以使用嵌套C注释。&lt;/p&gt;
&lt;p&gt;在下面几节中,我们描述了如何指定C/C++代码绑定到Lua。格式是简单有效的C/C++语句。它非常简单的将是一个真正的C/C++头文件转换成package文件。&lt;/p&gt;
&lt;h3 id=&quot;绑定常量-Binding-constants&quot;&gt;&lt;a href=&quot;#绑定常量-Binding-constants&quot; class=&quot;headerlink&quot; title=&quot;绑定常量 (Binding constants)&quot;&gt;&lt;/a&gt;绑定常量 (Binding constants)&lt;/h3&gt;&lt;p&gt;绑定常量，tolua支持两种绑定常量的方式：&lt;code&gt;define&lt;/code&gt;和 &lt;code&gt;enum&lt;/code&gt;。&lt;br&gt;&lt;code&gt;define&lt;/code&gt;通常的格式是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define NAME [ VALUE ]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的VALUE是可选的。如果这样的代码出现在被解析的文件中，tolua会将&lt;code&gt;NAME&lt;/code&gt;作为lua的全局变量，该全局变量是C/C++的常量，值为VALUE。这里只接受数字常量。&lt;/p&gt;
&lt;p&gt;tolua++新特性：所有的其他预处理指令会被忽略。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;enum&lt;/code&gt;的一般格式：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;enum &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NAME1 [ = VALUE1 ] ,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NAME2 [ = VALUE2 ] ,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NAMEn [ = VALUEn ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同样的，tolua会创建一系列全局变量，命名为&lt;code&gt;NAMEi&lt;/code&gt;，对应着各自的值。&lt;/p&gt;
&lt;h3 id=&quot;绑定外部变量-Binding-external-variables&quot;&gt;&lt;a href=&quot;#绑定外部变量-Binding-external-variables&quot; class=&quot;headerlink&quot; title=&quot;绑定外部变量 (Binding external variables)&quot;&gt;&lt;/a&gt;绑定外部变量 (Binding external variables)&lt;/h3&gt;&lt;p&gt;全局的外部变量也可以被导出。在package头文件指定为:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[extern] type var;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;tolua绑定这样的声明Lua全局变量。因此，在Lua中，我们自然地可以访问C/C++变量。如果非恒定的变量，我们也可以从Lua变量分配一个新值。全局变量表示数组的值也可以绑定到Lua。数组可以是任何类型的。相应的Lua对象数组是Lua表与数值索引；然而，请注意，指数1在Lua中映射到索引0 C/C++数组。数组必须预先设置长度。例如:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;double v[10];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绑定函数-Binding-functions&quot;&gt;&lt;a href=&quot;#绑定函数-Binding-functions&quot; class=&quot;headerlink&quot; title=&quot;绑定函数 (Binding functions)&quot;&gt;&lt;/a&gt;绑定函数 (Binding functions)&lt;/h3&gt;&lt;p&gt;函数也指传统C/C++声明:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type funcname (type1 par1[, type2 par2[,...typeN parN]]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回类型可以为空(void)，这意味着没有返回值。一个函数也可以没有参数。在这种情况下，void可能的列表中指定的参数。参数类型必须遵守已经发布的规则。tolua会创建一个Lua函数绑定C/C++函数。从Lua调用一个函数时，参数类型必须匹配相应的C/C++类型，否则，tolua会生成一个错误报告指定的参数是错误的。如果省略参数名称，tolua会自动命名，但类型应该是基本类型(basic type)或之前使用过的用户类型(user type)。&lt;/p&gt;
&lt;h4 id=&quot;Arrays-数组&quot;&gt;&lt;a href=&quot;#Arrays-数组&quot; class=&quot;headerlink&quot; title=&quot;Arrays (数组)&quot;&gt;&lt;/a&gt;Arrays (数组)&lt;/h4&gt;&lt;p&gt;tolua也处理函数或方法参数表示数组的值。阵列的优点是，它们的值更新相应的Lua表如果C/C++函数改变数组的内容。&lt;br&gt;数组必须指定大小。例如:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (double a[3]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;是一个有效的函数声明为tolua和从Lua不调用这个函数，例如:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p = &amp;#123;1.0,1.5,8.6&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func (p)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;数组维数不需要一个常数表达式，指定的大小也可以由任何表达式，可以在运行时进行。例如:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (int n, int m, double image[n*m]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;也有效的自表达式&lt;code&gt;n * m&lt;/code&gt;绑定函数范围是有效的。然而，请注意，tolua使用动态分配绑定这个函数，能降低性能。&lt;/p&gt;
&lt;p&gt;尽管大小规范，重要的是要知道所有数组传递给实际的C/C++函数在本地绑定函数的范围。所以，如果C/C++函数被称为需要保存数组指针以备后用，绑定的代码将无法正常工作。&lt;/p&gt;
&lt;h4 id=&quot;Overloaded-functions-重载函数&quot;&gt;&lt;a href=&quot;#Overloaded-functions-重载函数&quot; class=&quot;headerlink&quot; title=&quot;Overloaded functions (重载函数)&quot;&gt;&lt;/a&gt;Overloaded functions (重载函数)&lt;/h4&gt;&lt;p&gt;函数重载是支持的。记住名称相同的两个函数之间的区别是基于映射到Lua的参数类型。所以，尽管&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (int a); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void func (double a);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;代表两个不同的函数在C++中，他们是tolua相同的函数，因为int和double映射到相同的Lua类型:数字。&lt;/p&gt;
&lt;p&gt;另一个棘手的情况发生在导出指针。假设:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (char* s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void func (void* p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void func (Object1* ptr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void func (Object2* prt);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;虽然这四个函数代表不同的函数在C++中,Lua声明:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func(nil)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;匹配所有的函数。&lt;/p&gt;
&lt;p&gt;重要的是要知道tolua决定函数将调用在运行时，试图匹配每个提供的函数。tolua首先试图调用指定的函数;如果失败了，tolua然后试之前一个。重复这个过程，直到一个函数调用代码匹配或第一个函数。出于这个原因，失配误差信息，当它发生时，是基于第一个函数规范。当然性能是很重要的，我们可以指定最常用函数作为最后一个，因为它将放在第一位。&lt;/p&gt;
&lt;p&gt;tolua允许使用重载函数在C语言中，查看详细&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/tolua-3.2.html#renaming&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Renaming&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Default-parameter-values-默认参数值&quot;&gt;&lt;a href=&quot;#Default-parameter-values-默认参数值&quot; class=&quot;headerlink&quot; title=&quot;Default parameter values (默认参数值)&quot;&gt;&lt;/a&gt;Default parameter values (默认参数值)&lt;/h4&gt;&lt;p&gt;最后一个函数参数可以有相关联的默认值。在这种情况下，如果用更少的参数，函数被调用的默认值。格式指定默认值是一样的一个用于C++代码:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type funcname (..., typeN-1 parN-1 [= valueN-1], typeN parN [= valueN]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;toLua实现这个功能没有使用任何C++机制;因此，它也可以使用绑定C函数。&lt;/p&gt;
&lt;p&gt;我们也可以指定数组的元素的默认值(没有办法为数组本身，指定一个默认值)。例如:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (int a[5]=0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置默认元素值为零，因此，从Lua函数可以调用未初始化表。&lt;/p&gt;
&lt;p&gt;Lua对象类型(lua_Object)，tolua定义一个常数，可用于指定空值作为默认值:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (lua_Object lo = TOLUA_NIL);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Multiple-returned-values-多个返回值&quot;&gt;&lt;a href=&quot;#Multiple-returned-values-多个返回值&quot; class=&quot;headerlink&quot; title=&quot;Multiple returned values (多个返回值)&quot;&gt;&lt;/a&gt;Multiple returned values (多个返回值)&lt;/h4&gt;&lt;p&gt;In Lua, a function may return any number of values. tolua uses this feature to simulate values passed by reference. If a function parameter is specified as a pointer to or reference of a basic type or a pointer to or reference of a pointer to an user defined type, tolua accepts the corresponding type as input and returns, besides the conventional function returned value, if any, the updated parameter value.&lt;/p&gt;
&lt;p&gt;For instance, consider a C function that swaps two values:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void swap (double* x, double* y);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void swap (double&amp;amp; x, double&amp;amp; y);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If such a function is declared in the package file, tolua binds it as a function receiving two numbers as input and returning two numbers. So, a valid Lua code would be:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x,y = swap(x,y)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If the input values are not used, the use of default parameter value allows calling the function from Lua without specifying them:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void getBox (double* xmin=0, double* xmax=0, double* ymin=0, double* ymax=0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In Lua:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;xmin, xmax, ymin, ymax = getBox()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;With user defined types, we would have for instance:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void update (Point** p);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void update (Point*&amp;amp; p);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绑定结构体-Binding-struct-fields&quot;&gt;&lt;a href=&quot;#绑定结构体-Binding-struct-fields&quot; class=&quot;headerlink&quot; title=&quot;绑定结构体 (Binding struct fields)&quot;&gt;&lt;/a&gt;绑定结构体 (Binding struct fields)&lt;/h3&gt;&lt;p&gt;User defined types are nicely bound by tolua. For each variable or function type that does not correspond to a basic type, tolua automatically creates a tagged userdata to represent the C/C++ type. If the type corresponds to a struct, the struct fields can be directly accessed from Lua, indexing a variable that holds an object of such a type. In C code, these types are commonly defined using typedef’s:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct [name] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   type1 fieldname1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   type2 fieldname2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   typeN fieldnameN;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; typename;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If such a code is inserted in the package file being processed, tolua allows any variable that holds an object of type typename to access any listed field indexing the variable by the field name. For instance, if var holds a such object, &lt;code&gt;var.fieldnamei&lt;/code&gt; accesses the field named fieldnamei.&lt;/p&gt;
&lt;p&gt;Fields that represent arrays of values can also be mapped:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int x[10]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int y[10]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; Example;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绑定类和方法-Binding-classes-and-methods&quot;&gt;&lt;a href=&quot;#绑定类和方法-Binding-classes-and-methods&quot; class=&quot;headerlink&quot; title=&quot;绑定类和方法 (Binding classes and methods)&quot;&gt;&lt;/a&gt;绑定类和方法 (Binding classes and methods)&lt;/h3&gt;&lt;p&gt;C++ class definitions are also supported by tolua. Actually, the tolua deals with single inheritance and polymorphism in a natural way. The subsections below describe what can be exported by a class definition.&lt;/p&gt;
&lt;h4 id=&quot;Specifying-inheritance-指定继承&quot;&gt;&lt;a href=&quot;#Specifying-inheritance-指定继承&quot; class=&quot;headerlink&quot; title=&quot;Specifying inheritance (指定继承)&quot;&gt;&lt;/a&gt;Specifying inheritance (指定继承)&lt;/h4&gt;&lt;p&gt;If var is a Lua variable that holds an object of a derived class, var can be used wherever its base class type is expected and var can access any method of its base class. For this mechanism to take effect, we must indicate that the derived class actually inherits the base class. This is done in the conventional way:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class classname : public basename&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; /* class definition */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;Specifying-exported-members-and-methods-指定导出成员和方法&quot;&gt;&lt;a href=&quot;#Specifying-exported-members-and-methods-指定导出成员和方法&quot; class=&quot;headerlink&quot; title=&quot;Specifying exported members and methods (指定导出成员和方法)&quot;&gt;&lt;/a&gt;Specifying exported members and methods (指定导出成员和方法)&lt;/h4&gt;&lt;p&gt;As for struct fields, class fields, static or not, can be exported. Class methods and class static methods can also be exported. Of course, they must be declared as public in the actual C++ code (although the public: keyword may not appear in the package files).&lt;br&gt;For each bound class, tolua creates a Lua table and stores it at a global variable which name is the name of the C++ class. Static exported fields are accessed by indexing this table with the field names (similar to struct fields). Non static exported fields are accessed by indexing the variable that holds the object. Class methods follow the format of the function declaration showed above. They can be accessed from Lua code using the conventional way Lua uses to call methods, applied of course to a variable that holds the appropriate object or to the class table, for static methods.&lt;/p&gt;
&lt;p&gt;There are a few special methods that are also supported by tolua. Constructors are called as static methods, named new. Destructors are called as a conventional method called delete.&lt;/p&gt;
&lt;p&gt;Note that tolua does support overload. This applies even for constructors. Also note that the virtual keyword has no effect in the package file.&lt;/p&gt;
&lt;p&gt;The following code exemplifies class definitions that can be interpreted by tolua.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Point &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   static int n;    // represents the total number of created Points&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   double x;        // represents the x coordinate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   double y;        // represents the y coordinate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   static char* className (void);   // returns the name of the class&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Point (void);                          // constructor 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Point (double px, double py);          // constructor 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ~Point (void);                         // destructor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Point add (Point&amp;amp; other);              // add points, returning another one&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class ColorPoint : public Color &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int red;      // red color component [0 - 255]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int green;    // green color component [0 - 255]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int blue;     // blue color component [0 - 255]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ColorPoint (double px, double py, int r, int g, int b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If this segment of code is processed by tolua, we would be able to write the following Lua statements:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p1 = Point:new(0.0,1.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p2 = ColorPoint:new(1.5,2.2,0,0,255)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(Point.n)                     -- would print 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p3 = p1:add(p2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(p3.x,p3.y)                   -- would print 1.5 and 3.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(p2.red,p2.green,p2.blue)     -- would print 0, 0, and 255&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p1:delete()                        -- call destructor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p2:delete()                        -- call destructor&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Note that we can only explicitly delete objects that we explicitly create. In the example above, the point p3 will be garbage-collected by tolua automatically; we cannot delete it.&lt;br&gt;Of course, we need to specify only the methods and members we want to access from Lua. Sometimes, it will be necessary to declare a class with no member or method just for the sake of not breaking a chain of inheritances.&lt;/p&gt;
&lt;h4 id=&quot;Overloaded-operators（重载的运算符）&quot;&gt;&lt;a href=&quot;#Overloaded-operators（重载的运算符）&quot; class=&quot;headerlink&quot; title=&quot;Overloaded operators（重载的运算符）&quot;&gt;&lt;/a&gt;Overloaded operators（重载的运算符）&lt;/h4&gt;&lt;p&gt;tolua automatically binds the following binary operators:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;operator+   operator-   operator*   operator/ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;operator&amp;lt;   operator&amp;gt;   operator&amp;lt;=  operator&amp;gt;=&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;For the relational operators, toLua also automatically converts a returned 0 value into nil, so false in C becomes false in Lua.&lt;br&gt;As an example, suppose that in the code above, instead of having:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Point add (Point&amp;amp; other);              // add points, returning another one&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;we had:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Point operator+ (Point&amp;amp; other);        // add points, returning another one&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In that case, in Lua, we could simply write:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p3 = p1 + p2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The indexing operator (&lt;code&gt;operator[]&lt;/code&gt;) when receiving a numeric parameter can also be exported to Lua. In this case, tolua accepts reference as returned value, even for basic types. Then if a reference is returned, from Lua, the programmer can either get or set the value. If the returned value is not a reference, the programmer can only get the value. An example may clarify: suppose we have a vector class and bind the following operator:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;double&amp;amp; operator[] (int index);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In this case, in Lua, we would be able to write: &lt;code&gt;value = myVector[i]&lt;/code&gt; and also &lt;code&gt;myVector[i] = value&lt;/code&gt;, what updates the C++ object. However, if the bound operator was:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;double operator[] (int index);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;we would only be able to write: &lt;code&gt;value = myVector[i]&lt;/code&gt;.&lt;br&gt;Free functions (i.e., not class members) that overload operators are not supported.&lt;/p&gt;
&lt;h3 id=&quot;模块定义-Module-definition&quot;&gt;&lt;a href=&quot;#模块定义-Module-definition&quot; class=&quot;headerlink&quot; title=&quot;模块定义 (Module definition)&quot;&gt;&lt;/a&gt;模块定义 (Module definition)&lt;/h3&gt;&lt;p&gt;tolua allows us to group constants, variables, and functions in a module. The module itself is mapped to a table in Lua, and its constants, variables, and functions are mapped to fields in that table. The general format to specify a module is:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;module name &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ... // constant, variable, and function declarations &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Thus, if we bound the following module declaration:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;module mod &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; #define N &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; extern int var; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; int func (...): &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In Lua we would be able to access such features by indexing the module: &lt;code&gt;mod.N, mod.var, mod.func&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;命名常量、变量和函数-Renaming-constants-variables-and-functions&quot;&gt;&lt;a href=&quot;#命名常量、变量和函数-Renaming-constants-variables-and-functions&quot; class=&quot;headerlink&quot; title=&quot;命名常量、变量和函数 (Renaming constants, variables and functions)&quot;&gt;&lt;/a&gt;命名常量、变量和函数 (Renaming constants, variables and functions)&lt;/h3&gt;&lt;p&gt;When exporting constants, variable, and functions (members of a class or not), we can rename them, such that they will be bound with a different name from their C/C++ counterparts. To do that, we write the name they will be referenced in Lua after the character &lt;code&gt;@&lt;/code&gt;. For instance:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;extern int cvar @ lvar;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define CNAME @ LNAME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enum &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CITEM1 @ LITEM1, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CITEM2 @ LITEM2, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void cfunc @ lfunc (...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class T &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   double cfield @ lfield; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   void cmeth @ lmeth (...); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In such a case, the global variable &lt;code&gt;cvar&lt;/code&gt; would be identified in Lua by &lt;code&gt;lvar&lt;/code&gt;, the constant &lt;code&gt;CNAME&lt;/code&gt; by &lt;code&gt;LNAME&lt;/code&gt;, and so on. Note that class cannot be renamed, because they represent types in C.&lt;/p&gt;
&lt;p&gt;This renaming feature allows function overload in C, because we can choose to export two different C functions with a same Lua name:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void glVertex3d @ glVertex (double x, double y, double z=0.0); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void glVertexdv @ glVertex (double v[3]=0.0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;存储额外字段-Storing-additional-fields&quot;&gt;&lt;a href=&quot;#存储额外字段-Storing-additional-fields&quot; class=&quot;headerlink&quot; title=&quot;存储额外字段 (Storing additional fields)&quot;&gt;&lt;/a&gt;存储额外字段 (Storing additional fields)&lt;/h3&gt;&lt;p&gt;Finally, it is important to know that even though the variables that hold C/C++ objects are actually tagged userdata for Lua, tolua creates a mechanism that allows us to store any additional field attached to these objects. That is, these objects can be seen as conventional Lua tables.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;obj = ClassName:new()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.myfield = 1  -- even though &amp;quot;myfield&amp;quot; does not represent a field of ClassName&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Such a construction is possible because, if needed, tolua automatically creates a Lua table and associates it with the object. So that, the object can store additional fields not mapped to C/C++, but actually stored in the conjugate table. The Lua programmer accesses the C/C++ features and these additional fields in an uniform way. Note that, in fact, these additional fields overwrite C/C++ fields or methods when the names are the same.&lt;/p&gt;
&lt;h3 id=&quot;导出工具函数-Exported-utility-functions&quot;&gt;&lt;a href=&quot;#导出工具函数-Exported-utility-functions&quot; class=&quot;headerlink&quot; title=&quot;导出工具函数 (Exported utility functions)&quot;&gt;&lt;/a&gt;导出工具函数 (Exported utility functions)&lt;/h3&gt;&lt;p&gt;tolua uses itself to export some utility functions to Lua, including its object-oriented framework. The package file used by tolua is shown below:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;module tolua &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void tolua_using @ using (lua_Table module); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; char* tolua_type @ type (lua_Object lo); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void tolua_foreach @ foreach (lua_Object lo, lua_Function f); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void tolua_class @ class (lua_Table derived, lua_Table base=TOLUA_NIL); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void tolua_instance @ instance (lua_Table instance, lua_Table classobj); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; lua_Object tolua_base @ base (lua_Object lo); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;tolua-using-table&quot;&gt;&lt;a href=&quot;#tolua-using-table&quot; class=&quot;headerlink&quot; title=&quot;tolua.using (table)&quot;&gt;&lt;/a&gt;tolua.using (table)&lt;/h4&gt;&lt;p&gt;This functions receives a table and maps all its fields to the global environment. Thus we can map an entire module and access its features without the module prefix. For instance, if in our Lua code we do:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tolua.using(tolua)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;all tolua utility functions are mapped to the global environment.&lt;/p&gt;
&lt;h4 id=&quot;tolua-type-var&quot;&gt;&lt;a href=&quot;#tolua-type-var&quot; class=&quot;headerlink&quot; title=&quot;tolua.type (var)&quot;&gt;&lt;/a&gt;tolua.type (var)&lt;/h4&gt;&lt;p&gt;Returns a string representing the object type. For instance, &lt;code&gt;tolua.type(tolua)&lt;/code&gt; returns the string &lt;code&gt;generic module&lt;/code&gt; and &lt;code&gt;tolua.type(tolua.type)&lt;/code&gt; returns &lt;code&gt;cfunction&lt;/code&gt;. Similarly, if &lt;code&gt;var&lt;/code&gt; is a variable holding a user defined type &lt;code&gt;T, tolua.type(var)&lt;/code&gt; would return const &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;, depending whether it is a constant reference.&lt;/p&gt;
&lt;h4 id=&quot;tolua-tag-“type”&quot;&gt;&lt;a href=&quot;#tolua-tag-“type”&quot; class=&quot;headerlink&quot; title=&quot;tolua.tag (“type”)&quot;&gt;&lt;/a&gt;tolua.tag (“type”)&lt;/h4&gt;&lt;p&gt;Returns type corresponding tag number.&lt;/p&gt;
&lt;h4 id=&quot;tolua-foreach-object&quot;&gt;&lt;a href=&quot;#tolua-foreach-object&quot; class=&quot;headerlink&quot; title=&quot;tolua.foreach (object)&quot;&gt;&lt;/a&gt;tolua.foreach (object)&lt;/h4&gt;&lt;p&gt;Allows us to traverse the conjugate table of an user defined instance. If applied to conventional table, it has a similar behavior as the Lua built-in &lt;code&gt;foreach&lt;/code&gt; function. The difference is that this function filters all fields starting with a dot, not passing them to the provided callback function. This filter is need because tolua adds “hidden” fields to the tables it manipulates, and all its “hidden” fields start with a dot.&lt;/p&gt;
&lt;h4 id=&quot;tolua-cast-object-“typename”&quot;&gt;&lt;a href=&quot;#tolua-cast-object-“typename”&quot; class=&quot;headerlink&quot; title=&quot;tolua.cast (object, “typename”)&quot;&gt;&lt;/a&gt;tolua.cast (object, “typename”)&lt;/h4&gt;&lt;p&gt;Returns the object “casted” to the given type. The object must represent an user type, otherwise the function returns &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;tolua-takeownership-object&quot;&gt;&lt;a href=&quot;#tolua-takeownership-object&quot; class=&quot;headerlink&quot; title=&quot;tolua.takeownership (object)&quot;&gt;&lt;/a&gt;tolua.takeownership (object)&lt;/h4&gt;&lt;p&gt;Asks tolua to take the ownership of the given object. This means the C/C++ object will be freed/ destructed when garbage-collected by Lua.  The object must represent an user type, otherwise an execution error is generated.&lt;/p&gt;
&lt;h4 id=&quot;tolua-class-table-base-nil&quot;&gt;&lt;a href=&quot;#tolua-class-table-base-nil&quot; class=&quot;headerlink&quot; title=&quot;tolua.class (table, base=nil)&quot;&gt;&lt;/a&gt;tolua.class (table, base=nil)&lt;/h4&gt;&lt;p&gt;Creates a class by setting the appropriate tag methods to the given table. The created class can inherit from a base class, previously created.&lt;/p&gt;
&lt;h4 id=&quot;tolua-instance-table-class&quot;&gt;&lt;a href=&quot;#tolua-instance-table-class&quot; class=&quot;headerlink&quot; title=&quot;tolua.instance (table, class)&quot;&gt;&lt;/a&gt;tolua.instance (table, class)&lt;/h4&gt;&lt;p&gt;Sets the given table to be an instance of the given class. This and the previous utility functions allow object-oriented programming in Lua. As an example consider:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define a Point class &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;classPoint = &amp;#123; x=0, y=0 &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tolua.class(classPoint) -- set as a class&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define print method &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function classPoint:print () &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   print(self.x,self.y) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define add method &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function classPoint:add (p2) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   return Point&amp;#123;x=self.x+p2.x,y=self.y+p2.y&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define a Point constructor &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function Point (p) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   tolua.instance(p,classPoint) -- set as an instance of classPoint &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return p end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define a Color Point class &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;classColorPoint = &amp;#123; color = &amp;apos;black&amp;apos; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tolua.class(classColorPoint,classPoint) -- set as class inheriting from classPoint&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define class methods &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function classColorPoint:print () &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   print(self.x,self.y,self.color) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define Color Point constructor &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function ColorPoint (p) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   tolua.instance(p,classColorPoint) -- set as an instance of classColorPoint &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   return p &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- Some valid codes would then be &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p = Point&amp;#123;x=1&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;q = ColorPoint&amp;#123;x=2,y=3,color=2&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r = p:add(q) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r:print() --&amp;gt; would print &amp;quot;3 3&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Lua嵌入代码-Embedded-Lua-code&quot;&gt;&lt;a href=&quot;#Lua嵌入代码-Embedded-Lua-code&quot; class=&quot;headerlink&quot; title=&quot;Lua嵌入代码 (Embedded Lua code)&quot;&gt;&lt;/a&gt;Lua嵌入代码 (Embedded Lua code)&lt;/h3&gt;&lt;p&gt;tolua allows us to embed Lua code in the C/C++ generated code. To do that, it compiles the specified Lua code and creates a C constant string, storing the corresponding bytecodes, in the generated code.  When the package is opened, such a string is executed. The format to embed Lua code is:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;embedded Lua code &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;As an example consider the following .pkg excerpt:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* Bind a Point class */ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Point &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Point (int x, int y); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ~Point (); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void print (); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; CPoint;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-- Create a Point constructor &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function Point (self) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; local cobj = CPoint:new(self.x or 0, self.y or 0) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; tolua.takeownership(cobj) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; return cobj &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Binding such a code would allow us to write the following Lua code:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p = Point&amp;#123; x=2, y=3 &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p:print() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;基本步骤&quot;&gt;&lt;a href=&quot;#基本步骤&quot; class=&quot;headerlink&quot; title=&quot;基本步骤&quot;&gt;&lt;/a&gt;基本步骤&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;添加自定义类&lt;/li&gt;
&lt;li&gt;按照tolua改写规则，改写头文件(也可以在头文件加tolua能够识别的代码)生成tolua文件，这里分为两个方式，一是生成单独对应的tolua文件，二是追加到已有的tolua文件中&lt;/li&gt;
&lt;li&gt;运行脚本，生成绑定文件，根据第二步tolua生成方式的不同，生成的绑定也是两个方式：一是生成单独对应的绑定文件.h/.cpp，而是生成的内容分别追加到已有的绑定文件.h/.cpp中&lt;/li&gt;
&lt;li&gt;载入luabinding接口文件&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;项目使用Cocos2dx+lua框架做的，用到luabinding实现C++代码绑定到lua层使用，所以学习一下tolua++工具的原理和使用，在这做个记录。&lt;/p&gt;
&lt;p&gt;tolua++是tolua的扩展版本，是一款能够集成C/C++与lua代码的工具。在面向C++方面，tolua++包含了一些新的特性比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持&lt;code&gt;std::string&lt;/code&gt;作为基本类型（这个可以由一个命令行选项关闭）&lt;/li&gt;
&lt;li&gt;支持类模板&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tecgraf.puc-rio.br/~celes/tolua/&quot;&gt;tolua&lt;/a&gt;这款工具，极大的简化了C/C++代码与lua代码的集成。基于一个干净的头文件（或者从实际头文件中提取），tolua会自动生成从lua访问C/C++功能的绑定代码。使用Lua API和标记方法设施，tolua解析C/C++常数，外部变量、函数、类和方法绑定到Lua。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/&quot;&gt;官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/tolua-3.2.html&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Cocos2d-x" scheme="http://blog.keepmovingxin.com/tags/Cocos2d-x/"/>
    
      <category term="Lua" scheme="http://blog.keepmovingxin.com/tags/Lua/"/>
    
      <category term="tolua" scheme="http://blog.keepmovingxin.com/tags/tolua/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x中动态纹理CCRenderTexture的使用</title>
    <link href="http://blog.keepmovingxin.com/2016/05/09/Cocos2dx-CCRenderTexture/"/>
    <id>http://blog.keepmovingxin.com/2016/05/09/Cocos2dx-CCRenderTexture/</id>
    <published>2016-05-09T14:31:28.000Z</published>
    <updated>2016-05-16T04:56:26.000Z</updated>
    
    <content type="html">&lt;p&gt;记录一下Cocos2d-x中动态纹理&lt;code&gt;CCRenderTexture&lt;/code&gt;的各种应用，实现截屏、阴影等等&lt;br&gt;使用&lt;code&gt;CCRenderTexture&lt;/code&gt;需要做以下5步:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个新的&lt;code&gt;CCRenderTexture&lt;/code&gt;. 这里，你可以指定将要创建的纹理的宽度和高度。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;CCRenderTexture:begin&lt;/code&gt;. 这个方法会启动OpenGL，并且接下来，任何绘图的命令都会渲染到&lt;code&gt;CCRenderTexture&lt;/code&gt;里面去，而不是画到屏幕上。&lt;/li&gt;
&lt;li&gt;绘制纹理. 你可以使用原始的&lt;code&gt;OpenGL&lt;/code&gt;调用来绘图，或者你也可以使用cocos2d对象里面已经定义好的&lt;code&gt;visit&lt;/code&gt;方法。（这个visit方法就会调用一些opengl命令来绘制cocos2d对象）&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;CCRenderTexture:end&lt;/code&gt;. 这个方法会渲染纹理，并且会关闭渲染至&lt;code&gt;CCRenderTexture&lt;/code&gt;的通道。&lt;/li&gt;
&lt;li&gt;从生成的纹理中创建一个&lt;code&gt;sprite&lt;/code&gt;. 你现在可以用&lt;code&gt;CCRenderTexture&lt;/code&gt;的&lt;code&gt;sprite.texture&lt;/code&gt;属性来轻松创建新的精灵了。&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;截取当前屏幕图片&quot;&gt;&lt;a href=&quot;#截取当前屏幕图片&quot; class=&quot;headerlink&quot; title=&quot;截取当前屏幕图片&quot;&gt;&lt;/a&gt;截取当前屏幕图片&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;--[[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @des:截取当前屏幕图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @ret:截取的图片路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function getScreenshots()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local size = CCDirector:sharedDirector():getWinSize()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local renderTexture = CCRenderTexture:create(size.width, size.height,kCCTexture2DPixelFormat_RGBA8888)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:getSprite():setAnchorPoint( ccp(0.5,0.5) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:setPosition( ccp(size.width/2, size.height/2) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:setAnchorPoint( ccp(0.5,0.5) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local runingScene = CCDirector:sharedDirector():getRunningScene()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:begin()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    runingScene:visit()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:endToLua()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local picPath = CCFileUtils:sharedFileUtils():getWritablePath() .. &amp;quot;tempScreenshots.jpg&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;截屏图片:&amp;quot;,renderTexture:saveToFile(picPath))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return picPath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绘制精灵的影子&quot;&gt;&lt;a href=&quot;#绘制精灵的影子&quot; class=&quot;headerlink&quot; title=&quot;绘制精灵的影子&quot;&gt;&lt;/a&gt;绘制精灵的影子&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;--[[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @des:根据精灵绘制影子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @par:pSprite 精灵&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @ret:shadowSprite 精灵影子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function getShadowSprite( pSprite )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local size = pSprite:getContentSize()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local renderTexture = CCRenderTexture:create(size.width, size.height,kCCTexture2DPixelFormat_RGBA8888)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:getSprite():setAnchorPoint( ccp(0.5,0.5) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:setPosition( ccp(size.width/2, size.height/2) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:setAnchorPoint( ccp(0.5,0.5) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:beginWithClear(0,0,0,0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pSprite:visit()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:endToLua()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local shadowSprite = CCSprite:createWithTexture(renderTexture:getSprite():getTexture())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return shadowSprite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绘制动态精灵&quot;&gt;&lt;a href=&quot;#绘制动态精灵&quot; class=&quot;headerlink&quot; title=&quot;绘制动态精灵&quot;&gt;&lt;/a&gt;绘制动态精灵&lt;/h3&gt;&lt;p&gt;　　注意，我们这里不是调用的&lt;code&gt;CCRenderTexture:begin&lt;/code&gt;方法，而是调用另外一个较方便的方法&lt;code&gt;beginWithClear:g:b:a:&lt;/code&gt;，这个方法可以用给定的颜色来清除纹理的背景，相当于设置画布的颜色。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(CCSprite *)spriteWithColor:(ccColor4F)bgColor textureSize:(float)textureSize &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 1: Create new CCRenderTexture&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CCRenderTexture *rt = [CCRenderTexture renderTextureWithWidth:textureSize height:textureSize];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 2: Call CCRenderTexture:begin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[rt beginWithClear:bgColor.r g:bgColor.g b:bgColor.b a:bgColor.a];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 3: Draw into the texture&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// We&amp;apos;ll add this later&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 4: Call CCRenderTexture:end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[rt end];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 5: Create a new Sprite from the texture&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return [CCSprite spriteWithTexture:rt.sprite.texture];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (ccColor4F)randomBrightColor &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (true) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        float requiredBrightness = 192;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ccColor4B randomColor = &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ccc4(arc4random() % 255,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 arc4random() % 255, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 arc4random() % 255, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 255);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (randomColor.r &amp;gt; requiredBrightness || &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            randomColor.g &amp;gt; requiredBrightness ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            randomColor.b &amp;gt; requiredBrightness) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return ccc4FFromccc4B(randomColor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)genBackground &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_background removeFromParentAndCleanup:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ccColor4F bgColor = [self randomBrightColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _background = [self spriteWithColor:bgColor textureWidth:IS_IPHONE_5 ? 1024:512 textureHeight:512];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGSize winSize = [CCDirector sharedDirector].winSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _background.position = ccp(winSize.width/2, winSize.height/2);        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self addChild:_background z:-1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void) onEnter &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super onEnter];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self genBackground];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self setTouchEnabled:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self genBackground];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;　　&lt;code&gt;randomBrightColor&lt;/code&gt;方法是一个辅助方法，用来创建一种随机颜色。注意，这里使用ccc4B（因此，我们能够在0-255的范围内指定R/G/B/A值），同时确保至少有一个颜色分量是大于192的，这样的话，我们就不会得到较暗的颜色。&lt;br&gt;　　然后，&lt;code&gt;genBackground&lt;/code&gt;调用我们之前写的&lt;code&gt;spriteWithColor&lt;/code&gt;方法，同时把它加屏幕中央。&lt;br&gt;　　至于&lt;code&gt;init&lt;/code&gt;函数，它调用&lt;code&gt;genBackground&lt;/code&gt;方法，同时激活&lt;code&gt;touches&lt;/code&gt;事件，这样的话，你就可以通过点击屏幕来获得另外的随机背景了。&lt;br&gt;　　编译并运行，这样你每一次点击屏幕，你都可以得到一张不同的单色背景图片啦！&lt;/p&gt;
&lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.raywenderlich.com/33266/how-to-create-dynamic-textures-with-ccrendertexture-in-cocos2d-2-x&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How To Create Dynamic Textures with CCRenderTexture in Cocos2D 2.X&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/andyque/archive/2011/07/01/2095479.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(译)如何使用CCRenderTexture来创建动态纹理&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.keepmovingxin.com/2016/05/09/Cocos2dx-CCRenderTexture/&quot;&gt;http://blog.keepmovingxin.com/2016/05/09/Cocos2dx-CCRenderTexture/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下Cocos2d-x中动态纹理&lt;code&gt;CCRenderTexture&lt;/code&gt;的各种应用，实现截屏、阴影等等&lt;br&gt;使用&lt;code&gt;CCRenderTexture&lt;/code&gt;需要做以下5步:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个新的&lt;code&gt;CCRenderTexture&lt;/code&gt;. 这里，你可以指定将要创建的纹理的宽度和高度。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;CCRenderTexture:begin&lt;/code&gt;. 这个方法会启动OpenGL，并且接下来，任何绘图的命令都会渲染到&lt;code&gt;CCRenderTexture&lt;/code&gt;里面去，而不是画到屏幕上。&lt;/li&gt;
&lt;li&gt;绘制纹理. 你可以使用原始的&lt;code&gt;OpenGL&lt;/code&gt;调用来绘图，或者你也可以使用cocos2d对象里面已经定义好的&lt;code&gt;visit&lt;/code&gt;方法。（这个visit方法就会调用一些opengl命令来绘制cocos2d对象）&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;CCRenderTexture:end&lt;/code&gt;. 这个方法会渲染纹理，并且会关闭渲染至&lt;code&gt;CCRenderTexture&lt;/code&gt;的通道。&lt;/li&gt;
&lt;li&gt;从生成的纹理中创建一个&lt;code&gt;sprite&lt;/code&gt;. 你现在可以用&lt;code&gt;CCRenderTexture&lt;/code&gt;的&lt;code&gt;sprite.texture&lt;/code&gt;属性来轻松创建新的精灵了。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Cocos2d-x" scheme="http://blog.keepmovingxin.com/tags/Cocos2d-x/"/>
    
  </entry>
  
  <entry>
    <title>shell学习笔记</title>
    <link href="http://blog.keepmovingxin.com/2016/05/02/Learn-shell/"/>
    <id>http://blog.keepmovingxin.com/2016/05/02/Learn-shell/</id>
    <published>2016-05-02T08:50:52.000Z</published>
    <updated>2016-05-18T10:05:05.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-Shell脚本&quot;&gt;&lt;a href=&quot;#1-Shell脚本&quot; class=&quot;headerlink&quot; title=&quot;1.Shell脚本&quot;&gt;&lt;/a&gt;1.Shell脚本&lt;/h3&gt;&lt;h4 id=&quot;1-1-格式&quot;&gt;&lt;a href=&quot;#1-1-格式&quot; class=&quot;headerlink&quot; title=&quot;1.1 格式&quot;&gt;&lt;/a&gt;1.1 格式&lt;/h4&gt;&lt;p&gt;首行        #!/bin/bash    指定解释器&lt;/p&gt;
&lt;h4 id=&quot;1-2-注释&quot;&gt;&lt;a href=&quot;#1-2-注释&quot; class=&quot;headerlink&quot; title=&quot;1.2 注释&quot;&gt;&lt;/a&gt;1.2 注释&lt;/h4&gt;&lt;p&gt;‘#’开头的行，’#!’是例外&lt;/p&gt;
&lt;p&gt;此外，# 是特殊字符，可以出现在一些参数代换结构和在数值常量表达式中，具有特殊含义，而不会开启一个注释。‘#’也不会开启一个注释。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;1-3-函数&quot;&gt;&lt;a href=&quot;#1-3-函数&quot; class=&quot;headerlink&quot; title=&quot;1.3 函数&quot;&gt;&lt;/a&gt;1.3 函数&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;function funname(){…}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;funname()
{
    statements;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只需要使用函数名就可以调用某个函数：&lt;code&gt;funname&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数可以传递给函数，使用方法就好像函数是个新脚本一样：&lt;/p&gt;
&lt;p&gt;funname arg1 arg2…;    #传递参数&lt;/p&gt;
&lt;p&gt;在函数中使用传入的参数：$1    第一个参数；$@ 所有参数。&lt;/p&gt;
&lt;p&gt;其中：”$@”被扩展成”$1””$2””$3”；&lt;/p&gt;
&lt;p&gt;“$*”被扩展成”$1c$2c$3”，即一个字符串。c为IFS的第一个字符。&lt;/p&gt;
&lt;p&gt;有时我们需要知道命令或者函数的执行状态，用$?可以查看前一个命令的返回值，如果命令成功退出，那么退出状态为0，否则非0。&lt;/p&gt;
&lt;h4 id=&quot;1-4-正文部分&quot;&gt;&lt;a href=&quot;#1-4-正文部分&quot; class=&quot;headerlink&quot; title=&quot;1.4 正文部分&quot;&gt;&lt;/a&gt;1.4 正文部分&lt;/h4&gt;&lt;p&gt;流程控制+命令&lt;/p&gt;
&lt;h4 id=&quot;1-5-执行：修改权限&quot;&gt;&lt;a href=&quot;#1-5-执行：修改权限&quot; class=&quot;headerlink&quot; title=&quot;1.5 执行：修改权限&quot;&gt;&lt;/a&gt;1.5 执行：修改权限&lt;/h4&gt;&lt;p&gt;转为可执行程序&lt;/p&gt;
&lt;p&gt;chmod +x ./test.sh  #使脚本具有执行权限&lt;/p&gt;
&lt;p&gt;./test.sh  #执行脚本&lt;/p&gt;
&lt;h4 id=&quot;1-6-流程控制&quot;&gt;&lt;a href=&quot;#1-6-流程控制&quot; class=&quot;headerlink&quot; title=&quot;1.6 流程控制&quot;&gt;&lt;/a&gt;1.6 流程控制&lt;/h4&gt;&lt;p&gt;条件语句&lt;/p&gt;
&lt;p&gt;if :&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if condition&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;then	command1 	command2	...	commandNfi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if `ps -ef | grep ssh`;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;then &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	echo hello; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;if else-if else :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if condition1
then
    command1
elif condition2
    command2
else
    commandN
fi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;循环语句&lt;/p&gt;
&lt;p&gt;for :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;```for var in item1 item2 ... itemN; do command1; command2… done;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

while :

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;i=1;total=0;while [ $i -le 10 ]do    let total+=i    let i++    echo $total,$idone&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;i=1; total=0;while((i&amp;lt;=10))do    ((total+=i, i++))    echo $total,$idone&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



case语句: case语句可以用户处理自定义参数。

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;case $num in1) echo &amp;quot;January&amp;quot;;;     			#双分号结束2) echo &amp;quot;Feburary&amp;quot;;;5) echo &amp;quot;may&amp;quot;          				#每个case可以有多条命令          echo &amp;quot;sdfd&amp;quot;   echo &amp;quot;sdf&amp;quot;;;       				#但最后一条命令一定是双分号结束*) echo &amp;quot;not correct input&amp;quot;;;   	#*）是其他值、default的意思esac&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```#### 1.7 while read line&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

while read line; do something ; done
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;1-8-参数处理&quot;&gt;&lt;a href=&quot;#1-8-参数处理&quot; class=&quot;headerlink&quot; title=&quot;1.8    参数处理&quot;&gt;&lt;/a&gt;1.8    参数处理&lt;/h4&gt;&lt;p&gt;a)    “$*”将所有的参数解释成一个字符串，而”$@”是一个参数数组。&lt;/p&gt;
&lt;p&gt;b)    Shell内建函数getopts “:a:bc” opt&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主要变量：

$OPTIND    :    存储所处理的选项在参数列表中的位置

$OPTARG    ：    存储相应选项所带的参数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;while getopts &amp;quot;:a:b:cef&amp;quot; optdo    case $opt in        a)echo &amp;quot;the $OPTIND has arg:$OPTARG&amp;quot;;;#$OPTIND=3        b)echo &amp;quot;the b has arg:$OPTARG&amp;quot;;;        c | e | f)echo &amp;quot;the $opt has no arg&amp;quot;;;        \?)echo &amp;quot;the $opt is invalid param&amp;quot;;;    esacdone```c)	shift n   将位置命令左移n个#### 1.9	条件判断条件判断应该放进方括号里，且方括号两边都应该留有空格。 [  ]a)	字符串判断字符串比较时，最好用双中括号，因为有时候采用单中括号会产生错误，所以最好避开它们。[[ $str1 = $str2 ]]	=			当两个串有相同内容、长度时为真	!=		　　当串str1和str2不等时为真	-n			当串的长度大于0时为真(串非空)	-z			当串的长度为0时为真(空串)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b)	数值判断	-eq     两数相等为真 	-ne     两数不等为真 	-gt     int1大于int2为真 	-ge     int1大于等于int2为真 	-lt     int1小于int2为真 	-le     int1小于等于int2为真&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c)	文件判断	-e file         若文件存在，则为真 	-d file         若文件存在且是一个目录，则为真	-b file         若文件存在且是一个块特殊文件，则为真	-c file         若文件存在且是一个字符特殊文件，则为真	-f file         若文件存在且是一个规则文件，则为真	-g file         若文件存在且设置了SGID位的值，则为真	-h file         若文件存在且为一个符合链接，则为真	-k file         若文件存在且设置了&amp;quot;sticky&amp;quot;位的值	-p file         若文件存在且为一已命名管道，则为真	-r file         若文件存在且可读，则为真	-s file         若文件存在且其大小大于零，则为真	-u file         若文件存在且设置了SUID位，则为真	-w file         若文件存在且可写，则为真	-x file         若文件存在且可执行，则为真	-o file         若文件存在且被有效用户ID所拥有，则为真&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d)	逻辑判断	!      非	-a     与		&amp;amp;&amp;amp;	-o     或		||if [ $v –ne 0 –a $v –lt 2 ] 等价 if [ $v –ne 0 ] &amp;amp;&amp;amp; [ $v –lt 2 ]if [ $v –ne 0 –o $v –lt 2 ] 等价 if [ $v –ne 0 ] || [ $v –lt 2 ]条件判断部分可能会变得很长，一个优化的小技巧是利用&amp;amp;&amp;amp;和||运算符。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;if condition&lt;br&gt;then&lt;br&gt;    command1&lt;br&gt;else&lt;br&gt;    command2&lt;br&gt;fi&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[ condition ] &amp;amp;&amp;amp; command1 || command2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这样就用一行代替了上面的5行而实现的功能完全相同。

如果命令有多个，可以用{}括起来，当做一个命令块。

这样可以使判断语句变得非常简洁。

#### 1.10 &amp;amp;&amp;amp;、||
cmd1 &amp;amp;&amp;amp; cmd2

表示，当cmd1执行成功后，就执行cmd2，否则不执行。

cmd1 || cmd2

表示，当cmd1执行失败后，就执行cmd2，否则不执行。

### 2.变量
#### 2.1 系统变量
$n      该变量与脚本被激活时所带的参数相对应。n是正整数，与参数位置相对应($1,$2...) 

$?      前一个命令执行后的退出状态

$#      提供脚本的参数号

$*      所有这些参数都被双引号引住。若一个脚本接收两个参数，$*等于$1$2 

$0      正在被执行命令的名字。对于shell脚本而言，这是被激活命令的路径

$@      所有这些参数都分别被双引号引住。若一个脚本接收到两个参数，$@等价于$1$2

$$      当前shell的进程号。对于shell脚本，这是其正在执行时的进程ID

$!      前一个后台命令的进程号

#### 2.2    普通变量

1)    赋值：var=value

2)    #

获取字符串的长度。len=${#var}

3)    数值运算：let

let命令后面的变量不用带$，如：

nu=10;

let nu+=10;    #nu=20

但这个命令不能进行浮点数的运算。

4)    浮点数运算：bc

echo &amp;quot;4 * 0.6&amp;quot; | bc

bc是一个强大的计算器，还可以进项如下操作：

设定小数精度，`scale=2,eg:echo &amp;quot;scale=2;3 / 8&amp;quot; | bc`

\#.37  这是bc的特性，小于0的数，是不显示小数点前的0的。


进制转换。用ibase设定输入数字的进制，obase设定输出数字的进制。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;no=10&lt;br&gt;echo “obase=2;ibase=10;$no” | bc   #1010&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;计算平方以及平方根。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;echo “10^4” | bc        #1000    平方&lt;br&gt;echo “sqrt(100)” | bc     #10        平方根&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#### 2.3 IFS
全称是Internal Field Separtor，内部分隔符。

Shell 的环境变量分为 set, env 两种，其中 set 变量可以通过 export 工具导入到 env 变量中。其中，set 是显示设置shell变量，仅在本 shell 中有效；env 是显示设置用户环境变量 ，仅在当前会话中有效。换句话说，set 变量里包含了 env 变量，但 set 变量不一定都是 env 变量。这两种变量不同之处在于变量的作用域不同。显然，env 变量的作用域要大些，它可以在 subshell 中使用。

而 IFS 是一种 set 变量，当 shell 处理&amp;quot;命令替换&amp;quot;和&amp;quot;参数替换&amp;quot;时，shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;eg：$ cat test.txt123$ out=$(cat test.txt)$ echo $out1 2 3			#shell将(cat test.txt)的结果拆解，并用默认的分隔符（空格）重新组合，赋值给out，因此echo $out的结果不包含换行。```如果要保留cat test.txt中的换行符，一般情况下要做两步：1是，设定IFS为换行：IFS=&amp;apos;\n&amp;apos;2是，将$(cat test.txt)用双引号引起来，表示不用若指定IFS为换行符。#### 2.4 UID特殊的环境变量，如果UID=0，表示当前以root用户运行脚本。否则不是root### 3.自增Linux Shell中写循环时，常常要用到变量的自增，现在总结一下整型变量自增的方法。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

1)    i=`expr $i + 1`;
2)    let i+=1;
3)    ((i++));    #双括号结构
http://www.cnblogs.com/chengmo/archive/2010/10/19/1855577.html
4)    i=$[$i+1];
5)    i=$(( $i + 1 ))
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;4-双括号结构&quot;&gt;&lt;a href=&quot;#4-双括号结构&quot; class=&quot;headerlink&quot; title=&quot;4.双括号结构(())&quot;&gt;&lt;/a&gt;4.双括号结构(())&lt;/h3&gt;&lt;p&gt;双括号结构是对shell中算数及赋值运算的扩展。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;((表达式1,表达式2…))&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;p&gt;1)    在双括号结构中，所有表达式可以像c语言一样，如：a++,b–等。&lt;/p&gt;
&lt;p&gt;2)    在双括号结构中，所有变量可以不加入：“$”符号前缀。&lt;/p&gt;
&lt;p&gt;3)    双括号可以进行逻辑运算，四则运算.eg. echo $((a&amp;gt;1?2:3));注意四则运算中仍然不支持浮点数运算&lt;/p&gt;
&lt;p&gt;4)    支持多个表达式运算，各个表达式之间用“，”分开. eg:((a+1,b++,c++))&lt;/p&gt;
&lt;p&gt;5)    双括号结构 扩展了for，while,if条件测试运算&lt;/p&gt;
&lt;h3 id=&quot;5-数组&quot;&gt;&lt;a href=&quot;#5-数组&quot; class=&quot;headerlink&quot; title=&quot;5.数组&quot;&gt;&lt;/a&gt;5.数组&lt;/h3&gt;&lt;p&gt;1)    取数组长度 – ‘#’&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arr=(1 2 3 4 5)
len=${#arr[@]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)    打印特定索引的数组元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo ${arr[2]}        #2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3)    打印出数组中的所有值-‘*’、’@’&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo ${arr[*]}
echo ${arr[@]}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;6-关联数组&quot;&gt;&lt;a href=&quot;#6-关联数组&quot; class=&quot;headerlink&quot; title=&quot;6.关联数组&quot;&gt;&lt;/a&gt;6.关联数组&lt;/h3&gt;&lt;p&gt;在关联数组中，可以用任意的文本作为数组索引。先声明才能使用&lt;/p&gt;
&lt;p&gt;1)    声明一个关联数组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;declare –A ass_array
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)    赋值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a)    ass_array=([index1]=val1 [index2]=val2)
b)    ass_array[index1]=val1
ass_array[index2]=val2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3)    &lt;code&gt;echo ${ass_array[index1]}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4)    列出数组索引：&lt;br&gt;&lt;code&gt;echo ${!ass_array[@]}&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;7-临时文件或目录&quot;&gt;&lt;a href=&quot;#7-临时文件或目录&quot; class=&quot;headerlink&quot; title=&quot;7.临时文件或目录&quot;&gt;&lt;/a&gt;7.临时文件或目录&lt;/h3&gt;&lt;p&gt;在shell脚本中经常要保存临时的数据，如果使用认为创建临时文件用户保存临时数据，则有可能出现重名的情况，导致覆盖原来的数据。&lt;/p&gt;
&lt;p&gt;mktemp prefile.xxx    创建以prefile开头的随机文件文件，并返回文件名，指定前缀时必须包含至少3个xxx。&lt;/p&gt;
&lt;p&gt;主要参数：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-d	：	创建一个目录，dirname=`mktemp -d`-u	:	仅生成随机文件名，但不创建实际的文件或目录，tmpfile=`mktemp -u`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.keepmovingxin.com/2016/05/02/Learn-shell/&quot;&gt;http://blog.keepmovingxin.com/2016/05/02/Learn-shell/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Shell脚本&quot;&gt;&lt;a href=&quot;#1-Shell脚本&quot; class=&quot;headerlink&quot; title=&quot;1.Shell脚本&quot;&gt;&lt;/a&gt;1.Shell脚本&lt;/h3&gt;&lt;h4 id=&quot;1-1-格式&quot;&gt;&lt;a href=&quot;#1-1-格式&quot; class=&quot;headerlink&quot; title=&quot;1.1 格式&quot;&gt;&lt;/a&gt;1.1 格式&lt;/h4&gt;&lt;p&gt;首行        #!/bin/bash    指定解释器&lt;/p&gt;
&lt;h4 id=&quot;1-2-注释&quot;&gt;&lt;a href=&quot;#1-2-注释&quot; class=&quot;headerlink&quot; title=&quot;1.2 注释&quot;&gt;&lt;/a&gt;1.2 注释&lt;/h4&gt;&lt;p&gt;‘#’开头的行，’#!’是例外&lt;/p&gt;
&lt;p&gt;此外，# 是特殊字符，可以出现在一些参数代换结构和在数值常量表达式中，具有特殊含义，而不会开启一个注释。‘#’也不会开启一个注释。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="http://blog.keepmovingxin.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>利用pngquant压缩png图片</title>
    <link href="http://blog.keepmovingxin.com/2016/04/30/pngquant-compress-png/"/>
    <id>http://blog.keepmovingxin.com/2016/04/30/pngquant-compress-png/</id>
    <published>2016-04-30T13:11:28.000Z</published>
    <updated>2016-05-18T10:04:16.000Z</updated>
    
    <content type="html">&lt;p&gt;项目包体积越来越大，为了压缩包大小找到一个比较好用的png图片压缩工具，在这记录一下。&lt;/p&gt;
&lt;h3 id=&quot;安装并配置全局变量&quot;&gt;&lt;a href=&quot;#安装并配置全局变量&quot; class=&quot;headerlink&quot; title=&quot;安装并配置全局变量&quot;&gt;&lt;/a&gt;安装并配置全局变量&lt;/h3&gt;&lt;p&gt;安装：&lt;/p&gt;
&lt;p&gt;去官网下载压缩包 或者 源码: &lt;code&gt;git clone git://github.com/pornel/pngquant.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以使用HomeBrew安装：&lt;code&gt;brew install pngquant&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置全局变量(使用HomeBrew安装请忽略)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln –s /下载的位置/pngquant /usr/local/bin/pngquant&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;pngquant 可以愉快的玩耍啦！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;查看帮助信息：&quot;&gt;&lt;a href=&quot;#查看帮助信息：&quot; class=&quot;headerlink&quot; title=&quot;查看帮助信息：&quot;&gt;&lt;/a&gt;查看帮助信息：&lt;/h3&gt;&lt;p&gt;执行 pngquant -h 查看完整选项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--ext new.png
设置输出图片的后缀。默认是 -or8.png 或者 -fs8.png 。

--quality min-max
使 pngquant 使用最少的颜色达到或超出 max 品质要求。如果转换结果低于 min 品质，图像不会被保存 (如果是输出到标准输出, 24-bit 原图像会被输出) 并且 pngquant 会退出并返回 99。
min 和 max 范围在 0 (最差) 到 100 (最佳), 和 JPEG 相似。
pngquant --quality=65-80 image.png

--speed N, -sN
速度/质量 平衡 从 1 (强制) 到 10 (最快)。默认是 3。速度 10 相比减少图片 5% 质量, 但是 8 倍于默认的速度。

--iebug
在 IE6 下, 只显示完全不透明的像素。pngquant 会使半透明像素以不透明方式显示并且不生产新的像素。

--version
输出版本信息。

-
从标准输入读取图像并输出到标准输出。

--
不处理对象。允许使用文件名以 - 开头的文件。如果你在脚本中使用 pngquant , 建议在文件名前加上这个:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;pngquant $OPTIONS -- &amp;quot;$FILE&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用示例：&quot;&gt;&lt;a href=&quot;#使用示例：&quot; class=&quot;headerlink&quot; title=&quot;使用示例：&quot;&gt;&lt;/a&gt;使用示例：&lt;/h3&gt;&lt;p&gt;压缩Downloads目录下所有的png，并替换当前图片&lt;/p&gt;
&lt;p&gt;&lt;code&gt;find /Users/mac/Downloads/ -name &amp;quot;*.png&amp;quot; | while read line; do pngquant --ext .png --force $line; done&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.keepmovingxin.com/2016/04/30/pngquant-compress-png/&quot;&gt;http://blog.keepmovingxin.com/2016/04/30/pngquant-compress-png/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;项目包体积越来越大，为了压缩包大小找到一个比较好用的png图片压缩工具，在这记录一下。&lt;/p&gt;
&lt;h3 id=&quot;安装并配置全局变量&quot;&gt;&lt;a href=&quot;#安装并配置全局变量&quot; class=&quot;headerlink&quot; title=&quot;安装并配置全局变量&quot;&gt;&lt;/a&gt;安装并配置全局变量&lt;/h3&gt;&lt;p&gt;安装：&lt;/p&gt;
&lt;p&gt;去官网下载压缩包 或者 源码: &lt;code&gt;git clone git://github.com/pornel/pngquant.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以使用HomeBrew安装：&lt;code&gt;brew install pngquant&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置全局变量(使用HomeBrew安装请忽略)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln –s /下载的位置/pngquant /usr/local/bin/pngquant&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;pngquant 可以愉快的玩耍啦！&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="pngquant" scheme="http://blog.keepmovingxin.com/tags/pngquant/"/>
    
  </entry>
  
  <entry>
    <title>vi/vim显示中文字符并且去掉^M的方法</title>
    <link href="http://blog.keepmovingxin.com/2016/04/29/vi-vim-delete-M/"/>
    <id>http://blog.keepmovingxin.com/2016/04/29/vi-vim-delete-M/</id>
    <published>2016-04-29T05:39:31.000Z</published>
    <updated>2016-04-29T09:09:57.000Z</updated>
    
    <content type="html">&lt;ul&gt;
&lt;li&gt;处理项目xml配置时vim打开经常会碰到中文显示不正常的现象，也就是传说中的乱码，搜索找到一个解决办法，记录一下，但是gbk编码的正常了，utf8的又不对了，于是稍微改了一点。&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;用户目录下创建-vimrc文件&quot;&gt;&lt;a href=&quot;#用户目录下创建-vimrc文件&quot; class=&quot;headerlink&quot; title=&quot;用户目录下创建.vimrc文件&quot;&gt;&lt;/a&gt;用户目录下创建.vimrc文件&lt;/h3&gt;&lt;p&gt;加入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set fileencodings=utf-8,gb2312,gbk,gb18030
set termencoding=utf-8
set fileformats=unix
set encoding=prc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fileencodings中utf-8要在前面&lt;/p&gt;
&lt;p&gt;这样就能正常显示中文了，配合pietty，可以完全正常显示、编辑中文了。&lt;/p&gt;
&lt;h3 id=&quot;几种去除-M的方法&quot;&gt;&lt;a href=&quot;#几种去除-M的方法&quot; class=&quot;headerlink&quot; title=&quot;几种去除^M的方法&quot;&gt;&lt;/a&gt;几种去除^M的方法&lt;/h3&gt;&lt;p&gt;1、&lt;code&gt;cat filename1 | tr -d &amp;quot;\r&amp;quot; &amp;gt; newfile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、 &lt;code&gt;sed -e &amp;quot;s/^V^M//&amp;quot; filename &amp;gt; outputfilename&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3、vi： 用vi打开文件&lt;/p&gt;
&lt;p&gt;(1) 按ESC键&lt;/p&gt;
&lt;p&gt;(2) 输入 :%s/^M//g&lt;/p&gt;
&lt;p&gt;确定 ^M是使用 “CTRL-V CTRL-M” 而不是字面上的 ^M。&lt;/p&gt;
&lt;p&gt;这个正则式将替换所有回车符前的 ^M为空($是为了保证^M出现在行尾)&lt;/p&gt;
&lt;p&gt;4、用 vim 输入 :&lt;code&gt;set notextmode&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可惜，经过上面的处理以后，^M是不存在了，但是换行不成功。所有的东西都在一行上面，看着很费劲。这说明处理的时候文件缺少”\n”，可以在替换的时候添加上即可：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat filename | tr &amp;quot;\r&amp;quot; &amp;quot;\n&amp;quot; &amp;gt; newfile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注: ^M 可以用Sublime Text编辑器查看&lt;/p&gt;
&lt;p&gt;一些linux版本有 dos2unix 程序，可以用来祛除^M&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;处理项目xml配置时vim打开经常会碰到中文显示不正常的现象，也就是传说中的乱码，搜索找到一个解决办法，记录一下，但是gbk编码的正常了，utf8的又不对了，于是稍微改了一点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Vim" scheme="http://blog.keepmovingxin.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令学习</title>
    <link href="http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/"/>
    <id>http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/</id>
    <published>2016-04-28T08:02:52.000Z</published>
    <updated>2016-05-19T07:57:21.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;同步时间&quot;&gt;&lt;a href=&quot;#同步时间&quot; class=&quot;headerlink&quot; title=&quot;同步时间&quot;&gt;&lt;/a&gt;同步时间&lt;/h3&gt;&lt;p&gt;以管理员身份执行如下命令，可以自动与网络时间同步：&lt;br&gt;time.nist.gov 是一个时间服务器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ rdate -s time.nist.gov&lt;/code&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;管道符：&quot;&gt;&lt;a href=&quot;#管道符：&quot; class=&quot;headerlink&quot; title=&quot;管道符： |&quot;&gt;&lt;/a&gt;管道符： |&lt;/h3&gt;&lt;p&gt;就是把前面的命令运行的要放入标准输出的结果丢给后面的命令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat 1.txt | cat&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h3&gt;&lt;p&gt;由一般字符和特殊字符（meta字符）组成&lt;br&gt;meta元字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\ 通常用于打开或关闭后续字符的特殊含义，如\(...\)与\{...\}
. 匹配任何单个字符（除NULL）
\* 匹配前面的子表达式任意次，例：a* 匹配任意多个a
? 匹配前面的子表达式零次或一次匹配前面的子表达式一次或多次。
\+ 匹配前面的子表达式一次或多次
^ 匹配输入字符串的开始位置
$ 匹配输入字符串的结束位置
[] 匹配方括号内的任一字符，其中可用连字符（-）指的连续字符的范围；^符号若出现在方括号的第一个位置，则表示匹配不在列表中的任一字符
(x|y) 匹配x或y，比如：(g|f)ood，匹配good或food
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;文件通配符&quot;&gt;&lt;a href=&quot;#文件通配符&quot; class=&quot;headerlink&quot; title=&quot;文件通配符&quot;&gt;&lt;/a&gt;文件通配符&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;\* 匹配文件名中的任何字符串，包括空字符串。
? 匹配文件名中的任何单个字符。
[...] 匹配[ ]中所包含的任何字符。可以用 – 连接，表示范围
[!...] 匹配[ ]中非 感叹号！之后的字符。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5* 5开头的所有字符串
*5 5结尾的所有字符串
*5? 以5为倒数第二个字符的字符串
[0－9] 所有以数字的字符
[1,2] 1或者2
[!0-9] 不是数字的字符
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;echo-打印&quot;&gt;&lt;a href=&quot;#echo-打印&quot; class=&quot;headerlink&quot; title=&quot;echo 打印&quot;&gt;&lt;/a&gt;echo 打印&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-n    打印语句后不会换行。
-e 开启转义，即可以打印后面的 \t,\r 等转义字符
可以打印彩色文本。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;printf-格式化输出&quot;&gt;&lt;a href=&quot;#printf-格式化输出&quot; class=&quot;headerlink&quot; title=&quot;printf 格式化输出&quot;&gt;&lt;/a&gt;printf 格式化输出&lt;/h3&gt;&lt;p&gt;用于格式化输出，使用的参数和C语言中的printf函数一样&lt;br&gt;eg：printf “%-5s %-10s %-4.2f\n” 1 James 80.9968&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-：表示左对齐，默认为右对齐
s：表示打印的是字符串
f：表示打印一个浮点数，其中4表示宽度，.2表示保留2位小数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;printf默认不带换行，需要手动添加&lt;/p&gt;
&lt;h3 id=&quot;cat-查看文件&quot;&gt;&lt;a href=&quot;#cat-查看文件&quot; class=&quot;headerlink&quot; title=&quot;cat 查看文件&quot;&gt;&lt;/a&gt;cat 查看文件&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-n：为每行前面加上行号。-n会为空白行也加上行号，-b选项则会跳过空白行。
-s：压缩相邻的空白行，即连续的空白行将压缩为一行。
-T：用^I符号表示制表符\t
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;grep-匹配&quot;&gt;&lt;a href=&quot;#grep-匹配&quot; class=&quot;headerlink&quot; title=&quot;grep 匹配&quot;&gt;&lt;/a&gt;grep 匹配&lt;/h3&gt;&lt;p&gt;grep [options] [表达式]&lt;br&gt;1)    [options]列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-c    ：只输出匹配行的统计数
-n    ：显示匹配行及行号
-A2    ：列出匹配行及下面2行
-B2    ：列出匹配行及上面2行
-C2    ：列出匹配行及上下2行
-I    ：不区分大小写(只适用于单字符)
-h    ：查询多文件时不显示文件名
-H    ：查询多文件时显示文件名（默认）
-l    ：查询多文件时只输出包含匹配字符的文件名
-o    : 每行只输出匹配部分
-s    ：不显示不存在或无匹配文本的错误信息
-v    ：显示不包含匹配文本的所有行
-r    ：递归匹配目录下所有文件及目录
-E    : 扩展grep，增加了额外的正则表达式元字符集
-e    ：指定多个匹配样式，样式间“或”的关系
-f pattern_file    ：    样式文件pattern_file中逐行存放要匹配的样式，可匹配多个样式，样式之间是“或”的关系
--color    ：    为匹配项显示不同颜色
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)    &lt;code&gt;grep –E &amp;quot;pattern1|pattern2&amp;quot; files&lt;/code&gt; ：显示匹配 pattern1 或 pattern2 的行&lt;br&gt;3)    &lt;code&gt;grep –e pattern1 –e pattern2 files&lt;/code&gt; : 匹配pattern1或pattern2&lt;br&gt;4)    &lt;code&gt;grep pattern1 files | grep pattern2&lt;/code&gt; ：显示既匹配 pattern1 又匹配 pattern2 的行&lt;br&gt;5)    &lt;code&gt;egrep &amp;quot;t_hero|t_item&amp;quot;&lt;/code&gt;   匹配t_hero或者t_item的项&lt;br&gt;6)    &lt;code&gt;grep &amp;quot;t_hero\|t_item&amp;quot;&lt;/code&gt;    可以实现与上面同样的功能&lt;/p&gt;
&lt;h3 id=&quot;sed-处理内容&quot;&gt;&lt;a href=&quot;#sed-处理内容&quot; class=&quot;headerlink&quot; title=&quot;sed 处理内容&quot;&gt;&lt;/a&gt;sed 处理内容&lt;/h3&gt;&lt;p&gt;&lt;code&gt;sed [options] &amp;#39;command&amp;#39; file(s) 或sed [options] -f scriptfile file(s)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一次处理一行内容 不改变文件内容&lt;br&gt;[options]列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-n    :    取消默认的输出,使用安静(silent)模式。
-r    :    使用正则表达式，及表达式中不需要进行转义
-f filename :    指定sed脚本的文件名filename
-e &amp;apos;&amp;apos; :    允许多重编辑·  
-i    :    将替换结果应用于源文件
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1)    替换字符串&lt;br&gt;&lt;code&gt;sed &amp;#39;s/pattern/string/&amp;#39; file&lt;/code&gt;&lt;br&gt;或者&lt;br&gt;&lt;code&gt;cat file | sed &amp;#39;s/pattern/string/&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2)    替换文件中所有匹配内容，使用参数g&lt;br&gt;&lt;code&gt;sed &amp;#39;s/pattern/string/g&amp;#39; file&lt;/code&gt;&lt;br&gt;但如果你想从第N处匹配开始替换，可以使用参数/Ng&lt;br&gt;&lt;code&gt;$ echo thisthisthisthis | sed &amp;#39;s/this/THIS/2g&amp;#39;
thisTHISTHISTHIS&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3)    sed的定界符’/‘.当匹配模式中含有’/‘字符时，我们需要用’\’对定界符’/‘进行转义&lt;br&gt;&lt;code&gt;$ echo a/b | sed &amp;#39;s/a\/b/a*b/&amp;#39;
a*b&lt;/code&gt;&lt;br&gt;为了避免转义字符造成的理解困难，我们可以使用其它定界符，比如|,:,@,#,$,%,+等等&lt;br&gt;&lt;code&gt;$ echo a/b | sed &amp;#39;s:a/b:a*b:&amp;#39;
a*b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4)    移除匹配样式行  &lt;code&gt;sed &amp;#39;/pattern/d&amp;#39; file&lt;/code&gt;&lt;br&gt;&lt;code&gt;$ sed -r &amp;#39;/^ *$/d&amp;#39; args.txt        #移除空白行，含有一个或多个空格的行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5)    组合多个表达式&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ echo abd | sed &amp;apos;s/a/A/&amp;apos; | sed &amp;apos;s/d/D/&amp;apos;  #用管道组合$ echo abd | sed &amp;apos;s/a/A/;s/d/D/&amp;apos;           #用分号组合$ echo abd | sed -e &amp;apos;s/a/A/&amp;apos; -e &amp;apos;s/d/D/&amp;apos;  #用-e选项组合&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;6)    已匹配字符串标记（&amp;amp;）&lt;br&gt;&amp;amp;代表匹配给定样式的字符串，常用于对给定样式增加[]，{}等不需要改变样式的情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;this is an example&amp;quot; | sed &amp;apos;s/\w\+/[&amp;amp;]/g&amp;apos;   #\w\+ 匹配每个单词
[this] [is] [an] [example]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7)    子串匹配标记（\1）&lt;br&gt;有时我们希望对匹配给定的样式标记出一些子串来，方便后续引用&lt;br&gt;(pattern) 用于匹配子串pattern&lt;br&gt;\1 用于引用第一个匹配到的子串，\n 对应第n个匹配到的子串。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo 123 asd | sed &amp;apos;s/\([0-9]\+\) \([a-z]\+\)/\2+\1/&amp;apos; 
asd+123
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中\1对应数字123，\2对应字母asd&lt;br&gt;对于子串的引用，在样式里一定要用()括起来，如果加上-r选项，则不需要转义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo 123 asd | sed -r &amp;apos;s/([0-9]+) ([a-z]+)/\2+\1/&amp;apos;
asd+123
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8)    引用&lt;br&gt;在脚本中有用的一点，用双引号引用的sed表达式，会对表达式求值来进行扩展，如使用前面定义的变量等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ text=hello
$ echo hello world | sed &amp;quot;s/$text/HELLO/&amp;quot;
HELLO world
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;tail-查看文件&quot;&gt;&lt;a href=&quot;#tail-查看文件&quot; class=&quot;headerlink&quot; title=&quot;tail 查看文件&quot;&gt;&lt;/a&gt;tail 查看文件&lt;/h3&gt;&lt;p&gt;用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件&lt;br&gt;主要参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-f ：    循环读取   #可以用在监控线上有没有报错信息
-q ：    不显示处理信息
-v ：    显示详细的处理信息
-c&amp;lt;数目&amp;gt; ：    显示的字节数
-n&amp;lt;行数&amp;gt; ：    显示行数
--pid=PID ：    与-f合用,表示在进程ID,PID死掉之后结束. 
-q, --quiet, --silent ：    从不输出给出文件名的首部
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;find-查找&quot;&gt;&lt;a href=&quot;#find-查找&quot; class=&quot;headerlink&quot; title=&quot;find 查找&quot;&gt;&lt;/a&gt;find 查找&lt;/h3&gt;&lt;p&gt;&lt;code&gt;find dir [option] &amp;#39;command&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;dir&lt;/code&gt;: 目录名，用空格隔开多个目录&lt;br&gt;1) [option]列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-name wildcard 文件名，wildcard表示通配符，并非正则式
    find dir1 dir2 -name &amp;apos;*.c&amp;apos; –print  在目录dir1和dir2中查找文件，并打印路径
    如果在-name后面紧跟一个-prune，则表示此目录应被修剪
    find . \( -name &amp;quot;.svn&amp;quot; -prune \) -o –print 表示对于查找的目录，要么修剪掉（.svn），要么打印出来（其他）。
-iname 忽略名字大小写
-path 指定目录，如果在-path前面加上 ！ ，则表示忽略此目录，目录名可以使用通配符匹配。
-type 文件类型
    f:普通文件 d:目录 l:符号连接文件 c:字符设备文件 b:块设备文件 p:管道文件
-size ±nc 查找大于（+）或小于（-）n字节的文件，注意c（charter）
-mtime ±ndays 文件最近修改时间
-user,-nouser 文件所有者
-group,-nogroup 指定文件用户组
多条件的与（-a）/或（-o）/非（！）
    find . \( -name &amp;quot;*.txt&amp;quot; –o –name &amp;quot;*.sh&amp;quot; \) –print
    括号两边应该有空格
-maxdepth n 指定最大目录深度，n=1表示最大为当前目录
-mindepth n 指定最小目录深度，n=2表示不打印当前目录下的文件
  -maxdepth和-mindepth应作为find的第三个参数出现，以提高效率
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2) ‘command’命令列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-print  打印路径名
-delete 对找到的文件进行删除 
-exec   对查找到的目标执行某一命令。
    find ${workdir} -name &amp;quot;$filename&amp;quot; -exec  |grep $uid
    -exec 参数后面跟的是bash命令，但只能跟一个命令，如果想执行多个命令，那么可以将多个命令放进一个shell脚本，然后执行这个脚本。
    bash命令的终止，使用 &amp;apos;;&amp;apos; (分号）来判定，在后面必须有一个 &amp;apos;;&amp;apos;在分号前应该加上转义字符&amp;apos;\&amp;apos;
    &amp;apos;{}&amp;apos;，使用{}来表示文件名，也就是find前面处理过程中过滤出来的文件，用于bash命令进行处理
-ok     与-exec类似，只是对查找到符合条件的目标执行一个命令前需要经过确认
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;cut-剪切&quot;&gt;&lt;a href=&quot;#cut-剪切&quot; class=&quot;headerlink&quot; title=&quot;cut 剪切&quot;&gt;&lt;/a&gt;cut 剪切&lt;/h3&gt;&lt;p&gt;&lt;code&gt;cut&lt;/code&gt; 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出，必须指定 &lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;-c&lt;/code&gt; 或&lt;code&gt;-f&lt;/code&gt; 标志之一。&lt;br&gt;主要参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-b: 以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。
-c: 以字符为单位进行分割。（单个字母等）
    cut –c2-5 file    ，表示将文件file每行的第2-5个字符作为一列显示出来。
-d: 自定义分隔符，默认为制表符。
-f: 与-d一起使用，指定显示哪个区域。
    例子：cat file.txt | cut -d&amp;apos;]&amp;apos; -f7；
        cat file.txt | cut -d&amp;apos;]&amp;apos; –f4,7；//打印4和7列
        cat file.txt | cut -d&amp;apos;]&amp;apos; –f4-7；//打印4到7列
-n: 取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的&amp;lt;br /&amp;gt;范围之内，该字符将被写出；否则，该字符将被排除。
--complement: 与-f一起使用，指定显示哪个区域的补集。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;sort-排序&quot;&gt;&lt;a href=&quot;#sort-排序&quot; class=&quot;headerlink&quot; title=&quot;sort 排序&quot;&gt;&lt;/a&gt;sort 排序&lt;/h3&gt;&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按&lt;code&gt;ASCII&lt;/code&gt;码值进行比较，最后将他们按升序输出。&lt;br&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-u: 去除重复行
-r: sort默认的排序方式是升序，如果想改成降序，用此参数
-o file: 把排序结果输出到文件file，file可以是原文件
-n: 以数值排序
-t: 指定间隔符
-k: 指定域排序，常与-t连用。sort –t &amp;apos;:&amp;apos; –k 2
    在指定域的时候还可细分，比如指定第二个域的第3个字符开始比较，用-k 2.3;
    比如指定第二个域的第3个字符到第二个域的第5个字符进行排序，用-k 2.3,2.5
    比如只指定第二个域的第3个字符进行排序，用-k 2.3,2.3
-b: 忽略每一行前面的所有空白部分，从第一个可见字符开始比较
-f: 忽略大小写进行排序
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;uniq-去重&quot;&gt;&lt;a href=&quot;#uniq-去重&quot; class=&quot;headerlink&quot; title=&quot;uniq 去重&quot;&gt;&lt;/a&gt;uniq 去重&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-c : 统计重复的行数
-u : 只显示不重复的那些行
-d : 只显示重复的那些行
-s n : 指定跳过前n个字符
-w n : 指定用于比较的最大字符数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;wc-统计&quot;&gt;&lt;a href=&quot;#wc-统计&quot; class=&quot;headerlink&quot; title=&quot;wc 统计&quot;&gt;&lt;/a&gt;wc 统计&lt;/h3&gt;&lt;p&gt;使用wc的各种选项来统计行数、单词数和字符数。&lt;br&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-l ：行数
-w ：单词数
-c ：字符数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;seq-产生整数&quot;&gt;&lt;a href=&quot;#seq-产生整数&quot; class=&quot;headerlink&quot; title=&quot;seq 产生整数&quot;&gt;&lt;/a&gt;seq 产生整数&lt;/h3&gt;&lt;p&gt;&lt;code&gt;seq A B&lt;/code&gt;: 用于产生从某个数到另外一个数之间的所有整数&lt;br&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-f：指定格式。默认是&amp;quot;%g&amp;quot;，表示按宽度为1输出。可以在g的前面加入一些字符，表示不同的含义，如：
   %2g：表示按宽度为2右对齐。
   %02g：表示按宽度为2右对齐，不足的部分用0补足。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可用于构造日志文件名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i in `seq -f &amp;quot;log.20160407&amp;quot;%02g 5 12`; do echo $i; done
   str%03g：表示按宽度为3右对齐，补足的位数用0补，并在前面加上str子串。
    %-3g：表示按宽度为3左对齐。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;mkdir-创建目录&quot;&gt;&lt;a href=&quot;#mkdir-创建目录&quot; class=&quot;headerlink&quot; title=&quot;mkdir 创建目录&quot;&gt;&lt;/a&gt;mkdir 创建目录&lt;/h3&gt;&lt;p&gt;常用参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-p: 可以是一个路径名称。此时若路径中的某些目录尚不存在，加上此选项后,系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录;
-m &amp;lt;777&amp;gt;: 模式，设定权限&amp;lt;模式&amp;gt;
-v: 在创建目录的同时输出信息。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;date-时间&quot;&gt;&lt;a href=&quot;#date-时间&quot; class=&quot;headerlink&quot; title=&quot;date 时间&quot;&gt;&lt;/a&gt;date 时间&lt;/h3&gt;&lt;p&gt;1) 显示时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date [OPTION]... [+FORMAT]
date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;  #显示当前的年月日时分秒
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2) 设置时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date -s //设置当前时间，只有root权限才能设置，其他只能查看。
date -s 20080523 //设置成20080523，这样会把具体时间设置成空00:00:00
date -s 15:20:30 //设置时间
date +%s //当前时间时间戳
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3) 转换时间&lt;br&gt;把linux下的时间戳转换成现实中的年月日时分秒&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date –d @timestamp
eg:$date -d @1433087999
 2015年 05月 31日 星期日 23:59:59 CST
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;md5sum-MD5&quot;&gt;&lt;a href=&quot;#md5sum-MD5&quot; class=&quot;headerlink&quot; title=&quot;md5sum MD5&quot;&gt;&lt;/a&gt;md5sum MD5&lt;/h3&gt;&lt;p&gt;MD5全称是报文摘要算法（Message-Digest Algorithm 5），此算法对任意长度的信息逐位进行计算，产生一个二进制长度为128位（十六进制长度32位）的“指纹”（或称“报文摘要”），即使两个文件只相差一个字符，产生的校验和也完全不同。&lt;br&gt;1) 使用md5sum来产生指纹（报文摘要）命令如下：&lt;br&gt;     &lt;code&gt;md5sum file &amp;gt; file.md5&lt;/code&gt;&lt;br&gt;若不指定文件名，则从标准输入读取，也可输出到标准输出设备，因此可与管道符“|”连用。&lt;br&gt; 可以使用文件通配符，将多个文件的md5值输出到同一个文件。&lt;br&gt;文件file.md5的内容如下：&lt;br&gt;      &lt;code&gt;c0e207c045c344ebf363c3e9a6de1076  file&lt;/code&gt;&lt;br&gt; 第一列是md5校验和，第二列是对应文件名。&lt;br&gt;2) 使用md5报文摘要验证文件。&lt;br&gt;将生成的file.md5文件放在对应file文件的同一目录下。使用如下命令验证：&lt;br&gt;     &lt;code&gt;md5sum -c file.md5&lt;/code&gt;&lt;br&gt;若验证成功，输出“file: 确定”；验证失败则输出“file: 失败”，并打印警告信息：“md5sum: 警告：1/1 生成的校验和不匹配”。&lt;/p&gt;
&lt;h3 id=&quot;ln-链接&quot;&gt;&lt;a href=&quot;#ln-链接&quot; class=&quot;headerlink&quot; title=&quot;ln 链接&quot;&gt;&lt;/a&gt;ln 链接&lt;/h3&gt;&lt;p&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-f : 链结时先将与 dist 同档名的档案删除
-d : 允许系统管理者硬链结自己的目录
-i : 在删除与 dist 同档名的档案时先进行询问
-n : 在进行软连结时，将 dist 视为一般的档案
-s : 进行软链结(symbolic link)
     ln –s target new
     为target文件建立一个软链接new指向target
-v : 在连结之前显示其档名
-b : 将在链结时会被覆写或删除的档案进行备份
-S SUFFIX : 将备份的档案都加上 SUFFIX 的字尾
-V METHOD : 指定备份的方式
--help : 显示辅助说明
--version : 显示版本
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;split-大文件切割&quot;&gt;&lt;a href=&quot;#split-大文件切割&quot; class=&quot;headerlink&quot; title=&quot;split 大文件切割&quot;&gt;&lt;/a&gt;split 大文件切割&lt;/h3&gt;&lt;p&gt; &lt;code&gt;split -b 500m file newfile_prefix&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-l：行数，指定每多少行切成一个小文件。
-b：指定每多少字就要切成一个小文件。支持单位:m,k
-C：与-b参数类似，但切割时尽量维持每行的完整性。
-d：指定切割后的文件名以数字作为后缀
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;合并： &lt;code&gt;cat newfile_prefix* &amp;gt; newfile&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;alias-别名&quot;&gt;&lt;a href=&quot;#alias-别名&quot; class=&quot;headerlink&quot; title=&quot;alias 别名&quot;&gt;&lt;/a&gt;alias 别名&lt;/h3&gt;&lt;p&gt;&lt;code&gt;alias myssh=’sh filename.sh’&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;chmod-权限&quot;&gt;&lt;a href=&quot;#chmod-权限&quot; class=&quot;headerlink&quot; title=&quot;chmod 权限&quot;&gt;&lt;/a&gt;chmod 权限&lt;/h3&gt;&lt;p&gt;使用chmod命令设置文件权限。&lt;br&gt;&lt;code&gt;chmod a+x file&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;u ： 指定用户权限
g ： 指定用户组权限
o ： 指定其他用户权限
a ： 指定所有类别
+ ： 增加权限
- ： 删除权限
r ： 可读
w ： 可写
x ： 可执行，对目录文件来说表示可访问目录中的文件和子目录
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;vim-文本编辑工具&quot;&gt;&lt;a href=&quot;#vim-文本编辑工具&quot; class=&quot;headerlink&quot; title=&quot;vim 文本编辑工具&quot;&gt;&lt;/a&gt;vim 文本编辑工具&lt;/h3&gt;&lt;p&gt;&lt;code&gt;vimdiff&lt;/code&gt; 文本差异对比&lt;br&gt;&lt;code&gt;vimdiff  FILE_LEFT  FILE_RIGHT&lt;/code&gt;&lt;br&gt;常用命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ctrl-w K 把当前窗口移到最上边
Ctrl-w H 把当前窗口移到最左边
Ctrl-w J 把当前窗口移到最下边
Ctrl-w L 把当前窗口移到最右边
Ctrl-w,w  在两个文件之间来回跳转
]c   跳转到下一差异点
[c   跳转到上一差异点，可在前面加上数字，表示跳转多少个差异
dp(diff put) 把一个差异点中当前文件的内容复制到另一个文件中
do(diff get) 另一个文件的内容复制到当前行中
:diffupdate 手工来刷新比较结果
zo(folding open) 展开被折叠的相同的文本行
zc(folding close) 重新折叠
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;paste-拼接&quot;&gt;&lt;a href=&quot;#paste-拼接&quot; class=&quot;headerlink&quot; title=&quot;paste 拼接&quot;&gt;&lt;/a&gt;paste 拼接&lt;/h3&gt;&lt;p&gt;用paste命令实现按列拼接。&lt;br&gt;&lt;code&gt;$ paste file1 file2 file3...&lt;/code&gt;&lt;br&gt;参数：&lt;br&gt;&lt;code&gt;-d：指定定界符&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;ls-列出目录&quot;&gt;&lt;a href=&quot;#ls-列出目录&quot; class=&quot;headerlink&quot; title=&quot;ls 列出目录&quot;&gt;&lt;/a&gt;ls 列出目录&lt;/h3&gt;&lt;p&gt;以下是几种方法列出当前路径下的目录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls –d */
ls –F | grep &amp;quot;/$&amp;quot;
ls –l | grep &amp;quot;^d&amp;quot;
find . –type d –maxdepth 1 –print
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;jps-显示java进程&quot;&gt;&lt;a href=&quot;#jps-显示java进程&quot; class=&quot;headerlink&quot; title=&quot;jps 显示java进程&quot;&gt;&lt;/a&gt;jps 显示java进程&lt;/h3&gt;&lt;p&gt;显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。&lt;br&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数
-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null
-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名
-v 输出传递给JVM的参数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;xargs-参数传递&quot;&gt;&lt;a href=&quot;#xargs-参数传递&quot; class=&quot;headerlink&quot; title=&quot;xargs 参数传递&quot;&gt;&lt;/a&gt;xargs 参数传递&lt;/h3&gt;&lt;p&gt;&lt;code&gt;xargs [-0opt] [-E eofstr] [-I replstr [-R replacements]] [-J replstr] [-L number] [-n number [-x]] [-P maxprocs] [-s size] [utility [argument ...]]&lt;/code&gt;&lt;br&gt;给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。&lt;br&gt;最经典应用模式：  &lt;code&gt;somecommand | xargs -item  command&lt;/code&gt;&lt;br&gt;不带&lt;code&gt;command&lt;/code&gt;，默认的使用&lt;code&gt;echo&lt;/code&gt;输出&lt;/p&gt;
&lt;p&gt;用途：&lt;br&gt;1.构造参数列表并运行命令，即将接收的参数传递给后面的&lt;code&gt;command&lt;/code&gt;命令执行&lt;br&gt;2.将多行输入转换为单行（特殊功效）&lt;/p&gt;
&lt;p&gt;优点：&lt;br&gt;1.将输入参数整理后，去除&lt;code&gt;&amp;lt;newline&amp;gt;&lt;/code&gt;换行符，以一个列表形式处理&lt;br&gt;2.避免参数过长引发的问题，使用&lt;code&gt;xargs -n&lt;/code&gt; 参数适当控制，对于经常产生大量输出的命令如&lt;code&gt;find&lt;/code&gt;、&lt;code&gt;locate&lt;/code&gt;和&lt;code&gt;grep&lt;/code&gt;来说非常有用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-item&lt;/code&gt; 代表选项:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-0      当sdtin含有特殊字元时候，将其当成一般字符，想/&amp;apos;空格等
-a file 从文件中读入作为sdtin
-e flag 注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。
-E EOF  指定输入结束符
-n num  后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。
-p      操作具有可交互性，每次执行comand都交互式提示用户选择，当每次执行一个argument的时候询问一次用户
-t      表示先打印命令，然后再执行。
-i      或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给{}，可以用{}代替。
-r      no-run-if-empty 如果没有要处理的参数传递给xargs，xargs 默认是带 空参数运行一次，如果你希望无参数时，停止 xargs，直接退出，使用 -r 选项即可，其可以防止xargs 后面命令带空参数运行报错。
-s      num xargs后面那个命令的最大命令行字符数(含空格) 
-L      从标准输入一次读取num行送给Command命令 ，-l和-L功能一样
-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符
-x      exit的意思，如果有任何 Command 行大于 -s Size 标志指定的字节数，停止运行 xargs 命令，-L -I -n 默认打开-x参数，主要是配合-s使用
-P      修改最大的进程数，默认是1，为0时候为as many as it can.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;未完待续…&quot;&gt;&lt;a href=&quot;#未完待续…&quot; class=&quot;headerlink&quot; title=&quot;未完待续…&quot;&gt;&lt;/a&gt;未完待续…&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/&quot;&gt;http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;同步时间&quot;&gt;&lt;a href=&quot;#同步时间&quot; class=&quot;headerlink&quot; title=&quot;同步时间&quot;&gt;&lt;/a&gt;同步时间&lt;/h3&gt;&lt;p&gt;以管理员身份执行如下命令，可以自动与网络时间同步：&lt;br&gt;time.nist.gov 是一个时间服务器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ rdate -s time.nist.gov&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://blog.keepmovingxin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x使用CCGLProgram和Shader文件实现精灵置灰</title>
    <link href="http://blog.keepmovingxin.com/2016/04/27/cocos2d-x-GraySprite/"/>
    <id>http://blog.keepmovingxin.com/2016/04/27/cocos2d-x-GraySprite/</id>
    <published>2016-04-27T09:47:46.000Z</published>
    <updated>2016-05-18T10:03:14.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;1-实现方法：CCGraySprite-继承自-CCSprite-覆盖initWithTexture和draw方法实现置灰。&quot;&gt;&lt;a href=&quot;#1-实现方法：CCGraySprite-继承自-CCSprite-覆盖initWithTexture和draw方法实现置灰。&quot; class=&quot;headerlink&quot; title=&quot;1. 实现方法：CCGraySprite 继承自 CCSprite 覆盖initWithTexture和draw方法实现置灰。&quot;&gt;&lt;/a&gt;1. 实现方法：&lt;code&gt;CCGraySprite&lt;/code&gt; 继承自 &lt;code&gt;CCSprite&lt;/code&gt; 覆盖&lt;code&gt;initWithTexture&lt;/code&gt;和&lt;code&gt;draw&lt;/code&gt;方法实现置灰。&lt;/h4&gt;&lt;h5 id=&quot;方法和属性声明：&quot;&gt;&lt;a href=&quot;#方法和属性声明：&quot; class=&quot;headerlink&quot; title=&quot;方法和属性声明：&quot;&gt;&lt;/a&gt;方法和属性声明：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class CCGraySprite : public CCSprite&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CCGraySprite();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    virtual ~CCGraySprite();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* create(const char* pszFileName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool initWithTexture(CCTexture2D* pTexture, const CCRect&amp;amp; tRect);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* createWithSprite(CCSprite *pSprite);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* createWithNodeAndItChild(CCNode *pNode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void setGray(bool isGray);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    virtual void draw();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool m_isGray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CCGLProgram* pProgram;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m_isGray&lt;/code&gt; 是否置灰&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pProgram&lt;/code&gt; 保存置灰的GL程序&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;2-shader字符串&quot;&gt;&lt;a href=&quot;#2-shader字符串&quot; class=&quot;headerlink&quot; title=&quot;2. shader字符串:&quot;&gt;&lt;/a&gt;2. shader字符串:&lt;/h4&gt;&lt;p&gt;可以像官方那样写在一个.h文件中&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GLchar* pszFragSource = (GLchar*)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;#ifdef GL_ES \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        precision mediump float; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #endif \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uniform sampler2D u_texture; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        varying vec2 v_texCoord; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        varying vec4 v_fragmentColor; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        void main(void) \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Convert to greyscale using NTSC weightings \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vec4 col = texture2D(u_texture, v_texCoord); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        float grey = dot(col.rgb, vec3(0.299, 0.587, 0.114)); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        gl_FragColor = vec4(grey, grey, grey, col.a); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;3-核心代码：&quot;&gt;&lt;a href=&quot;#3-核心代码：&quot; class=&quot;headerlink&quot; title=&quot;3. 核心代码：&quot;&gt;&lt;/a&gt;3. 核心代码：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;覆盖父类的&lt;code&gt;initWithTexture&lt;/code&gt;和&lt;code&gt;draw&lt;/code&gt;方法，根据&lt;code&gt;m_isGray&lt;/code&gt;调用对应GL程序进行渲染绘制精灵&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void CCGraySprite::setGray(bool isGray) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m_isGray = isGray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (isGray == true) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;setShaderProgram(pProgram);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;setShaderProgram(CCShaderCache::sharedShaderCache()-&amp;gt;programForKey(kCCShader_PositionTextureColor));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool CCGraySprite::initWithTexture(CCTexture2D* pTexture, const CCRect&amp;amp; tRect )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m_isGray = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CC_BREAK_IF(!CCSprite::initWithTexture(pTexture, tRect));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        GLchar* pszFragSource = (GLchar*)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;#ifdef GL_ES \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        precision mediump float; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #endif \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uniform sampler2D u_texture; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        varying vec2 v_texCoord; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        varying vec4 v_fragmentColor; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        void main(void) \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Convert to greyscale using NTSC weightings \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vec4 col = texture2D(u_texture, v_texCoord); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        float grey = dot(col.rgb, vec3(0.299, 0.587, 0.114)); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        gl_FragColor = vec4(grey, grey, grey, col.a); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pProgram = new CCGLProgram();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pProgram-&amp;gt;initWithVertexShaderByteArray(ccPositionTextureColor_vert, pszFragSource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;setShaderProgram(pProgram);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHECK_GL_ERROR_DEBUG();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;addAttribute(kCCAttributeNamePosition, kCCVertexAttrib_Position);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;addAttribute(kCCAttributeNameColor, kCCVertexAttrib_Color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;addAttribute(kCCAttributeNameTexCoord, kCCVertexAttrib_TexCoords);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHECK_GL_ERROR_DEBUG();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;link();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHECK_GL_ERROR_DEBUG();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;updateUniforms();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHECK_GL_ERROR_DEBUG();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; while (0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CCGraySprite::draw()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (this-&amp;gt;getTexture() == NULL) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(m_isGray == false)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CCSprite::draw();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ccGLEnableVertexAttribs(kCCVertexAttribFlag_PosColorTex );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ccGLBlendFunc( m_sBlendFunc.src, m_sBlendFunc.dst );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this-&amp;gt;getShaderProgram()-&amp;gt;use();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this-&amp;gt;getShaderProgram()-&amp;gt;setUniformsForBuiltins();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ccGLBindTexture2D( this-&amp;gt;getTexture()-&amp;gt;getName() );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#define kQuadSize sizeof(m_sQuad.bl)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long offset = (long)&amp;amp;m_sQuad;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // vertex&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int diff = offsetof( ccV3F_C4B_T2F, vertices);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    glVertexAttribPointer(kCCVertexAttrib_Position, 3, GL_FLOAT, GL_FALSE, kQuadSize, (void*) (offset + diff));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // texCoods&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    diff = offsetof( ccV3F_C4B_T2F, texCoords);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, kQuadSize, (void*)(offset + diff));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // color&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    diff = offsetof( ccV3F_C4B_T2F, colors);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_UNSIGNED_BYTE, GL_TRUE, kQuadSize, (void*)(offset + diff));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CC_INCREMENT_GL_DRAWS(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;4-lua使用示例&quot;&gt;&lt;a href=&quot;#4-lua使用示例&quot; class=&quot;headerlink&quot; title=&quot;4. lua使用示例&quot;&gt;&lt;/a&gt;4. lua使用示例&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;需手写.pkg文件，使用tolua++工具导出Lua binding文件，在AppDelegate::applicationDidFinishLaunching()注册后，方可在lua层使用&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local nameBgSp = CCGraySprite:create(&amp;quot;images/namebg.png&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local normalSp = CCSprite:create(&amp;quot;images/namebg.png&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local graySp = CCGraySprite:createWithNodeAndItChild(normalSp)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local frameSp = CCGraySprite:create(&amp;quot;images/frame.png&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frameSp:setGray(isGray)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.keepmovingxin.com/2016/04/27/cocos2d-x-GraySprite/&quot;&gt;http://blog.keepmovingxin.com/2016/04/27/cocos2d-x-GraySprite/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-实现方法：CCGraySprite-继承自-CCSprite-覆盖initWithTexture和draw方法实现置灰。&quot;&gt;&lt;a href=&quot;#1-实现方法：CCGraySprite-继承自-CCSprite-覆盖initWithTexture和draw方法实现置灰。&quot; class=&quot;headerlink&quot; title=&quot;1. 实现方法：CCGraySprite 继承自 CCSprite 覆盖initWithTexture和draw方法实现置灰。&quot;&gt;&lt;/a&gt;1. 实现方法：&lt;code&gt;CCGraySprite&lt;/code&gt; 继承自 &lt;code&gt;CCSprite&lt;/code&gt; 覆盖&lt;code&gt;initWithTexture&lt;/code&gt;和&lt;code&gt;draw&lt;/code&gt;方法实现置灰。&lt;/h4&gt;&lt;h5 id=&quot;方法和属性声明：&quot;&gt;&lt;a href=&quot;#方法和属性声明：&quot; class=&quot;headerlink&quot; title=&quot;方法和属性声明：&quot;&gt;&lt;/a&gt;方法和属性声明：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class CCGraySprite : public CCSprite&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CCGraySprite();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    virtual ~CCGraySprite();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* create(const char* pszFileName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool initWithTexture(CCTexture2D* pTexture, const CCRect&amp;amp; tRect);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* createWithSprite(CCSprite *pSprite);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* createWithNodeAndItChild(CCNode *pNode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void setGray(bool isGray);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    virtual void draw();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool m_isGray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CCGLProgram* pProgram;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m_isGray&lt;/code&gt; 是否置灰&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pProgram&lt;/code&gt; 保存置灰的GL程序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Cocos2d-x" scheme="http://blog.keepmovingxin.com/tags/Cocos2d-x/"/>
    
  </entry>
  
  <entry>
    <title>Git Config命令查看配置文件</title>
    <link href="http://blog.keepmovingxin.com/2016/04/27/Git-Config/"/>
    <id>http://blog.keepmovingxin.com/2016/04/27/Git-Config/</id>
    <published>2016-04-27T08:31:28.000Z</published>
    <updated>2016-04-29T03:15:37.000Z</updated>
    
    <content type="html">&lt;p&gt;git config命令的基本使用&lt;/p&gt;
&lt;h3 id=&quot;配置文件如何生效&quot;&gt;&lt;a href=&quot;#配置文件如何生效&quot; class=&quot;headerlink&quot; title=&quot;配置文件如何生效&quot;&gt;&lt;/a&gt;配置文件如何生效&lt;/h3&gt;&lt;p&gt;对于 git 来说，配置文件的权重是仓库&amp;gt;全局&amp;gt;系统。Git 会使用这一系列的配置文件来存储你定义的偏好，它首先会查找 /etc/gitconfig 文件（系统级），该文件含有对系统上所有用户及他们所拥有的仓库都生效的配置值。接下来 Git 会查找每个用户的 ~/.gitconfig 文件（全局级）。最后 Git 会查找由用户定义的各个库中Git目录下的配置文件 .git/config（仓库级），该文件中的值只对当前所属仓库有效。以上阐述的三 层配置从一般到特殊层层推进，如果定义的值有冲突，以后面层中定义的为准，例如：.git/config 和 /etc/gitconfig 的较量中， .git/config 取得了胜利。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;使用-git-config-命令查看配置文件&quot;&gt;&lt;a href=&quot;#使用-git-config-命令查看配置文件&quot; class=&quot;headerlink&quot; title=&quot;使用 git config 命令查看配置文件&quot;&gt;&lt;/a&gt;使用 git config 命令查看配置文件&lt;/h3&gt;&lt;p&gt;命令参数–list, 简写 -l&lt;/p&gt;
&lt;p&gt;格式：&lt;code&gt;git config [–local|–global|–system] -l&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;查看仓库级的 config，命令：git config –local -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看全局级的 config，命令：git config –global -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看系统级的 config，命令：git config –system -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看当前生效的配置，  命令：git config -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;使用-git-config-命令编辑配置文件&quot;&gt;&lt;a href=&quot;#使用-git-config-命令编辑配置文件&quot; class=&quot;headerlink&quot; title=&quot;使用 git config 命令编辑配置文件&quot;&gt;&lt;/a&gt;使用 git config 命令编辑配置文件&lt;/h3&gt;&lt;p&gt;命令参数 –edit, 简写 -e&lt;/p&gt;
&lt;p&gt;格式：&lt;code&gt;git config [–local|–global|–system] -e&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;查看仓库级的config，命令：git config –local -e，与–list参数不同的是，git config -e默认是编辑仓库级的配置文件。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看全局级的config，命令：git config –global -e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看系统级的config，命令：git config –system -e&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行这个命令的时候，git 会用配置文件中设定的编辑器打开配置文件。&lt;/p&gt;
&lt;h3 id=&quot;增加一个配置项&quot;&gt;&lt;a href=&quot;#增加一个配置项&quot; class=&quot;headerlink&quot; title=&quot;增加一个配置项&quot;&gt;&lt;/a&gt;增加一个配置项&lt;/h3&gt;&lt;p&gt;参数 –add&lt;/p&gt;
&lt;p&gt;格式: &lt;code&gt;git config [–local|–global|–system] –add section.key value&lt;/code&gt; (默认是添加在 local 配置中)&lt;/p&gt;
&lt;p&gt;注意 add 后面的 section,key,value 一项都不能少，否则添加失败。比如我们执行：&lt;code&gt;git config –add man.name jim&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取一个配置项&quot;&gt;&lt;a href=&quot;#获取一个配置项&quot; class=&quot;headerlink&quot; title=&quot;获取一个配置项&quot;&gt;&lt;/a&gt;获取一个配置项&lt;/h3&gt;&lt;p&gt;有时候，我们并不需要查看所有配置的值，而是查看某个配置项的值，怎么做呢？&lt;/p&gt;
&lt;p&gt;命令参数 –get&lt;/p&gt;
&lt;p&gt;格式：&lt;code&gt;git config [–local|–global|–system] –get section.key&lt;/code&gt; (默认是获取 local 配置中内容) 我们先往 global 配置中写入一个 man .name=jim 的配置项，再使用 &lt;code&gt;git config –get man.name&lt;/code&gt; 看看得到的是什么&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.keepmovingxin.com/2016/04/27/Git-Config/&quot;&gt;http://blog.keepmovingxin.com/2016/04/27/Git-Config/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;git config命令的基本使用&lt;/p&gt;
&lt;h3 id=&quot;配置文件如何生效&quot;&gt;&lt;a href=&quot;#配置文件如何生效&quot; class=&quot;headerlink&quot; title=&quot;配置文件如何生效&quot;&gt;&lt;/a&gt;配置文件如何生效&lt;/h3&gt;&lt;p&gt;对于 git 来说，配置文件的权重是仓库&amp;gt;全局&amp;gt;系统。Git 会使用这一系列的配置文件来存储你定义的偏好，它首先会查找 /etc/gitconfig 文件（系统级），该文件含有对系统上所有用户及他们所拥有的仓库都生效的配置值。接下来 Git 会查找每个用户的 ~/.gitconfig 文件（全局级）。最后 Git 会查找由用户定义的各个库中Git目录下的配置文件 .git/config（仓库级），该文件中的值只对当前所属仓库有效。以上阐述的三 层配置从一般到特殊层层推进，如果定义的值有冲突，以后面层中定义的为准，例如：.git/config 和 /etc/gitconfig 的较量中， .git/config 取得了胜利。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://blog.keepmovingxin.com/tags/Git/"/>
    
  </entry>
  
</feed>
