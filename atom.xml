<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KeepMoving</title>
  <subtitle>KP_小新的技术Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.keepmovingxin.com/"/>
  <updated>2016-06-13T02:18:12.000Z</updated>
  <id>http://blog.keepmovingxin.com/</id>
  
  <author>
    <name>KP_小新</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lua数据结构 — lua_State（六）</title>
    <link href="http://blog.keepmovingxin.com/2016/06/10/Lua-lua_State/"/>
    <id>http://blog.keepmovingxin.com/2016/06/10/Lua-lua_State/</id>
    <published>2016-06-10T13:03:16.000Z</published>
    <updated>2016-06-13T02:18:12.000Z</updated>
    
    <content type="html">&lt;p&gt;前面各种Lua的数据类型基本都说得差不多了，剩下最后一个数据类型：&lt;strong&gt;lua_State&lt;/strong&gt;，我们可以认为是&lt;strong&gt;”脚本上下文”&lt;/strong&gt;，主要是包括当前脚本环境的运行状态信息，还会有gc相关的信息。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Lua这门语言考虑了多线程的情况，在脚本空间中能够开多个线程相关脚本上下文，而大家会共用一个全局脚本状态数据，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaState/lua-state-01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;全局数据global_state的数据结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaState/lua-state-02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;global_state主要是用于GC的数据链表，下面简要说明几个:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;stringtable strt：这个是在TString那章说到的全局字符串哈希表&lt;/li&gt;
&lt;li&gt;TValue lregistry：对应LUAREGISTRYINDEX的全局table.&lt;/li&gt;
&lt;li&gt;TString *tmname[TM_N]：元方法的名称字符串。&lt;/li&gt;
&lt;li&gt;Table *mt[NUM_TAGS]：基本类型的元表，这是Lua5.0的特性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;mt成员在作者介绍文章中说到:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaState/lua-state-03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上面代码中，我们看到a支持一个tostring的方法，a是数值类型，我们可以为数值类型添加任意的方法。Lua文章中说到一个用途，就是对于unicode和gbk的字符串的len方法能自己实现。&lt;/p&gt;
&lt;p&gt;其它成员就不一一介绍了，下面来介绍与线程相关的脚本上下文lua_State：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaState/lua-state-04.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们看到，luaState也带有CommonHeader头，在第一章中也提到了GCObject中有luaState th这个成员，由此可见lua_State也会是被回收的对象之一。&lt;/p&gt;
&lt;p&gt;考虑回一个线程中的脚本上下文，我们再来逐个分析每个成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lu_byte status：线程脚本的状态，线程可选状态如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaState/lua-state-05.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;StkId top：指向当前线程栈的栈顶指针，typedef TValue *StkId&lt;/li&gt;
&lt;li&gt;&lt;p&gt;StkId base：指向当前函数运行的相对基位置，具体可参考第四章的闭包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;globalState *lG：指向全局状态的指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;CallInfo *ci：当前线程运行的函数调用信息&lt;/li&gt;
&lt;li&gt;const Instruction *savedpc：函数调用前，记录上一个函数的pc位置&lt;/li&gt;
&lt;li&gt;StkId stack_last：栈的实际最后一个位置（栈的长度是动态增长的）&lt;/li&gt;
&lt;li&gt;StkId stack：栈底&lt;/li&gt;
&lt;li&gt;CallInfo *end_ci：指向函数调用栈的栈顶&lt;/li&gt;
&lt;li&gt;CallInfo *base_ci：指向函数调用栈的栈底&lt;/li&gt;
&lt;li&gt;int stacksize：栈的大小&lt;/li&gt;
&lt;li&gt;int size_ci：函数调用栈的大小&lt;/li&gt;
&lt;li&gt;unsigned short nCcalls：当前C函数的调用的深度&lt;/li&gt;
&lt;li&gt;unsigned short baseCcalls：用于记录每个线程状态的C函数调用深度的辅助成员&lt;/li&gt;
&lt;li&gt;lu_byte hookmask：支持哪些hook能力，有下列可选的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaState/lua-state-06.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lu_byte allowhook：是否允许hook&lt;/li&gt;
&lt;li&gt;int basehookcount：用户设置的执行指令数(LUA_MASKCOUNT下有效)&lt;/li&gt;
&lt;li&gt;int hookcount：运行时，跑了多少条指令（LUA_MASKCOUNT下有效）&lt;/li&gt;
&lt;li&gt;lua_Hook：用户注册的hook回调函数&lt;/li&gt;
&lt;li&gt;TValue l_gt：当前线程的全局的环境表&lt;/li&gt;
&lt;li&gt;TValue env：当前运行的环境表&lt;/li&gt;
&lt;li&gt;GCObject *openupval、gclist：用于gc，详细将会在GC一章细说&lt;/li&gt;
&lt;li&gt;struct lua_longjmp *errorJmp：发生错误的长跳转位置，用于记录当函数发生错误时跳转出去的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaState/lua-state-07.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本系列总结：&lt;/p&gt;
&lt;p&gt;整个系列文章回答了我们对Lua中最基本的一个问题：“一个Lua变量究竟是什么？”。由此我们深入并引申出各种知识，在脚本中我们觉得弱类型变量用起来很痛快，而其实它的内部实现其实是如此的复杂。&lt;/p&gt;
&lt;p&gt;对于实现一门脚本语言，必须实现的是解释器、虚拟机、上下文数据3大部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaState/lua-state-08.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上下文数据这一层是脚本最基础，最底层的东西，它决定了这门脚本究竟能做什么。抛开解释器和虚拟机，我们依然可以单纯地通过C接口，在C++这一层就能操作脚本的上下文数据。&lt;/p&gt;
&lt;p&gt;有空再研究一下Lua的GC，解释器等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lua数据结构&lt;/strong&gt;系列转自阿里云博客，作者是&lt;strong&gt;罗日健&lt;/strong&gt;。&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.aliyun.com/795&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.aliyun.com/795&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前面各种Lua的数据类型基本都说得差不多了，剩下最后一个数据类型：&lt;strong&gt;lua_State&lt;/strong&gt;，我们可以认为是&lt;strong&gt;”脚本上下文”&lt;/strong&gt;，主要是包括当前脚本环境的运行状态信息，还会有gc相关的信息。&lt;/p&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Lua" scheme="http://blog.keepmovingxin.com/tags/Lua/"/>
    
      <category term="Lua数据结构" scheme="http://blog.keepmovingxin.com/tags/Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Lua数据结构 — Udata（五）</title>
    <link href="http://blog.keepmovingxin.com/2016/06/09/Lua-Udata/"/>
    <id>http://blog.keepmovingxin.com/2016/06/09/Lua-Udata/</id>
    <published>2016-06-09T12:33:43.000Z</published>
    <updated>2016-06-13T02:18:12.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;Udata负责存储userdata的数据&lt;/strong&gt;，这部分其实很简单，但是为了保证系列文章的完整性，还是写一篇出来补全。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;下面是Udata的数据结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaUdata/lua-udata-01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;意义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CommonHeader：和与TValue中的GCHeader能对应起来的部分&lt;/li&gt;
&lt;li&gt;metatable：userdata的元表，和table的元表一样的&lt;/li&gt;
&lt;li&gt;env：创建userdata时，会把当前执行语句的curenv赋给userdata的env，可修改&lt;/li&gt;
&lt;li&gt;len：使用userdata的时候绑定对象申请的空间大小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和TString类似，用户绑定的C对象或数据内存紧跟在Udata后面，在luaS_newudata中（lstring.c 96 – 110）有如下代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaUdata/lua-udata-02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaUdata/lua-udata-03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;Udata元表-metable-的作用&quot;&gt;&lt;a href=&quot;#Udata元表-metable-的作用&quot; class=&quot;headerlink&quot; title=&quot;Udata元表(metable)的作用&quot;&gt;&lt;/a&gt;Udata元表(metable)的作用&lt;/h4&gt;&lt;p&gt;如果userdata没有元表，那是使用起来将会很麻烦，有元表，可以在脚本这样写：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaUdata/lua-udata-04.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从C语言层面来看，myuserdata这个变量其实只是个指针，不像table那样有子元素。但是因为有metatable，由此可以把成员\函数放到这个metatable中，在脚本中可以利用它来实现这个类似table的访问方法。&lt;/p&gt;
&lt;h4 id=&quot;Udata环境-env-的作用&quot;&gt;&lt;a href=&quot;#Udata环境-env-的作用&quot; class=&quot;headerlink&quot; title=&quot;Udata环境(env)的作用&quot;&gt;&lt;/a&gt;Udata环境(env)的作用&lt;/h4&gt;&lt;p&gt;env这个成员，默认是存储创建userdata时的环境table，而参考Lua官方的文档后，其实这个env成员在Lua中并没有使用，它的值时什么并不影响Lua的运行。&lt;/p&gt;
&lt;p&gt;这就说明这个成员目前来说是一个用户可以自由操作的table，在&lt;a href=&quot;http://lua-users.org/wiki/UserDataRefinement&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UserDataRefinement&lt;/a&gt;文章中，告诉了我们一些使用的手段。另外一篇文章&lt;a href=&quot;http://lua-users.org/lists/lua-l/2005-08/msg00709.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://lua-users.org/lists/lua-l/2005-08/msg00709.html&lt;/a&gt;也对它的使用方法提出了一些建议。&lt;/p&gt;
&lt;p&gt;我比较赞成后一篇文章的看法，对于Udata来说，metatable是一种静态的类型数据(type-common data)，而env则是实例相关的数据(instance-local data)。当然了，怎么用取决于使用者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lua数据结构&lt;/strong&gt;系列转自阿里云博客，作者是&lt;strong&gt;罗日健&lt;/strong&gt;。&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.aliyun.com/789&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.aliyun.com/789&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Udata负责存储userdata的数据&lt;/strong&gt;，这部分其实很简单，但是为了保证系列文章的完整性，还是写一篇出来补全。&lt;/p&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Lua" scheme="http://blog.keepmovingxin.com/tags/Lua/"/>
    
      <category term="Lua数据结构" scheme="http://blog.keepmovingxin.com/tags/Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Lua数据结构 — 闭包（四）</title>
    <link href="http://blog.keepmovingxin.com/2016/06/08/Lua-Closure/"/>
    <id>http://blog.keepmovingxin.com/2016/06/08/Lua-Closure/</id>
    <published>2016-06-08T15:06:17.000Z</published>
    <updated>2016-06-14T09:39:32.000Z</updated>
    
    <content type="html">&lt;p&gt;前面几篇文章已经说明了Lua里面很常用的几个数据结构，这次要分享的也是常用的数据结构之一 – &lt;strong&gt;函数的结构&lt;/strong&gt;。函数在Lua里也是一种变量，但是它却很特殊，能存储执行语句和被执行，本章主要描述Lua是怎么实现这种函数的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在脚本世界里，相信&lt;strong&gt;闭包&lt;/strong&gt;这个词大家也不陌生，闭包是由函数与其相关引用环境组成的实体。可能有点抽象，下面详细说明：&lt;/p&gt;
&lt;h3 id=&quot;一、-闭包的组成&quot;&gt;&lt;a href=&quot;#一、-闭包的组成&quot; class=&quot;headerlink&quot; title=&quot;一、 闭包的组成&quot;&gt;&lt;/a&gt;一、 闭包的组成&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;闭包主要由以下2个元素组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：上图意在表明是一段可执行代码。在Lua中可以是lua_CFunction，也可以是lua自身的虚拟机指令。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上下文环境&lt;/strong&gt;：在Lua里主要是Upvalues和env，下面会有说明Upvalues和env。 在Lua里，我们也从闭包开始，逐步看出整个结构模型，下面是Closure的数据结构：(lobject.h 291-312)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;不难发现，Lua的闭包分成2类，一类是CClosure，即&lt;strong&gt;luaC函数的闭包&lt;/strong&gt;。另一类是LClosure，是&lt;strong&gt;Lua里面原生的函数的闭包&lt;/strong&gt;。下面先讨论2者都有相同部分ClosureHeader：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CommonHeader：和与TValue中的GCHeader能对应起来的部分&lt;/li&gt;
&lt;li&gt;isC：是否CClosure&lt;/li&gt;
&lt;li&gt;nupvalues：外部对象个数&lt;/li&gt;
&lt;li&gt;gclist：用于GC销毁，超出本章话题，在GC章节将详细说明&lt;/li&gt;
&lt;li&gt;env：函数的运行环境，下面会有补充说明&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于CClosure数据结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;lua_CFunction f：函数指针，指向自定义的C函数&lt;/li&gt;
&lt;li&gt;TValue upvalue[1]：C的闭包中，用户绑定的任意数量个upvalue&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于LClosure数据结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Proto *p：Lua的函数原型，在下面会有详细说明&lt;/li&gt;
&lt;li&gt;UpVal *upvals：Lua的函数upvalue，这里的类型是UpVal，这个数据结构下面会详细说明，这里之所以不直接用TValue是因为具体实现需要一些额外数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;二、-闭包的UpVal实现&quot;&gt;&lt;a href=&quot;#二、-闭包的UpVal实现&quot; class=&quot;headerlink&quot; title=&quot;二、 闭包的UpVal实现&quot;&gt;&lt;/a&gt;二、 闭包的UpVal实现&lt;/h3&gt;&lt;p&gt;究竟什么是UpVal呢？先来看看代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;分析一下上面这段代码，最终testB的值显然是3+5+10=18。当调用testA(5)的时候，其实是在调用FuncB(5)，但是这个FuncB知道a = 3，这个是由&lt;strong&gt;FuncA调用时&lt;/strong&gt;，记录到FuncB的&lt;strong&gt;外部变量&lt;/strong&gt;，我们把a和c称为FuncB的upvalue。那么Lua是如何实现upvalue的呢？ 以上面这段代码为例，从虚拟机的角度去分析实现流程：&lt;/p&gt;
&lt;p&gt;1) FuncA(3)执行流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把3这个常量放到栈顶，执行FuncA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-04.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;虚拟机操作：（帮助理解，与真实值有差别）&lt;/p&gt;
&lt;p&gt;LOADK top 3                //把3这个常量放到栈顶&lt;br&gt;CALL  top FuncA nresults  //调用对应的FuncA函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机的&lt;strong&gt;pc已经在FuncA里面&lt;/strong&gt;了，FuncA中的&lt;strong&gt;局部变量都是放到栈中的&lt;/strong&gt;，所以第一句loacl c = 10是把10放到栈顶（这里假设先放到栈顶简化一些复杂细节问题，下同）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-05.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;虚拟机操作：&lt;/p&gt;
&lt;p&gt;LOADK top 10                //local c = 10&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遇到Function FuncB这个语句，会&lt;strong&gt;生成FuncB的闭包&lt;/strong&gt;，这个过程同时会绑定upval到这个闭包上，但这是值还在栈上，&lt;strong&gt;upval只是个指针&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-06.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面生成一个闭包之后，因为在Lua里，函数也是一个变量，上面的语句等价于&lt;strong&gt;local FuncB = function() … end&lt;/strong&gt;，所以也会生成一个临时的FuncB到栈顶。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-07.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;虚拟机操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-08.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最后return FuncB，就会把这个&lt;strong&gt;闭包关闭&lt;/strong&gt;并返回出去，同时会把所有的upval进行unlink操作，让&lt;strong&gt;upval本身保存值&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-09.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;虚拟机操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-10.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2) FuncB的执行过程&lt;/p&gt;
&lt;p&gt;到了FuncB执行的时候，参数b=5已经放到栈顶，然后执行FuncB。语句比较简单和容易理解，return a+b+c 虚拟机操作如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;到这里UpVal的创建和使用也在上面给出事例说明，总结一下UpVal的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UpVal是在函数&lt;strong&gt;闭包生成的时候（运行到function时）绑定&lt;/strong&gt;的。&lt;/li&gt;
&lt;li&gt;UpVal在&lt;strong&gt;闭包还没关闭前&lt;/strong&gt;（即函数返回前），是&lt;strong&gt;对栈的引用&lt;/strong&gt;，这样做的目的是可以在函数里修改对应的值从而修改UpVal的值，比如：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;lua code:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-12.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;闭包关闭后&lt;/strong&gt;（即函数退出后），UpVal不再是指针，而是&lt;strong&gt;值&lt;/strong&gt;。 知道UpVal的原理后，就只需要简要叙述一下UpVal的数据结构：（lobject.h 274 – 284）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-13.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CommHeader： UpVal也是可回收的类型，一般有的CommHeader也会有&lt;/li&gt;
&lt;li&gt;TValue* v：当函数打开时是指向对应stack位置值，当关闭后则指向自己&lt;/li&gt;
&lt;li&gt;TValue value：函数关闭后保存的值&lt;/li&gt;
&lt;li&gt;UpVal* prev、UpVal* next：用于GC，全局绑定的一条UpVal回收链表&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;三、-函数原型&quot;&gt;&lt;a href=&quot;#三、-函数原型&quot; class=&quot;headerlink&quot; title=&quot;三、 函数原型&quot;&gt;&lt;/a&gt;三、 函数原型&lt;/h3&gt;&lt;p&gt;之前说的，函数原型是表明一段可执行的代码或者操作指令。在绑定到Lua空间的C函数，&lt;strong&gt;函数原型就是lua_CFunction的一个函数指针&lt;/strong&gt;，指向用户绑定的C函数。下面描述一下&lt;strong&gt;Lua中的原生函数的函数原型&lt;/strong&gt;，即&lt;strong&gt;Proto数据结构&lt;/strong&gt;（lobject.h 231-253）：&lt;/p&gt;
&lt;p&gt;引用内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-14.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CommonHeader：Proto也是需要回收的对象，也会有与GCHeader对应的CommonHeader&lt;/li&gt;
&lt;li&gt;TValue* k：函数使用的常量数组，比如local d = 10，则会有一个10的数值常量&lt;/li&gt;
&lt;li&gt;Instruction *code：虚拟机指令码数组&lt;/li&gt;
&lt;li&gt;Proto **p：函数里定义的函数的函数原型，比如funcA里定义了funcB，在funcA的5. Proto中，这个指针的[0]会指向funcB的Proto&lt;/li&gt;
&lt;li&gt;int *lineinfo：主要用于调试，每个操作码所对应的行号&lt;/li&gt;
&lt;li&gt;LocVar *locvars：主要用于调试，记录每个本地变量的名称和作用范围&lt;/li&gt;
&lt;li&gt;TString **upvalues：一来用于调试，二来用于给API使用，记录所有upvalues的名称&lt;/li&gt;
&lt;li&gt;TString *source：用于调试，函数来源，如c:\t1.lua@ main&lt;/li&gt;
&lt;li&gt;sizeupvalues： upvalues名称的数组长度&lt;/li&gt;
&lt;li&gt;sizek：常量数组长度&lt;/li&gt;
&lt;li&gt;sizecode：code数组长度&lt;/li&gt;
&lt;li&gt;sizelineinfo：lineinfo数组长度&lt;/li&gt;
&lt;li&gt;sizep：p数组长度&lt;/li&gt;
&lt;li&gt;sizelocvars：locvars数组长度&lt;/li&gt;
&lt;li&gt;linedefined：函数定义起始行号，即function语句行号&lt;/li&gt;
&lt;li&gt;lastlinedefined：函数结束行号，即end语句行号&lt;/li&gt;
&lt;li&gt;gclist：用于回收&lt;/li&gt;
&lt;li&gt;nups：upvalue的个数，其实在Closure里也有nupvalues，这里我也不太清楚为什么要弄两个，nups是语法分析时会生成的，而nupvalues是动态计算的。&lt;/li&gt;
&lt;li&gt;numparams：参数个数&lt;/li&gt;
&lt;li&gt;is_vararg：是否参数是”…”（可变参数传递）&lt;/li&gt;
&lt;li&gt;maxstacksize：函数所使用的stacksize&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Proto的所有参数都是在&lt;strong&gt;语法分析和中间代码生成时获取的&lt;/strong&gt;，相当于编译出来的汇编码一样是不会变的，动态性是在Closure中体现的。&lt;/p&gt;
&lt;h3 id=&quot;四、-闭包运行环境&quot;&gt;&lt;a href=&quot;#四、-闭包运行环境&quot; class=&quot;headerlink&quot; title=&quot;四、 闭包运行环境&quot;&gt;&lt;/a&gt;四、 闭包运行环境&lt;/h3&gt;&lt;p&gt;在前面说到的闭包数据结构中，有一个成员env，是一个Table*指针，用于指向当前闭包运行环境的Table。&lt;/p&gt;
&lt;p&gt;什么是闭包运行环境呢？以下面代码举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-15.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面代码中的d = 20，其实就是在&lt;strong&gt;环境变量中取env[“d”]&lt;/strong&gt;，所以env一定是个table，而当定义了本地变量之后，之后的所有变量都对从本地变量中操作。&lt;/p&gt;
&lt;h3 id=&quot;五、-函数调用信息&quot;&gt;&lt;a href=&quot;#五、-函数调用信息&quot; class=&quot;headerlink&quot; title=&quot;五、 函数调用信息&quot;&gt;&lt;/a&gt;五、 函数调用信息&lt;/h3&gt;&lt;p&gt;函数调用相当于一个&lt;strong&gt;状态信息&lt;/strong&gt;，每次函数调用都会生成一个状态，比如递归调用，则会有一个栈去记录每个函数调用状态信息，比如说下面这段没有意义的代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-16.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么每次调用将会生成一个调用状态信息，上面代码会无限生成下去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-17.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;究竟一个CallInfo要记录哪些状态信息呢？下面来看看CallInfo的数据结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-18.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Instruction *savedpc：如果这个调用被中断，则用于记录当前闭包执行到的pc位置&lt;/li&gt;
&lt;li&gt;nresults：返回值个数，-1为任意返回个数&lt;/li&gt;
&lt;li&gt;tailcalls：用于调试，记录尾调用次数信息，关于尾调用下面会有详细解释&lt;/li&gt;
&lt;li&gt;base、func、top：如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-19.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;六、-函数调用的栈操作&quot;&gt;&lt;a href=&quot;#六、-函数调用的栈操作&quot; class=&quot;headerlink&quot; title=&quot;六、 函数调用的栈操作&quot;&gt;&lt;/a&gt;六、 函数调用的栈操作&lt;/h3&gt;&lt;p&gt;上面描述的CallInfo信息，具体整个流程是怎么走的，结合下面代码详细地叙述整个调用过程，栈是怎么变化的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-20.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;假设现在走到了funcA(30, 40)这个语句，在执行前已经存在了global这个闭包和funcA这个闭包，在调用global这个闭包时，已经生成了一个global的CallInfo。&lt;/p&gt;
&lt;p&gt;1） 函数调用的栈操作：（OP_CALL lvm.c 582-601）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;global的CallInfo信息记录，并把funcA放到栈顶&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-21.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当前虚拟机的pc指针，指向global函数原型中的CALL指令，这时global的CallInfo的savedpc就会保存当前pc。然后会把要执行的funcA的闭包放到栈顶。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数分别放到栈顶（从左到右分别进栈），生成funcA的CallInfo，并把完成对应CallInfo栈操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-22.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置虚拟机pc到funcA闭包第一条虚拟机Instruction，并继续执行虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-23.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2） 函数返回的栈操作：（OP_RETURN lvm.c 635-648）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录第一个返回值的位置到firstResult，把栈中的funcA位置设置为base和top&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-24.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把返回值根据nresult参数重新push到栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-25.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从全局CallInfo栈弹出funcA，并还原虚拟机pc到global的savedpc和栈信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-26.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继续执行虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;七、-尾调用（TAILCALL）&quot;&gt;&lt;a href=&quot;#七、-尾调用（TAILCALL）&quot; class=&quot;headerlink&quot; title=&quot;七、 尾调用（TAILCALL）&quot;&gt;&lt;/a&gt;七、 尾调用（TAILCALL）&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-27.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尾调用是一种对函数解释的优化方法&lt;/strong&gt;，对于上面代码，改造成下面代码后，则不会出现stack overflow：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-28.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面的Recursion方法不会出现stack overflow错误，也能顺利算出Recursion(20000) = 200010000。尾调用的使用方法十分简单，就是&lt;strong&gt;在return后直接调用函数，不能有其它操作&lt;/strong&gt;，这样的写法即会进入尾调用方式。&lt;/p&gt;
&lt;p&gt;那究竟lua是如何实现这种尾调用优化的呢？尾调用是在编译时分析出来的，有独立的操作码OP_TAILCALL，在虚拟机中的执行代码在lvm.c 603-634，具体原理如下：&lt;/p&gt;
&lt;p&gt;1）首先像普通调用一样，准备调用Recursion函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-29.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2）关闭Recursion1的调用状态，把Recursion2的对应栈数据下移，然后重新执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaClosure/lua-closure-30.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本质优化思想：&lt;strong&gt;先关闭前一个函数，销毁CallInfo，再调用新的CallInfo，这样就会避免全局CallInfo栈溢出&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;八、-总结&quot;&gt;&lt;a href=&quot;#八、-总结&quot; class=&quot;headerlink&quot; title=&quot;八、 总结&quot;&gt;&lt;/a&gt;八、 总结&lt;/h3&gt;&lt;p&gt;本文讨论了闭包、UpVal、函数原型、环境、栈操作、尾调用等相关知识，基本上把大部分的知识点和细节也囊括了，另外还有2大块知识：函数原型的生成和闭包GC可能迟些再分享。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lua数据结构&lt;/strong&gt;系列转自阿里云博客，作者是&lt;strong&gt;罗日健&lt;/strong&gt;。&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.aliyun.com/845&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.aliyun.com/845&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前面几篇文章已经说明了Lua里面很常用的几个数据结构，这次要分享的也是常用的数据结构之一 – &lt;strong&gt;函数的结构&lt;/strong&gt;。函数在Lua里也是一种变量，但是它却很特殊，能存储执行语句和被执行，本章主要描述Lua是怎么实现这种函数的。&lt;/p&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Lua" scheme="http://blog.keepmovingxin.com/tags/Lua/"/>
    
      <category term="Lua数据结构" scheme="http://blog.keepmovingxin.com/tags/Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Lua数据结构 — Table（三）</title>
    <link href="http://blog.keepmovingxin.com/2016/06/07/Lua-Table/"/>
    <id>http://blog.keepmovingxin.com/2016/06/07/Lua-Table/</id>
    <published>2016-06-07T14:15:39.000Z</published>
    <updated>2016-06-13T02:18:12.000Z</updated>
    
    <content type="html">&lt;p&gt;前面（一）、（二）里面其实已经把一些常用的数据类型（数值、布尔、字符串）说明了，这次要描述的是Table，Table在Lua里是一种常用的数据类型，是Lua里的精髓之一，其效率必须得到保证，而实现这种支持任意类型key和value的Table也是较为复杂的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一、-Table的设计思想&quot;&gt;&lt;a href=&quot;#一、-Table的设计思想&quot; class=&quot;headerlink&quot; title=&quot;一、 Table的设计思想&quot;&gt;&lt;/a&gt;一、 Table的设计思想&lt;/h3&gt;&lt;p&gt;1、 首先，讲一下Lua要设计的Table是怎么样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Lua就是想做这种支持任意类型的key和任意类型val的table，并且要&lt;strong&gt;高效和节约内存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2、 基本的实现（基于链表的实现）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;基于链表的实现是最简单的，其实map就可以了，这样实现是最容易的。但当遇到很多key的数组（如t[0]、t[1]、t[2]。。这种数值索引大数组）时，明明&lt;strong&gt;可以用O(1)查找的，却要O(n)去查找&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;3、 区分数字key和其它类型的key&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过改良的Table，除了有key链表之外，还有一个&lt;strong&gt;数组array专门存放key为数值的val&lt;/strong&gt;。但是这种情况下，要保证数值部分是连续且从0开始的，如果出现&lt;strong&gt;t[100000000] = 1&lt;/strong&gt;，则把这个离散的数据放到链表中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-04.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4、 利用哈希表再度优化&lt;/p&gt;
&lt;p&gt;区分了array和head之后，始终有个问题，对于链表部分的数据，查找始终是O(n)的，有没有办法优化这部分代码呢，在Lua里，利用哈希表再对这部分的Node进行查找。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-05.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;每次计算一个key的哈希值是非常快的，哈希后直接映射到hashlist的某个位置。这里已经很接近Lua Table的最终设计，但是这种方法仍然有个弊端，哈希表的大小无法较好地估计，hashlist的长度可能是一个固定的长度，无法动态扩容。&lt;/p&gt;
&lt;p&gt;5、 动态扩容的Table设计&lt;/p&gt;
&lt;p&gt;下面用例子展示一下动态扩容的Table设计&lt;/p&gt;
&lt;p&gt;1） 如下图，现在初始状态下，只有[0]被使用了，里面放着A，其它都是空：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-06.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2） 现在要&lt;strong&gt;插入一个新的元素B&lt;/strong&gt;，计算出其&lt;strong&gt;哈希值是0&lt;/strong&gt;，即是说应该插入到节点[0]。这个时候发现节点&lt;strong&gt;[0]已经被使用&lt;/strong&gt;，则会分配最后一个空闲块lastfree给这个元素B，然后node[0]的next指向node[3]，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-07.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3） 然后再&lt;strong&gt;插入一个新的nodeC&lt;/strong&gt;，计算出其哈希值是3，即是说应该插入到node[3]。这个时候发现&lt;strong&gt;node[3]已经被使用&lt;/strong&gt;，但是&lt;strong&gt;元素B的哈希值是0&lt;/strong&gt;，即本来应该插入到node[0]的，于是&lt;strong&gt;把node[3]的内容移到lastfree&lt;/strong&gt;，然后&lt;strong&gt;再在node[3]插入新的nodeC&lt;/strong&gt;，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-08.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4） 这是如果再往Table插入一个元素D，那么必然最后一个空闲块会被使用完，那么就会把nodelist的大小扩大一倍，并且重新计算每个元素的哈希值并重新插值，可能的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-09.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在最后一步的重新计算哈希值，不仅重新计算nodelist的哈希值，也会重新计算arraylist的哈希值，arraylist也是会动态扩大的，这就是lua中table的设计。&lt;/p&gt;
&lt;h3 id=&quot;二、-Lua里面的实现&quot;&gt;&lt;a href=&quot;#二、-Lua里面的实现&quot; class=&quot;headerlink&quot; title=&quot;二、 Lua里面的实现&quot;&gt;&lt;/a&gt;二、 Lua里面的实现&lt;/h3&gt;&lt;p&gt;Table相关数据结构关系图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-10.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图中有Table、Node、TKey这3个数据结构，不用急，我们先从简单的入手，看看&lt;strong&gt;Node数据结构&lt;/strong&gt;：（lobject.h 332-335）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Node就是设计思想里的key、value数据结构，包含ikey和ival两个成员，这2个成员很好理解，一个就是table的key，另一个就是这个key的value。ival是一般值的TValue类型，而ikey的TKey类型的。可以看到Node并没有next指针，&lt;strong&gt;其实它把next指针藏在TKey下面了&lt;/strong&gt;，请看TKey数据结构：（lobject.h 319-329）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-12.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到TKey其实是一个支持TValue的数据结构外，还&lt;strong&gt;多了一个next指针&lt;/strong&gt;。这个next指针就是用作&lt;strong&gt;同一个hash值下冲突时的链表指针&lt;/strong&gt;。明白了Node结构之后，接下来看看Table数据结构：（lobject.h 338-348）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-13.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个字段意义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CommonHeader：与TValue中的GCHeader能对应起来的部分&lt;/li&gt;
&lt;li&gt;flags：用于元表元方法的一些优化手段，一共有8位用于标记是否没有某个元方法&lt;/li&gt;
&lt;li&gt;lsizenode：用于表示node的长度，如下图所示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-14.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;node成员其实是上面讨论的hashlist成员，是一个固定长度大小的数组，但是lsizenode的数据类型是lu_byte，只有一个字节长，&lt;strong&gt;表示范围只有0~255&lt;/strong&gt;，一般数组大小都会很大，所以这里lsizenode用于&lt;strong&gt;表示整体长度的log2值&lt;/strong&gt;，同时也表明了，&lt;strong&gt;hashlist的长度是2的幂，每次增长都会×2&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;metatable：元表指针&lt;/li&gt;
&lt;li&gt;array：这个成员就是上面讨论的array，用于给数值的索引&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-15.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node：上面提到的hashlist成员&lt;/li&gt;
&lt;li&gt;lastfree：lastfree就是链表的最后一个空元素&lt;/li&gt;
&lt;li&gt;gclist：用于gc的，以后会有专门对GC的详细讨论&lt;/li&gt;
&lt;li&gt;sizearray：array数组的大小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;离散数值key存储的实现：&lt;/p&gt;
&lt;p&gt;在luaH_getnum（ltable.c 432-449）函数中，实现了对数值key的获取，可以看到第一个判断：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-16.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;即&lt;strong&gt;如果key在sizearray的范围内，则直接用t-&amp;gt;array成员来存储，如果不是则计算key的哈希值，然后放到node里&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;还有一种情况，就是如果对某个连续数值的table赋值：t[2] = nil，那是否从2到后面的key都会马上放到哈希表里呢？答案是否定的，不会马上做，等到做完gc后，会进行table的resize。&lt;/p&gt;
&lt;p&gt;Table的Rehash（重新计算大小）：&lt;/p&gt;
&lt;p&gt;1） &lt;strong&gt;rehash的时机&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在newkey(ltable.c 399-429)函数中可以看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-17.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;n是hashlist中的一个没使用的节点，&lt;strong&gt;当没有空余节点的时候&lt;/strong&gt;，就会调用rehash进行grow table，这个可以参考本文上面说到的动态扩容章节。&lt;/p&gt;
&lt;p&gt;2） &lt;strong&gt;rehash函数(ltable.c 333-349)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;table的这个rehash操作，代码不多，但是却十分复杂，接下来我们分解一下它所做的事：&lt;/p&gt;
&lt;p&gt;a． 计算使用数值作为key的元素数量na、计算实际为数组申请的空间大小nasize、计算hashlist的元素数量nhsize。 这里有点模糊，na和nasize的关系，下面写个例子更好说明一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-18.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;没错，nasize一定要是2的幂，computesizes(ltable.c 189-208)通过特定算法，高效地计算出实际要使用的数组大小，举下面例子说明一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-19.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;lua其实是用了一个条件来决定数组部分大小的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果数值key的元素个数大于对应个数幂大小的一半，则生成对应幂长度的数组链表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很抽象，还是拿上面的例子来说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-20.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;整体算法如上图所示，还是挺精致的，不太懂用语言描述，可以想象一个元素如果拥有tbl[10]到tbl[50]，那么这个arraylist的长度是64，中间可能会多&lt;strong&gt;生成1~10和50~64这个区间的数组&lt;/strong&gt;，但是这种方法既能动态扩容，又能提升效率，牺牲一点点还是值得的。&lt;/p&gt;
&lt;p&gt;b． resize(ltable.c 300-327)函数，根据前面计算出来的nasize和nhsize，realloc对应数组的大小，并对其中的元素重新计算哈希值和赋值。&lt;/p&gt;
&lt;p&gt;哈希的实现：&lt;/p&gt;
&lt;p&gt;主要可以看到mainposition（ltable.c 96-113）函数，用于计算哈希然后快速定位到某个Node上面，可以看到它根据不同类型有不同的哈希计算：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-21.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;元表的实现：&lt;/p&gt;
&lt;p&gt;元表是metatable，可以绑定metatable的对象在lua中只有table和userdata。这里讨论的是table中的metatable，在userdata中的其实也一样。我们看到Table数据结构里的struct Table* metatable指针，下面以index操作为例，其它的话其实也一样：&lt;/p&gt;
&lt;p&gt;看luaV_gettable(lvm.c 108-131)，我们可以看到在取一个对应key后会有判断：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTable/lua-table-22.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个判断其实就是看看返回结果如果是空，就会去&lt;strong&gt;取元表的__index对象&lt;/strong&gt;，取回来之后，下次循环就再次用这个tm来取key，如果在tm上找不到对应key，而且tm又有metatable，&lt;strong&gt;就会一直循环下去&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里fasttm做了一些优化，其实就是先用h-&amp;gt;metatable的&lt;strong&gt;flags成员去判断是否存在__index元方法&lt;/strong&gt;，如果不存在马上返回。flags只有8位，用于存储常用的元操作，可以在ltm.h 18-37看到，快速操作的常用元方法是&lt;strong&gt;index&lt;/strong&gt; 、newindex、&lt;strong&gt;gc&lt;/strong&gt;、mode、__eq，说明flags还有3位没用到。&lt;/p&gt;
&lt;p&gt;循环有个MAXTAGLOOP，这里其实限制了元表的深度不能超过100（其实超过5个深度的元表已经很恐怖了）。元操作对象的获取方法其实是luaTgettm（ltm.c 50-58）和luaTgettmbyobj（ltm.c 61-74）&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;对于Table，还有个弱表的特性，这个留待在说gc的时候再详细讨论。其实Table的实现还是挺多细节的，不过主要的思想和处理都说了（除了gc）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lua数据结构&lt;/strong&gt;系列转自阿里云博客，作者是&lt;strong&gt;罗日健&lt;/strong&gt;。&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.aliyun.com/787&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.aliyun.com/787&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前面（一）、（二）里面其实已经把一些常用的数据类型（数值、布尔、字符串）说明了，这次要描述的是Table，Table在Lua里是一种常用的数据类型，是Lua里的精髓之一，其效率必须得到保证，而实现这种支持任意类型key和value的Table也是较为复杂的。&lt;/p&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Lua" scheme="http://blog.keepmovingxin.com/tags/Lua/"/>
    
      <category term="Lua数据结构" scheme="http://blog.keepmovingxin.com/tags/Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Lua数据结构 — TString（二）</title>
    <link href="http://blog.keepmovingxin.com/2016/06/06/Lua-TString/"/>
    <id>http://blog.keepmovingxin.com/2016/06/06/Lua-TString/</id>
    <published>2016-06-06T13:13:36.000Z</published>
    <updated>2016-06-08T01:08:27.000Z</updated>
    
    <content type="html">&lt;p&gt;存储lua里面的字符串的&lt;strong&gt;TString数据结构&lt;/strong&gt;:（lobject.h 196-207）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTstring/lua-tstring-01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;其它结构中也会有&lt;strong&gt;L_Umaxalign dummy&lt;/strong&gt;这个东西，来看看L_Umaxaliagn:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTstring/lua-tstring-02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从字面意思上就是保证&lt;strong&gt;内存能与最大长度的类型进行对齐&lt;/strong&gt;，事实上也是做这件事，这里感觉lua想给各种不同设备做一种嵌入式脚本，这里要保证与最大的长度对齐能&lt;strong&gt;保证CPU运行高效不会罢工&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;tsv才是TString的主要数据结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CommonHeader：这个是和GCObject能对应起来的GCheader&lt;/li&gt;
&lt;li&gt;reserved：保留位&lt;/li&gt;
&lt;li&gt;hash：每个字符串在创建的时候都会用有冲突的哈希算法获取哈希值以提高性能&lt;/li&gt;
&lt;li&gt;len：字符串长度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;哈希是lua里一个很重要的优化手段，具体的哈希算法相关知识在文章最后会补充说明一下，字符串的hast表放在L-&amp;gt;l_G-&amp;gt;strt中，这个成员的类型是stringtable，我们再来看看&lt;strong&gt;stringtable数据结构&lt;/strong&gt;：（lstate.h 38-42）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTstring/lua-tstring-03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;stringtable结构很简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;hash：一个GCObject的表，在这里其实是个TString*数组&lt;/li&gt;
&lt;li&gt;nuse：已经有的TString个数&lt;/li&gt;
&lt;li&gt;size：hash表的大小(可动态扩充)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来看看stringtable是怎么动态调整大小的:&lt;br&gt;1、动态扩充stringtable：(lstring.c 60-70)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTstring/lua-tstring-04.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;每次newlstr的之后，都会判断nuse是否已经大于table的size，如果是的话就会重新resize这个stringtable的大小为原来的2倍。&lt;/p&gt;
&lt;p&gt;2、动态浓缩stringtable：(lgc.c 433-436)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTstring/lua-tstring-05.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在gc的时候，会判断nuse是否比size/4还小，如果是的话就重新resize这个stringtable的大小为原来的1/2倍。&lt;/p&gt;
&lt;p&gt;3、resize算法：(lstring.c 22-47)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTstring/lua-tstring-06.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;resize时，需要根据每个节点的哈希值重新计算新位置，然后放到newhash里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串在哪里？&lt;/strong&gt; 看完TString和stringtable，大家都没有发现究竟字符串放在哪里，从内存上看其实字符串直接放在了&lt;strong&gt;TString&lt;/strong&gt;后面，这样还能省掉一个成员：(lstring.c 56)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTstring/lua-tstring-07.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;性能问题：&lt;/p&gt;
&lt;p&gt;在这里说一点lua的性能问题，虽然不在这个主题的讨论范围。由上面可以知道lua的字符串是带hash值的，所以我们拿着一个字符串去做比较、查询、传递等操作都是&lt;strong&gt;非常高效&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;但是我们也可以看到&lt;strong&gt;每次创建一个新的字符串&lt;/strong&gt;都会做很多操作，所以这里&lt;strong&gt;不建议频繁做字符串创建、连接、销毁等操作&lt;/strong&gt;，最好能&lt;strong&gt;缓存&lt;/strong&gt;一下。&lt;/p&gt;
&lt;p&gt;补充：字符串的哈希算法：&lt;/p&gt;
&lt;p&gt;常用的字符串哈希函数比较如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTstring/lua-tstring-08.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中数据1为100000个字母和数字组成的随机串哈希冲突个数。数据2为100000个有意义的英文句子哈希冲突个数。数据3为数据1的哈希值与1000003(大素数)求模后存储到线性表中冲突的个数。数据4为数据1的哈希值与10000019(更大素数)求模后存储到线性表中冲突的个数。&lt;/p&gt;
&lt;p&gt;经过比较，得出以上平均得分。平均数为平方平均数。可以发现，BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的。APHash也是较为优秀的算法。DJBHash,JSHash,RSHash与SDBMHash各有千秋。PJWHash与ELFHash效果最差，但得分相似，其算法本质是相似的。&lt;/p&gt;
&lt;p&gt;在Lua中使用到的是JSHash算法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTstring/lua-tstring-09.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体JS Hash算法的冲突性解决和性能上面，我也不懂，具体要找paper看看，但是从数据比较上看，JSHash是属于较好的算法，可也有比JSHash算法更好的字符串哈希算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lua数据结构&lt;/strong&gt;系列转自阿里云博客，作者是&lt;strong&gt;罗日健&lt;/strong&gt;。&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.aliyun.com/768&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.aliyun.com/768&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;存储lua里面的字符串的&lt;strong&gt;TString数据结构&lt;/strong&gt;:（lobject.h 196-207）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTstring/lua-tstring-01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Lua" scheme="http://blog.keepmovingxin.com/tags/Lua/"/>
    
      <category term="Lua数据结构" scheme="http://blog.keepmovingxin.com/tags/Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Lua数据结构 — TValue（一）</title>
    <link href="http://blog.keepmovingxin.com/2016/06/05/Lua-TValue/"/>
    <id>http://blog.keepmovingxin.com/2016/06/05/Lua-TValue/</id>
    <published>2016-06-05T14:06:28.000Z</published>
    <updated>2016-06-13T04:01:58.000Z</updated>
    
    <content type="html">&lt;p&gt;数据结构的设计，在一定程度上奠定了整个系统的设计，所以决定写一个对Lua主要数据结构的分析文章，本来打算写一篇就好了，但是每个数据类型其实都有点复杂，一篇的话篇幅太长，所以就拆开几篇来写了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;为什么是从TValue说起，&lt;strong&gt;TValue是实现Lua弱数据类型的主要数据结构&lt;/strong&gt;，不但在脚本中的值使用了TValue，连Lua的实现中，很多数据结构也依赖于TValue，TValue一定程度上贯穿了整个Lua。先说一下Lua里面的&lt;strong&gt;数据类型&lt;/strong&gt;:（lua.h :69）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTValue/lua-tvalue-01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上面的定义中可以看到，&lt;strong&gt;Lua的值类型有9种&lt;/strong&gt;，其中LUA_TNONE是用于判断这个变量是否等于为空使用的，这个是Lua内部使用的，后面再详细说明。现在来看Lua里面的&lt;strong&gt;TValue数据结构&lt;/strong&gt;:（lobject.h 71-75）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTValue/lua-tvalue-02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Lua里面，一个变量使用TValue这个类型来存储的，int tt就是上面宏的类型值（4个字节），而Value则是一个union（8个字节）。在这个union中，其实分工也十分明确:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTValue/lua-tvalue-03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Value中，void* p、lua_Number n、int b都是不用回收的值类型，而GCObject* gc则都是需要回收的对象，下面是&lt;strong&gt;GCObject数据结构&lt;/strong&gt;:（lstate.h 133-145）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTValue/lua-tvalue-04.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;GCObject也是一个union，存储了一个GCheader，这个GCHeader主要用于&lt;strong&gt;GC回收机制&lt;/strong&gt;使用，GC回收机制超出了这次讨论话题，暂时先忽略。真正存储值的结构是TString、Udata、Closure等等，每个存储数据的结构都会有GCheader，接下来几篇文章将会开始逐个数据类型进行解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/luaTValue/lua-tvalue-05.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lua数据结构&lt;/strong&gt;系列转自阿里云博客，作者是&lt;strong&gt;罗日健&lt;/strong&gt;。&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.aliyun.com/761&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.aliyun.com/761&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构的设计，在一定程度上奠定了整个系统的设计，所以决定写一个对Lua主要数据结构的分析文章，本来打算写一篇就好了，但是每个数据类型其实都有点复杂，一篇的话篇幅太长，所以就拆开几篇来写了。&lt;/p&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Lua" scheme="http://blog.keepmovingxin.com/tags/Lua/"/>
    
      <category term="Lua数据结构" scheme="http://blog.keepmovingxin.com/tags/Lua%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Lua 全局变量的那些事儿</title>
    <link href="http://blog.keepmovingxin.com/2016/05/27/Lua-global/"/>
    <id>http://blog.keepmovingxin.com/2016/05/27/Lua-global/</id>
    <published>2016-05-27T14:30:12.000Z</published>
    <updated>2016-06-01T03:24:48.000Z</updated>
    
    <content type="html">&lt;p&gt;最近项目查了一个问题，最后发现和&lt;code&gt;_G[moduleName]&lt;/code&gt;这个置为&lt;code&gt;nil&lt;/code&gt;有关系，找了点资料看看里面的坑还是蛮深的，所以记录一下。&lt;/p&gt;
&lt;h3 id=&quot;全局环境表-G&quot;&gt;&lt;a href=&quot;#全局环境表-G&quot; class=&quot;headerlink&quot; title=&quot;全局环境表 _G&quot;&gt;&lt;/a&gt;全局环境表 &lt;code&gt;_G&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Lua把所有的全局变量都放在一个称为全局环境的表_G中，这个表只是个普通的表。注意&lt;code&gt;_G._G == _G&lt;/code&gt;。&lt;br&gt;由于&lt;code&gt;_G&lt;/code&gt;是一个普通的表，所以提供了以动态名称访问全局变量的形式，这又是Lua的一种对元编程的支持。&lt;/p&gt;
&lt;p&gt;如&lt;code&gt;_G[varname] = value&lt;/code&gt;，更一般的问题是允许使用动态字段名，如_G[“read.io”]默认是不会取出read模块的io字段的，但是使用下面这样实现：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function getfield(f)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local v = _G&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for w in string.gmatch(f, &amp;quot;[%w_]+&amp;quot;) do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        v = v[w]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function setfield(t, v)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local t = _G&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for w, d in string.gmatch(f, &amp;quot;([%w_]+)(%.?)&amp;quot;) do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if d == &amp;quot;.&amp;quot; then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            t[w] = t[w] or &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            t = t[w]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            t[w] = v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;全局变量声明&quot;&gt;&lt;a href=&quot;#全局变量声明&quot; class=&quot;headerlink&quot; title=&quot;全局变量声明&quot;&gt;&lt;/a&gt;全局变量声明&lt;/h3&gt;&lt;p&gt;全局变量不需要声明，虽然这对一些小程序来说很方便，但程序很大时，一个简单的拼写错误可能引起bug并且很难发现。然而，如果我们喜欢，我们可以改变这种行为。因为Lua所有的全局变量都保存在一个普通的表中，我们可以使用metatables来改变访问全局变量的行为。&lt;br&gt;第一个方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;setmetatable(_G, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __newindex = function (_, n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       error(&amp;quot;attempt to write to undeclared variable &amp;quot;..n, 2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    end,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __index = function (_, n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       error(&amp;quot;attempt to read undeclared variable &amp;quot;..n, 2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    end,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样一来，任何企图访问一个不存在的全局变量的操作都会引起错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; a = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stdin:1: attempt to write to undeclared variable a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是我们如何声明一个新的变量呢？使用rawset，可以绕过metamethod：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function declare (name, initval)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rawset(_G, name, initval or false)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;or 带有 false 是为了保证新的全局变量不会为 nil。注意：你应该在安装访问控制以前（before installing the access control）定义这个函数，否则将得到错误信息：毕竟你是在企图创建一个新的全局声明。只要刚才那个函数在正确的地方，你就可以控制你的全局变量了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; a = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stdin:1: attempt to write to undeclared variable a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; declare &amp;quot;a&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; a = 1       -- OK&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是现在，为了测试一个变量是否存在，我们不能简单的比较他是否为nil。如果他是nil访问将抛出错误。所以，我们使用rawget绕过metamethod：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if rawget(_G, var) == nil then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -- &amp;apos;var&amp;apos; is undeclared&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;改变控制允许全局变量可以为nil也不难，所有我们需要的是创建一个辅助表用来保存所有已经声明的变量的名字。不管什么时候metamethod被调用的时候，他会检查这张辅助表看变量是否已经存在。代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local declaredNames = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function declare (name, initval)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rawset(_G, name, initval)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    declaredNames[name] = true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setmetatable(_G, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __newindex = function (t, n, v)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if not declaredNames[n] then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       error(&amp;quot;attempt to write to undeclared var. &amp;quot;..n, 2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       rawset(t, n, v)   -- do the actual set&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __index = function (_, n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if not declaredNames[n] then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       error(&amp;quot;attempt to read undeclared var. &amp;quot;..n, 2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       return nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两种实现方式，代价都很小可以忽略不计的。第一种解决方法：&lt;code&gt;metamethods&lt;/code&gt;在平常操作中不会被调用。第二种解决方法：他们可能被调用，不过当且仅当访问一个值为nil的变量时。&lt;/p&gt;
&lt;h3 id=&quot;非全局变量-ENV&quot;&gt;&lt;a href=&quot;#非全局变量-ENV&quot; class=&quot;headerlink&quot; title=&quot;非全局变量 _ENV&quot;&gt;&lt;/a&gt;非全局变量 &lt;code&gt;_ENV&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Lua中其实没有真正的全局变量，一个chunk会编译类似下面的代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local _ENV = the global environment  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function  (...)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _ENV.var1 = _ENV.var2 + 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;也就是说Lua5.2中，会这样处理全局变量： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在一个名为&lt;code&gt;_ENV&lt;/code&gt;的&lt;code&gt;upvalue&lt;/code&gt;作用域中编译&lt;code&gt;chunk&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;将所有的自由名称转换成&lt;code&gt;_ENV.var&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;load或loadfile函数用全局环境初始化&lt;code&gt;_ENV&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也可以通过显式使用&lt;code&gt;_EVN&lt;/code&gt;来访问被遮蔽的全局变量：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = 13  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local a = 12  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a)      --&amp;gt; 12  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(_ENV.a) --&amp;gt; 13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;_ENV&lt;/code&gt;最大的作用就是修改代码片的环境。如使用_ENV可以限制代码对全局变量的访问：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local print, sin = print, math.sin  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_ENV = nil  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(1) --&amp;gt; 1  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(math.cos(13)) -- error&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;想要修改环境的同时还能访问全局变量，通常说方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = 1  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local newgt = ()  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setmetatable(newgt, &amp;#123;__index = _G&amp;#125;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_ENV = newgt  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a)    --&amp;gt; 1  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = 10  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a)    --&amp;gt; 10  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(_G.a) --&amp;gt; 1  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_G.a = 20  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(_G.a) --&amp;gt; 20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们还可以为函数定义私有执行环境：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function factory (_ENV)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   return function ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(factory&amp;#123;a = 6&amp;#125;()) -&amp;gt; 6  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(factory&amp;#123;a = 7&amp;#125;()) -&amp;gt; 7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;load函数有一个可选参数，可以由用户指定_ENV，这样就可以限制外部的运行环境。如果一个chunk加载后要以不同的环境多次运行，这时就不能通过参数在加载时指定环境了，这时可以每次都使用debug.setupvalue函数指定运行环境，另外，为了避免使用debug库，还可以像下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;f = loadwithprefix(&amp;quot;local _ENV = ...&amp;quot;, io.lines(filename, &amp;quot;*L&amp;quot;)) -- 因为Lua会把chunk编译成可参数函数，所以前面的这一句相当于把chunk的第一个参数赋值给_ENV  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;env = &amp;#123;&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f(env)  -- 使用env作为环境调用chunk&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;全局变量与环境&quot;&gt;&lt;a href=&quot;#全局变量与环境&quot; class=&quot;headerlink&quot; title=&quot;全局变量与环境&quot;&gt;&lt;/a&gt;全局变量与环境&lt;/h3&gt;&lt;p&gt;lua中真正存储全局变量的地方不是在_G里面，而是在&lt;code&gt;setfenv（i,table）&lt;/code&gt;的table中，所有当前的全局变量都在这里面找，只不过在程序开始时lua会默认先设置一个变量&lt;br&gt;&lt;code&gt;_G&lt;/code&gt;=这个里面的table而已。所以在新设置环境后，如果还想找到之前的全局变量，通常需要附加上为新的table设置元表&lt;code&gt;{_index=_G}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面的几个例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(_G.a)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;正常情况，输出1,1&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setfenv(1,&amp;#123;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(_G.a)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这时会出错说找不到&lt;code&gt;print&lt;/code&gt;，因为当前的全局变量表示空的，啥也找不到的&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setfenv(1,&amp;#123;_G=_G&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_G.print(_G.a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这时&lt;code&gt;_G.print(_G.a)&lt;/code&gt;可以正常吗，因为可以在新的table中找到一个叫&lt;code&gt;_G&lt;/code&gt;的表，这个&lt;code&gt;_G&lt;/code&gt;有之前的奈尔全局变量，但是下面的&lt;code&gt;print(a)&lt;/code&gt;则找不到&lt;code&gt;print&lt;/code&gt;，因为当前的&lt;code&gt;table{_G=_G}&lt;/code&gt;没有一个叫&lt;code&gt;print&lt;/code&gt;的东西&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local mt=&amp;#123;__index=_G&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local t=&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setmetatable(t,mt)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setfenv(1,t)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(_G.a)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是正确输出，因为新的全局表采用之前的表做找不到时的索引，原先的表里面存在&lt;code&gt;print&lt;/code&gt; 、&lt;code&gt;_G&lt;/code&gt;、 &lt;code&gt;a&lt;/code&gt;这些东西&lt;br&gt;&lt;code&gt;setfenv&lt;/code&gt;的第一个参数可以是当前的堆栈层次，如1代表当前代码块，2表调用当前的上一层，也可以是具体的那个函数名，表示在那个函数里。&lt;br&gt;每个新创建的函数都将继承创建它的那个函数的全局环境&lt;/p&gt;
&lt;h4 id=&quot;require&quot;&gt;&lt;a href=&quot;#require&quot; class=&quot;headerlink&quot; title=&quot;require&quot;&gt;&lt;/a&gt;require&lt;/h4&gt;&lt;p&gt;&lt;code&gt;require&lt;/code&gt;的意义就是导入一堆可用的名称，这些名称（非local的）都包含在一个table中，这个table再被包含在当前的全局表（“通常的那个&lt;code&gt;_G&lt;/code&gt;”）中，这样访问一个模块中的变量就可以使用&lt;code&gt;_G.table.**&lt;/code&gt;了，（刚开始学习lua时还以为模块里的名称在导入后直接就是在&lt;code&gt;_G&lt;/code&gt;中的）&lt;br&gt;&lt;code&gt;a=require(&amp;quot;&amp;quot;)&lt;/code&gt;的a取决于这个导入的文件的返回值，没有返回值时&lt;code&gt;true&lt;/code&gt;，所以在标准的情况下模块的结尾应该&lt;code&gt;return&lt;/code&gt;这个模块的名字，这样a就是这个模块的table了（当然不这样做也ok，只是a就不是这个模块名了）&lt;/p&gt;
&lt;h3 id=&quot;理解-ENV-和-G&quot;&gt;&lt;a href=&quot;#理解-ENV-和-G&quot; class=&quot;headerlink&quot; title=&quot;理解 _ENV 和 _G&quot;&gt;&lt;/a&gt;理解 &lt;code&gt;_ENV&lt;/code&gt; 和 &lt;code&gt;_G&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;5.1之前, 全局变量存储在&lt;code&gt;_G&lt;/code&gt;这个table中, 这样的操作:&lt;br&gt;&lt;code&gt;a = 1&lt;/code&gt;&lt;br&gt;相当于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_G[&amp;apos;a&amp;apos;] = 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但在5.2之后， 引入了&lt;code&gt;_ENV&lt;/code&gt;叫做环境，与&lt;code&gt;_G&lt;/code&gt;全局变量表产生了一些混淆，需要从原理上做一个理解。&lt;br&gt;在5.2中，&lt;br&gt;操作&lt;code&gt;a = 1&lt;/code&gt;&lt;br&gt;相当于&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_ENV[&amp;apos;a&amp;apos;] = 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是一个最基础的认知改变，其次要格外注意&lt;code&gt;_ENV&lt;/code&gt;不是全局变量，而是一个&lt;code&gt;upvalue&lt;/code&gt;(非局部变量)。&lt;/p&gt;
&lt;p&gt;其次，&lt;code&gt;_ENV[&amp;#39;_G&amp;#39;]&lt;/code&gt;指向了&lt;code&gt;_ENV&lt;/code&gt;自身，这一目的是为了兼容5.1之前的版本，因为之前你也许会用到：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_G[&amp;#39;a&amp;#39;] = 2&lt;/code&gt; ， 在5.2中， 这相当于&lt;code&gt;_ENV[&amp;#39;_G&amp;#39;][&amp;#39;a&amp;#39;]&lt;/code&gt;，为了避免5.1之前的老代码在5.2中运行错误，所以5.2设置了&lt;code&gt;_ENV[&amp;#39;_G&amp;#39;]=_ENV&lt;/code&gt;来兼容这个问题。然而你不要忘记&lt;code&gt;_ENV[&amp;#39;_G&amp;#39;]=_ENV&lt;/code&gt;，所以一切都顺理成章了。&lt;/p&gt;
&lt;p&gt;在5.1中，我们可以为一段代码块（或者函数）设置环境，使用函数&lt;code&gt;setfuncs&lt;/code&gt;，这样会导致那一段代码/函数访问全局变量的时候使用了&lt;code&gt;setfuncs&lt;/code&gt;指定的table，而不是全局的&lt;code&gt;_G&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在5.2中，&lt;code&gt;setfuncs&lt;/code&gt;遭到了废弃，因为引入了&lt;code&gt;_ENV&lt;/code&gt;。 通过在函数定义前覆盖&lt;code&gt;_ENV&lt;/code&gt;变量即可为函数定义设置一个全新的环境，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function get_echo()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local _ENV=&amp;#123;print=print, a = 2&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return function echo()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;get_echo()()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;会打印2，而不是3，因为&lt;code&gt;echo&lt;/code&gt;函数的环境被修改为&lt;code&gt;{print=print, a=2}&lt;/code&gt;，而&lt;code&gt;print(a)&lt;/code&gt;相当于访问&lt;code&gt;_ENV[&amp;#39;a&amp;#39;]&lt;/code&gt;（先忘掉那为了兼容而存在的&lt;code&gt;_G&lt;/code&gt;）。&lt;br&gt;这就是&lt;code&gt;_ENV&lt;/code&gt;的基本用法了。&lt;br&gt;另外，不得不提到lua的C支持中关于全局变量与环境的细节，只能简单描述，你必须自己试试才能记得清楚。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lua_setglobal/lua_getglobal&lt;/code&gt;都是操作&lt;code&gt;lua_State&lt;/code&gt;注册表中&lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt;伪索引指向的全局变量表，与lua中访问&lt;code&gt;_ENV[&amp;#39;a&amp;#39;]&lt;/code&gt;或者&lt;code&gt;a&lt;/code&gt;是不同的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lua_load&lt;/code&gt;加载lua代码后会返回一个函数，默认会给这个函数设置一个&lt;code&gt;upvalue&lt;/code&gt;就叫&lt;code&gt;_ENV&lt;/code&gt;，起值是&lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt;的全局变量表，你可以&lt;code&gt;lua_setupvalue&lt;/code&gt;设置这个函数的&lt;code&gt;upvalue&lt;/code&gt;，即下标1的&lt;code&gt;upvalue&lt;/code&gt;，因为这个位置是这个函数的&lt;code&gt;_ENV&lt;/code&gt;表存放位置（你可以通过&lt;code&gt;lua_setupvalue&lt;/code&gt;的返回值印证这一点）&lt;/p&gt;
&lt;p&gt;这里巧妙的是，&lt;code&gt;lua_State&lt;/code&gt;会在创建时保证&lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt;的全局变量表中包含一个指向自己的&lt;code&gt;_G&lt;/code&gt;元素，这样就保证了在不调用&lt;code&gt;lua_setupvalue&lt;/code&gt;的情况下该返回函数的&lt;code&gt;_ENV[&amp;#39;_G&amp;#39;]&lt;/code&gt;是指向自己的，即&lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt;这个全局表。（其实你的lua解释器就是简单的&lt;code&gt;lua_load&lt;/code&gt;后&lt;code&gt;pcall&lt;/code&gt;的，对于一个刚启动&lt;code&gt;lua_State&lt;/code&gt;来说是没有&lt;code&gt;_ENV&lt;/code&gt;的，是lua解释器load你的代码时自动给带上的&lt;code&gt;_ENV&lt;/code&gt;，其值是&lt;code&gt;lua_state&lt;/code&gt;的&lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt;全局表。）&lt;/p&gt;
&lt;p&gt;一些有意思的东西是需要你自己摸索的，lua语言自身就很简练，并且所有东西都不是什么神秘的事情，可以通过读源码或者试验摸索得到。&lt;/p&gt;
&lt;p&gt;最后，提一下，&lt;code&gt;lua_state&lt;/code&gt;启动后在注册表里&lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt;下标存放的全局表一定有一个元素是指向自己的，即&lt;code&gt;_G&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.lua.org/manual/5.1/manual.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.lua.org/manual/5.1/manual.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.shouce.ren/api/lua/5/_88.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.shouce.ren/api/lua/5/_88.htm&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/leonwei/article/details/7739930&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/leonwei/article/details/7739930&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.aforget.net/shen-ru-luahe-czhi-si/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.aforget.net/shen-ru-luahe-czhi-si/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目查了一个问题，最后发现和&lt;code&gt;_G[moduleName]&lt;/code&gt;这个置为&lt;code&gt;nil&lt;/code&gt;有关系，找了点资料看看里面的坑还是蛮深的，所以记录一下。&lt;/p&gt;
&lt;h3 id=&quot;全局环境表-G&quot;&gt;&lt;a href=&quot;#全局环境表-G&quot; class=&quot;headerlink&quot; title=&quot;全局环境表 _G&quot;&gt;&lt;/a&gt;全局环境表 &lt;code&gt;_G&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Lua把所有的全局变量都放在一个称为全局环境的表_G中，这个表只是个普通的表。注意&lt;code&gt;_G._G == _G&lt;/code&gt;。&lt;br&gt;由于&lt;code&gt;_G&lt;/code&gt;是一个普通的表，所以提供了以动态名称访问全局变量的形式，这又是Lua的一种对元编程的支持。&lt;/p&gt;
&lt;p&gt;如&lt;code&gt;_G[varname] = value&lt;/code&gt;，更一般的问题是允许使用动态字段名，如_G[“read.io”]默认是不会取出read模块的io字段的，但是使用下面这样实现：&lt;/p&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Lua" scheme="http://blog.keepmovingxin.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>了解Lua metatable 元表</title>
    <link href="http://blog.keepmovingxin.com/2016/05/25/Lua-metable/"/>
    <id>http://blog.keepmovingxin.com/2016/05/25/Lua-metable/</id>
    <published>2016-05-25T07:30:05.000Z</published>
    <updated>2016-06-01T03:25:05.000Z</updated>
    
    <content type="html">&lt;p&gt;参考lua手册，&lt;code&gt;metatable&lt;/code&gt;是被译作元表，Lua 中的每个值都可以用一个 &lt;code&gt;metatable&lt;/code&gt;。这个 &lt;code&gt;metatable&lt;/code&gt; 就是一个原始的 Lua table，它用来定义原始值在特定操作下的行为。&lt;/p&gt;
&lt;h3 id=&quot;metatable&quot;&gt;&lt;a href=&quot;#metatable&quot; class=&quot;headerlink&quot; title=&quot;metatable&quot;&gt;&lt;/a&gt;&lt;code&gt;metatable&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;一个 &lt;code&gt;metatable&lt;/code&gt; 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为，metatable 中还可以定义一个函数，让 &lt;code&gt;userdata&lt;/code&gt; 作垃圾收集时调用它。对于这些操作，Lua 都将其关联上一个被称作事件的指定健。当 Lua 需要对一个值发起这些操作中的一个时，它会去检查值中 metatable 中是否有对应事件。如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;函数（元方法）&quot;&gt;&lt;a href=&quot;#函数（元方法）&quot; class=&quot;headerlink&quot; title=&quot;函数（元方法）&quot;&gt;&lt;/a&gt;函数（元方法）&lt;/h3&gt;&lt;p&gt;metatable通过其包含的函数来给所挂接的table定义一些特殊的操作，包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__add&lt;/code&gt;: 定义所挂接table的加法操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__mul&lt;/code&gt;: 定义乘法操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__div&lt;/code&gt;: 定义除法操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__sub&lt;/code&gt;: 定义减法操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__unm&lt;/code&gt;: 定义负操作, 即: -table的含义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__tostring&lt;/code&gt;: 定义当table作为tostring()函式之参数被呼叫时的行为(例如: &lt;code&gt;print(table)&lt;/code&gt;时将呼叫&lt;code&gt;tostring(table)&lt;/code&gt;作为输出结果)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__concat&lt;/code&gt;: 定义连接操作(“..”运算符)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__index&lt;/code&gt;: 定义当table中不存在的key值被试图获取时的行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__newindex&lt;/code&gt;: 定义在table中产生新key值时的行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;index-metamethod&quot;&gt;&lt;a href=&quot;#index-metamethod&quot; class=&quot;headerlink&quot; title=&quot;__index metamethod&quot;&gt;&lt;/a&gt;&lt;code&gt;__index&lt;/code&gt; metamethod&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在我们访问 table 的不存在的域时，Lua 会尝试调用 &lt;code&gt;__index&lt;/code&gt; metamethod。&lt;code&gt;__index&lt;/code&gt; metamethod 接受两个参数 table 和 key，代码如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local mt = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mt.__index = function(table, key)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;apos;table -- &amp;apos; .. tostring(table))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;apos;key -- &amp;apos; .. key)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local t = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setmetatable(t, mt)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local v = t.a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;__index&lt;/code&gt; 域也可以是一个 table，那么 Lua 会尝试在 &lt;code&gt;__index&lt;/code&gt; table 中访问对应的域，代码如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local mt = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mt.__index = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a = &amp;apos;Hello World&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local t = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setmetatable(t, mt)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(t.a) --&amp;gt; Hello World&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们通过 &lt;code&gt;__index&lt;/code&gt; 可以容易的实现单继承（类似于 JavaScrpit 通过 prototype 实现单继承），如果 &lt;code&gt;__index&lt;/code&gt; 是一个函数，则可以实现更加复杂的功能：多重继承、caching 等。我们可以通过 &lt;code&gt;rawget(t, i)&lt;/code&gt; 来访问 &lt;code&gt;table t&lt;/code&gt; 的域 &lt;code&gt;i&lt;/code&gt;，而不会访问 &lt;code&gt;__index&lt;/code&gt; metamethod，注意的是，不要太指望通过 &lt;code&gt;rawget&lt;/code&gt; 来提高对 &lt;code&gt;table&lt;/code&gt; 的访问速度（Lua 中函数的调用开销远远大于对表的访问的开销）&lt;/p&gt;
&lt;h4 id=&quot;newindex-metamethod&quot;&gt;&lt;a href=&quot;#newindex-metamethod&quot; class=&quot;headerlink&quot; title=&quot;__newindex metamethod&quot;&gt;&lt;/a&gt;&lt;code&gt;__newindex&lt;/code&gt; metamethod&lt;/h4&gt;&lt;p&gt;如果对 table 的一个不存在的域赋值时，Lua 将检查 &lt;code&gt;__newindex&lt;/code&gt; metamethod：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果 &lt;code&gt;__newindex&lt;/code&gt; 为函数，Lua 将调用函数而不是进行赋值&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;__newindex&lt;/code&gt; 为一个 table，Lua 将对此 table 进行赋值&lt;br&gt;如果 &lt;code&gt;__newindex&lt;/code&gt; 为一个函数，它可以接受三个参数 table key value。如果希望忽略 &lt;code&gt;__newindex&lt;/code&gt; 方法对 table 的域进行赋值，可以调用 &lt;code&gt;rawset(t, k, v)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结合 &lt;code&gt;__index&lt;/code&gt; 和 &lt;code&gt;__newindex&lt;/code&gt; 可以实现很多功能，例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OOP&lt;/li&gt;
&lt;li&gt;Read-only table&lt;/li&gt;
&lt;li&gt;Tables with default values&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Read-only table 代码如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function readOnly(t)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local proxy = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local mt = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __index = t,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __newindex = function(t, k, v)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            error(&amp;apos;attempt to update a read-only table&amp;apos;, 2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setmetatable(proxy, mt)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return proxy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;days = readOnly&amp;#123;&amp;apos;Sun&amp;apos;, &amp;apos;Mon&amp;apos;, &amp;apos;Tues&amp;apos;, &amp;apos;Wed&amp;apos;, &amp;apos;Thur&amp;apos;, &amp;apos;Fri&amp;apos;, &amp;apos;Sat&amp;apos;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(days[1])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;days[2] = &amp;apos;Noday&amp;apos; --&amp;gt; stdin:1: attempt to update a read-only table&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有时候，我们需要为 table 设定一个唯一的 key，那么可以使用这样的技巧，代码如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local key = &amp;#123;&amp;#125; -- unique key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local t = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;t[key] = value&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;参考lua手册，&lt;code&gt;metatable&lt;/code&gt;是被译作元表，Lua 中的每个值都可以用一个 &lt;code&gt;metatable&lt;/code&gt;。这个 &lt;code&gt;metatable&lt;/code&gt; 就是一个原始的 Lua table，它用来定义原始值在特定操作下的行为。&lt;/p&gt;
&lt;h3 id=&quot;metatable&quot;&gt;&lt;a href=&quot;#metatable&quot; class=&quot;headerlink&quot; title=&quot;metatable&quot;&gt;&lt;/a&gt;&lt;code&gt;metatable&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;一个 &lt;code&gt;metatable&lt;/code&gt; 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为，metatable 中还可以定义一个函数，让 &lt;code&gt;userdata&lt;/code&gt; 作垃圾收集时调用它。对于这些操作，Lua 都将其关联上一个被称作事件的指定健。当 Lua 需要对一个值发起这些操作中的一个时，它会去检查值中 metatable 中是否有对应事件。如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。&lt;/p&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Lua" scheme="http://blog.keepmovingxin.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令用法：程序员的场景</title>
    <link href="http://blog.keepmovingxin.com/2016/05/20/Git-Workflow/"/>
    <id>http://blog.keepmovingxin.com/2016/05/20/Git-Workflow/</id>
    <published>2016-05-20T14:41:28.000Z</published>
    <updated>2016-06-06T02:18:06.000Z</updated>
    
    <content type="html">&lt;p&gt;Git 相比 Subversion，无论概念上还是使用上，复杂度其实是高出一个等级的。为什么这么说？分别看下 &lt;code&gt;git help -a&lt;/code&gt; 和 &lt;code&gt;svn help&lt;/code&gt; 命令清单的对比，单按这个来看，就如果要掌握所有命令的用法，Git 的学习曲线绝对是比 Subversion 高的。尽管如此，但还是有越来越多项目开始用 Git 来做源码管理了。&lt;/p&gt;
&lt;p&gt;实际中，我们用到的的 Git 命令还是很有限的，可能也就 &lt;code&gt;git help&lt;/code&gt; 中那些而已。下面就类似 &lt;a href=&quot;http://blog.keepmovingxin.com/2016/05/20/SVN-Workflow/&quot;&gt;SVN命令用法：程序员的场景&lt;/a&gt; 一样，结合实际场景说下 Git 的常用命令用法。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;“新人报道”&quot;&gt;&lt;a href=&quot;#“新人报道”&quot; class=&quot;headerlink&quot; title=&quot;“新人报道”&quot;&gt;&lt;/a&gt;“新人报道”&lt;/h3&gt;&lt;p&gt;你刚入职一家公司，或新加入某个团队，立马参与到一个项目中，那么就得获取项目代码，开始你的项目生涯。这个时候一般你需要克隆一份项目代码，下面都以 GitHub 上的项目地址为例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone git@github.com:akun/pm.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;之后就进入项目目录，运行项目中的构建脚本，然后就可以熟悉代码，展开具体工作了。&lt;br&gt;当然，有的时候，有一个新项目是由你发起的，你要将初始化的项目工程放到 Git 版本仓库中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir pm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd pm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ touch README.md&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add README.md&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Git 是分布式的版本控制系统，所以刚才的操作，算是已经在你本地版本控制起来了，为了推送本地仓库到远程仓库，就还得执行：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git remote add origin git@github.com:akun/pm.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push -u origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一般这个时候都会设置下 &lt;code&gt;~/.gitconfig&lt;/code&gt; 或 &lt;code&gt;.git/config&lt;/code&gt; 中的配置，最基本的就是用户名和邮箱&lt;br&gt;确认当前的 Git 配置信息：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --list&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置用户名和邮箱：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config user.name akun&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config user.email admin@example.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;刚才的命令只是对 .git/config 生效，如果想全局生效，也就是 ~/.gitconfig，就得加上 –global 参数，比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.name akun&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.email admin@example.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;日常工作&quot;&gt;&lt;a href=&quot;#日常工作&quot; class=&quot;headerlink&quot; title=&quot;日常工作&quot;&gt;&lt;/a&gt;日常工作&lt;/h3&gt;&lt;p&gt;当你已经逐渐融入了一个项目，可能一天的工作场景或完成某个任务的工作周期是这样的：&lt;/p&gt;
&lt;h4 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h4&gt;&lt;p&gt;无论是清早或下午或晚上，开始了你的一天工作，你首先会更新你的工作目录：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cd ~/projects/pm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout develop  # 我想在 develop 分支上开始一天的工作&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;更新方式一：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all  # 从远程仓库获取所有分支的代码变更&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;更新方式二：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rebase  # 默认就衍合 develop 分支的代码了&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;更新方式三，可以认为是 fetch 和 merge 的合集：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull  # 懒得理解 fetch 和 merge 就直接 pull 吧&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样你就可以在最新的项目代码基础上工作了。&lt;br&gt;注解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git pull –rebase 相当于是前面的方式二的合集&lt;/li&gt;
&lt;li&gt;有关 “fetch + merge” VS “fetch + rebase” VS pull 的差异后续单独写一篇文章说明&lt;/li&gt;
&lt;li&gt;这里说的三种方式，可能每个人或团队都有自己的习惯吧&lt;/li&gt;
&lt;li&gt;想了解 Git 中的“衍合”，可以实践下这个文档：&lt;a href=&quot;http://git-scm.com/book/zh/Git-分支-分支的衍合&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git-分支-分支的衍合&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;修改&quot;&gt;&lt;a href=&quot;#修改&quot; class=&quot;headerlink&quot; title=&quot;修改&quot;&gt;&lt;/a&gt;修改&lt;/h4&gt;&lt;p&gt;可能你写了一个新的模块，需要纳入项目的版本控制：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git add tools.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你发现某个模块已经陈旧了，不再使用了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git rm utils.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rm --cached utils.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你发现一个模块的命名不太合理，需要改名：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git mv model.py models.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你要创建一个新的较大的模块，需要归档为目录的方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir groups&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ touch groups/__init__.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add groups/__init__.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注解&lt;br&gt;Git 不支持空文件加加入版本控制，非得必要咋办，后续的其它场景会简单说明下&lt;br&gt;可能你发现要写的模块代码布局类似于旧的模块，直接复制个代码模版：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cp users/tests.py groups/tests.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add groups/tests.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注解&lt;br&gt;Git 没有自带的所谓 cp 命令&lt;br&gt;当然，其实最常见的情况其实还是打开编辑器，比如 Vim，修改已经存在的代码，这个就跟 Git 命令无关了。&lt;/p&gt;
&lt;h4 id=&quot;检查&quot;&gt;&lt;a href=&quot;#检查&quot; class=&quot;headerlink&quot; title=&quot;检查&quot;&gt;&lt;/a&gt;检查&lt;/h4&gt;&lt;p&gt;忙碌的一天过去了，或者一个任务完成了，这个时候一般会将你的工作成果，也就是代码更新到版本仓库（分为本地版本仓库和远程版本仓库）。&lt;br&gt;习惯上会先检查下修改状态：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看到一些 Git 状态信息，确认是修改了哪些文件，之后一般会自己 code review 一下代码的改动，可能有的人会习惯直接用 Git 方式来查看：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git diff&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里的 diff 只是查看其中“工作目录”和“暂存区域”的区别。要查看“暂存区域”和“本地仓库”的区别，可以用：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git diff --staged  # 或 git diff --cached&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注解&lt;/p&gt;
&lt;p&gt;最好理解下三个区的概念，以代码角度来理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作目录：&lt;code&gt;git clone&lt;/code&gt; 后获得的一份本地的代码，也包括新编辑的，尚未加入版本控制的代码&lt;/li&gt;
&lt;li&gt;暂存区域：&lt;code&gt;git add&lt;/code&gt; 后暂存起来，尚未 &lt;code&gt;git commit&lt;/code&gt; 的代码&lt;/li&gt;
&lt;li&gt;本地仓库：&lt;code&gt;git commit&lt;/code&gt; 后正式被版本控制记录起来的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看下图，能更好的理解这三个区&lt;/p&gt;
&lt;p&gt;然后本地运行下相关的单元测试，确认是否有问题。一般来说这个时候，没有什么特殊情况，就直接进入“提交”甚至是“推送”阶段了，然后结束一个工作日或工作周期，但难免会有些特殊情况出现。&lt;/p&gt;
&lt;h4 id=&quot;取消修改&quot;&gt;&lt;a href=&quot;#取消修改&quot; class=&quot;headerlink&quot; title=&quot;取消修改&quot;&gt;&lt;/a&gt;取消修改&lt;/h4&gt;&lt;p&gt;当你 code review 完后，发现有些改动不满意；或者运行完单元测试，发现有些测试用例没通过，你可能会进行取消这些修改的操作。&lt;br&gt;如果还没 add，那么可以：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -- main.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为了避免刚好跟分支名重合，所以加了两个斜杠（虽然概率很低），如果已经 add 了，但还没 commit，那么可以：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git reset HEAD main.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;万一刚提交完毕，也就是已经 commit 了，才发现代码有问题，比如：忘记把某个文件提交了，这个时候咋办？Git 好处是可以覆盖上一次提交，那么可以：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git add tests.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit --amend&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面还只是简单的撤销操作，Git 还能支持更高级的重写历史功能，想掌握高级技能的可以实践下这个文档：&lt;a href=&quot;http://git-scm.com/book/zh/Git-工具-重写历史&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git-工具-重写历史&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;解决冲突&quot;&gt;&lt;a href=&quot;#解决冲突&quot; class=&quot;headerlink&quot; title=&quot;解决冲突&quot;&gt;&lt;/a&gt;解决冲突&lt;/h4&gt;&lt;p&gt;有时候同别人合作写一个模块的代码，会把对方代码合并或衍合过来，比如：对方修复了某个缺陷，你刚好也需要这个修复；再比如：对方完成了某个特性，你也刚好需要用下这 个特性等等各种情况。&lt;br&gt;大多数情况，代码的合并或衍合不会冲突，但也有冲突的情况，分两种情况说明，第一种是合并操作时候有冲突：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge bugfix/remove_error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 这个时候就提示你代码冲突了，处理完冲突的代码后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff  # code review 下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add remove.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 日志中就多了一条合并操作的日志了&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另一种是衍合操作时有冲突：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rebase bugfix/remove_error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 这个时候就提示你代码冲突了，处理完冲突的代码后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff  # code review 下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rebase --continue  # 有时候会 git rebase --skip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 直到不用再 rebase 为止&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;提交到本地版本仓库&quot;&gt;&lt;a href=&quot;#提交到本地版本仓库&quot; class=&quot;headerlink&quot; title=&quot;提交到本地版本仓库&quot;&gt;&lt;/a&gt;提交到本地版本仓库&lt;/h4&gt;&lt;p&gt;最后，一切确认没问题了：code review 完毕，自己觉得代码满意了；有可能也合并完别人的修改并且没有冲突了；运行单元测试也通过了。那么就提交代码吧：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;推送到远程版本仓库&quot;&gt;&lt;a href=&quot;#推送到远程版本仓库&quot; class=&quot;headerlink&quot; title=&quot;推送到远程版本仓库&quot;&gt;&lt;/a&gt;推送到远程版本仓库&lt;/h4&gt;&lt;p&gt;Git 中的 commit 只是提交到自己本地的版本控制仓库，如果想分享你的代码提交，还需要推送到远程的版本控制仓库：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;在分支工作&quot;&gt;&lt;a href=&quot;#在分支工作&quot; class=&quot;headerlink&quot; title=&quot;在分支工作&quot;&gt;&lt;/a&gt;在分支工作&lt;/h3&gt;&lt;p&gt;Git 分支很灵活，用 Git 的合作开发模式方式也很灵活，如何更好得使用 Git 分支来合作开发，可以参考这篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中文翻译版本一：&lt;a href=&quot;http://www.juvenxu.com/2010/11/28/a-successful-git-branching-model/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.juvenxu.com/2010/11/28/a-successful-git-branching-model/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文翻译版本二：&lt;a href=&quot;http://www.oschina.net/translate/a-successful-git-branching-model&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oschina.net/translate/a-successful-git-branching-model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;英文原文：&lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nvie.com/posts/a-successful-git-branching-model/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能后续也会写一篇专门的以 Git 为例的源代码的管理和发布相关主题的文章。&lt;/p&gt;
&lt;p&gt;下面说下在分支工作的常见的实际场景，按顺序：&lt;/p&gt;
&lt;h4 id=&quot;创建新的本地分支&quot;&gt;&lt;a href=&quot;#创建新的本地分支&quot; class=&quot;headerlink&quot; title=&quot;创建新的本地分支&quot;&gt;&lt;/a&gt;创建新的本地分支&lt;/h4&gt;&lt;p&gt;确定要新开个分支来写代码，这里以贡献新特性为例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b features/batch_remove&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -a  # 确认已经在新分支中工作了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git log  # 可以确认是基于刚才的分支新分出来的&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里已经隐含了自动切换到新分支的动作了。&lt;/p&gt;
&lt;h4 id=&quot;在新的本地分支工作&quot;&gt;&lt;a href=&quot;#在新的本地分支工作&quot; class=&quot;headerlink&quot; title=&quot;在新的本地分支工作&quot;&gt;&lt;/a&gt;在新的本地分支工作&lt;/h4&gt;&lt;p&gt;类似，“日常工作”中的工作周期操作，这个时候，你就可以在新分支中进行大刀阔斧的工作了，直到分支中代码符合要求。&lt;/p&gt;
&lt;h4 id=&quot;推送成为作为远程分支&quot;&gt;&lt;a href=&quot;#推送成为作为远程分支&quot; class=&quot;headerlink&quot; title=&quot;推送成为作为远程分支&quot;&gt;&lt;/a&gt;推送成为作为远程分支&lt;/h4&gt;&lt;p&gt;如果想把分支分享给别人，可以推送到远程版本库，这样别人可以根据需要来把你的分支代码更新到他自己的本地仓库，例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin features/batch_remove&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;合并或衍合远程分支&quot;&gt;&lt;a href=&quot;#合并或衍合远程分支&quot; class=&quot;headerlink&quot; title=&quot;合并或衍合远程分支&quot;&gt;&lt;/a&gt;合并或衍合远程分支&lt;/h4&gt;&lt;p&gt;在分支中工作一段时间后，确认相关的功能代码、测试代码、文档等都提交完毕了，单元测试通过，大家 code review 一致认为没问题，审核通过，最后该分支的持续集成（CI）完整 build 通过。这个时候，就可以进行合并的操作了。&lt;/p&gt;
&lt;p&gt;其实前面也提过类似操作，这里再类似重复一遍，如果用合并：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge features/batch_remove&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 如果没提示冲突，那就合并成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 如果这个时候就提示你代码冲突了，处理完冲突的代码后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff  # code review 下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add batch.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 日志中就多了一条合并操作的日志了&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果用衍合：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rebase features/batch_remove&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 如果没提示冲突，那就衍合成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 如果这个时候就提示你代码冲突了，处理完冲突的代码后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff  # code review 下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rebase --continue  # 有时候会 git rebase --skip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 直到不用再 rebase 为止&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里也提下直接合并本地分支，有时候你创建的分支只是自己用用，没有共享给别人，因为本地已经有了这份分支代码了，那么就省去 &lt;code&gt;git fetch&lt;/code&gt; 操作，类似上述方式合并或衍合代码就行。&lt;/p&gt;
&lt;p&gt;对比 Subversion 的分支合并操作，实在是简化不少。&lt;/p&gt;
&lt;h4 id=&quot;删除分支&quot;&gt;&lt;a href=&quot;#删除分支&quot; class=&quot;headerlink&quot; title=&quot;删除分支&quot;&gt;&lt;/a&gt;删除分支&lt;/h4&gt;&lt;p&gt;如果确认工作完毕的分支不再需要了，那就记得及时清理掉，删除远程分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin :features/batch_remove&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删除本地分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -d features/batch_remove&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;顺便说下，一段时间后，一定有一堆别人的分支，然后你 &lt;code&gt;git fetch&lt;/code&gt; 下来了，这样就出现在本地的分支清单中，但远程版本库中已经删除了，如果想本地分支清单干净些，可以在 &lt;code&gt;git fetch&lt;/code&gt; 时候这样执行：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --all -p&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Ship-it&quot;&gt;&lt;a href=&quot;#Ship-it&quot; class=&quot;headerlink&quot; title=&quot;Ship it&quot;&gt;&lt;/a&gt;Ship it&lt;/h3&gt;&lt;p&gt;可能在平时的研发分支工作一段时间后，并且测试完毕，大家觉得符合发布条件了。终于可以进入到版本发布阶段的工作了。&lt;/p&gt;
&lt;h4 id=&quot;创建发布分支&quot;&gt;&lt;a href=&quot;#创建发布分支&quot; class=&quot;headerlink&quot; title=&quot;创建发布分支&quot;&gt;&lt;/a&gt;创建发布分支&lt;/h4&gt;&lt;p&gt;一般来说这个时候已经将在某个发布分支上工作了，比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b release-1.2 develop  # develop 就是平时的研发分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ release.sh 1.2  # 比如有个执行发布脚本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;打标签&quot;&gt;&lt;a href=&quot;#打标签&quot; class=&quot;headerlink&quot; title=&quot;打标签&quot;&gt;&lt;/a&gt;打标签&lt;/h4&gt;&lt;p&gt;确定可以发布了，就开始打标签吧，比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge --no-ff release-1.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git tag -a v1.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git tag  # 确认下打上了标签了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin v1.2  # 推送标签到远程版本库&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;正式发布&quot;&gt;&lt;a href=&quot;#正式发布&quot; class=&quot;headerlink&quot; title=&quot;正式发布&quot;&gt;&lt;/a&gt;正式发布&lt;/h4&gt;&lt;p&gt;发布又是一个比较复杂的主题，比如：能快速发布、快速回滚（包括数据回滚）、灰度发布等等，在构建发布工具中会详细进行介绍，这里就简单罗列下。&lt;/p&gt;
&lt;p&gt;一般来说，根据实际情况，可以记录下来发布相关的操作过程。很多环节可以写脚本将来的人工操作改成自动化操作。以后只要执行发布脚本执行一键发布就可以了。&lt;/p&gt;
&lt;h3 id=&quot;其它场景&quot;&gt;&lt;a href=&quot;#其它场景&quot; class=&quot;headerlink&quot; title=&quot;其它场景&quot;&gt;&lt;/a&gt;其它场景&lt;/h3&gt;&lt;p&gt;可能还有很多别的场景，比较零散，但也算经常用到。&lt;br&gt;code review 查看代码，要知道对应代码是由谁写的，好询问了解具体代码的思路：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git blame&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;跟踪问题时候，会查看日志，更方便历史代码定位：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;觉得完整的 Git 命令太长，想用类似 Subversion 的缩写命令，可以用 &lt;code&gt;alias&lt;/code&gt;，比如配置文件中可以写上：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[alias]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    br = branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ci = commit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    co = checkout&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    diffs = diff --staged&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    st = status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lg = log --graph --abbrev-commit --decorate --format=format:&amp;apos;%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n&amp;apos;&amp;apos;          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)&amp;apos; --all&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有时候合并或衍合代码，但本地有修改了一半的代码没有提交，可以先暂存起来：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git stash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 合并或衍合完毕代码后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git stash pop  # 恢复刚才修改了一半的代码&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;原来的一个项目想拆分多个项目，又想保留版本仓库记录，可以用下 &lt;code&gt;git subtree split&lt;/code&gt;，例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git subtree split --prefix=plugins/sqli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Git 不支持空文件夹加入版本控制，变通方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir downloads&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ vim downloads/.gitignore  # 增加 * 和 !.gitignore 这两条规则&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;永远别忘了-help&quot;&gt;&lt;a href=&quot;#永远别忘了-help&quot; class=&quot;headerlink&quot; title=&quot;永远别忘了 help&quot;&gt;&lt;/a&gt;永远别忘了 help&lt;/h3&gt;&lt;p&gt;对于习惯命令行下编程的程序员来说，多看帮助总是好的，直接执行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git help&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到 Git 的常用命令，如果想看到更全的 Git 命令，可以执行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git help -a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;单独查看某个命令的帮助，可以执行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git help add  # 比如 add 命令&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;会发现更多的命令，这个相比 Subversion 的命令更多，所以看起来也更复杂些，不过Git 本身也比 Subversion 更灵活、更好，比如：分支的使用、历史提交修改等。&lt;/p&gt;
&lt;h3 id=&quot;好习惯&quot;&gt;&lt;a href=&quot;#好习惯&quot; class=&quot;headerlink&quot; title=&quot;好习惯&quot;&gt;&lt;/a&gt;好习惯&lt;/h3&gt;&lt;p&gt;这里顺带说下几个使用 Git 的好习惯，但有的其实跟 Git 联系也不算大，只是顺带提下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持工作目录干净。或者说工作目录中的代码变更就为了完成一个任务，即一次只做一件事。完成任务后，就直接 &lt;code&gt;git commit&lt;/code&gt; 提交到本地版本仓库的某个分支中，而不用担心其它任务作出的代码变更无提交。并且，对于分支切换更方便，而不用担心代码被覆盖或冲突的问题。&lt;/li&gt;
&lt;li&gt;Git 的日志信息足够有效。足够有效的意思，是说这次提交作出的变更摘要，只要别人阅读了日志就能知道大概，如果为了深入了解变更细节才会去查看具体代码变更。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit&lt;/code&gt; 前 code review。code review 本身就是个好习惯，提交前确认是一种更为严谨的方式，如果觉得自己 code review 发现不了什么问题，那么随便从身边抓个会代码的，跟别人讲解下代码变更的内容，说不定会发现你没考虑到的问题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit&lt;/code&gt; 前跑单元测试。写单元测试本身也是个不错的习惯，如果项目本身已经有了完备的单元测试覆盖了，那么你对代码的修改，应该能通过单元测试，所以提交前执行一遍是否通过。如果没通过，就得看下是功能代码写的有问题，还是测试代码有问题，比如：功能需求或接口设计有变化，而测试代码没有同步更新。&lt;/li&gt;
&lt;li&gt;有代码变更及时提交。有 Git 这种版本控制工具，本身就是为了记录研发过程，避免意外导致代码丢失，如果为了完成某个任务需要很长时间，代码也很久没有提交，风险太高。这个时候，一般会自己开个分支，而将代码提交到分支中，既解决代码要及时提交的问题，又解决代码提交频繁，可能造成代码不稳定影响别人的问题，因为那个分支只有你自己在工作。而这一点，Git 分支的功能更为强大，更加鼓励多开分支。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h3&gt;&lt;p&gt;这些场景覆盖的 Git 命令其实很有限，如果要完整的熟悉，那就 git help 以及阅读下《Git Pro》这本官方推荐的入门书，有个系统的学习，基础才会更加牢固。&lt;/p&gt;
&lt;h3 id=&quot;后续&quot;&gt;&lt;a href=&quot;#后续&quot; class=&quot;headerlink&quot; title=&quot;后续&quot;&gt;&lt;/a&gt;后续&lt;/h3&gt;&lt;p&gt;另外，这里只是以程序员的场景来简单介绍 Git 使用，对于系统管理员，可能有一部分职责是作为 Git 版本仓库管理员，日常也会遇到的各种场景吧，后续也会简单介绍。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;原文：&lt;a href=&quot;http://pm.readthedocs.io/vcs/git/usage.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://pm.readthedocs.io/vcs/git/usage.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git-scm.com/book/zh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://git-scm.com/book/zh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://source.android.com/source/developing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://source.android.com/source/developing.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.oschina.net/translate/a-successful-git-branching-model&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oschina.net/translate/a-successful-git-branching-model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Git 相比 Subversion，无论概念上还是使用上，复杂度其实是高出一个等级的。为什么这么说？分别看下 &lt;code&gt;git help -a&lt;/code&gt; 和 &lt;code&gt;svn help&lt;/code&gt; 命令清单的对比，单按这个来看，就如果要掌握所有命令的用法，Git 的学习曲线绝对是比 Subversion 高的。尽管如此，但还是有越来越多项目开始用 Git 来做源码管理了。&lt;/p&gt;
&lt;p&gt;实际中，我们用到的的 Git 命令还是很有限的，可能也就 &lt;code&gt;git help&lt;/code&gt; 中那些而已。下面就类似 &lt;a href=&quot;http://blog.keepmovingxin.com/2016/05/20/SVN-Workflow/&quot;&gt;SVN命令用法：程序员的场景&lt;/a&gt; 一样，结合实际场景说下 Git 的常用命令用法。&lt;br&gt;
    
    </summary>
    
      <category term="工具/效率" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%88%E7%8E%87/"/>
    
    
      <category term="Git" scheme="http://blog.keepmovingxin.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>SVN命令用法：程序员的场景</title>
    <link href="http://blog.keepmovingxin.com/2016/05/20/SVN-Workflow/"/>
    <id>http://blog.keepmovingxin.com/2016/05/20/SVN-Workflow/</id>
    <published>2016-05-20T14:31:59.000Z</published>
    <updated>2016-06-06T02:18:06.000Z</updated>
    
    <content type="html">&lt;p&gt;SVN有不少命令，其实常用的也就那么几个，可以结合下实际的使用场景，来说明下SVN的命令用法。&lt;br&gt;当然可能对很多人来说，最实用的熟悉方式，就是直接运行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn help (?, h)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就入门了，但为了更好的记忆，有个实际场景也是个不错的选择。&lt;br&gt;注解：括号中的是该命令的缩写或别名，有的可以少打几个字母，后面也有类似描述。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;“新人报道”&quot;&gt;&lt;a href=&quot;#“新人报道”&quot; class=&quot;headerlink&quot; title=&quot;“新人报道”&quot;&gt;&lt;/a&gt;“新人报道”&lt;/h3&gt;&lt;p&gt;你刚入职一家公司，或新加入某个团队，立马参与到一个项目中，项目代号Norther，那么就得获取项目代码，开始你的项目生涯。这个时候一般你需要签出项目代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn checkout (co) https://scms.ship.it/svn/norther/trunk norther&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认工作目录的SVN信息，说明已经纳入版本控制了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/projects/norther&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn info&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认没问题了，就运行项目中的构建脚本，然后就可以熟悉代码，展开具体工作了。&lt;br&gt;当然，有的时候，有一个新项目是由你发起的，你要将初始化的项目工程放到SVN版本仓库中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn import souther https://scms.ship.it/svn&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认项目已经在版本仓库中了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn list (ls) https://scms.ship.it/svn/souther/trunk&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;应该就可以看到Souther项目的根目录结构了。&lt;/p&gt;
&lt;h3 id=&quot;日常工作&quot;&gt;&lt;a href=&quot;#日常工作&quot; class=&quot;headerlink&quot; title=&quot;日常工作&quot;&gt;&lt;/a&gt;日常工作&lt;/h3&gt;&lt;p&gt;当你已经逐渐融入了一个项目，可能一天的工作场景或完成某个任务的工作周期是这样的：&lt;/p&gt;
&lt;h4 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h4&gt;&lt;p&gt;无论是清早或下午或晚上，开始了你的一天工作，你首先会更新你的工作目录：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/projects/norther&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn update (up)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样你就可以在最新的项目代码基础上工作了。&lt;/p&gt;
&lt;h4 id=&quot;修改&quot;&gt;&lt;a href=&quot;#修改&quot; class=&quot;headerlink&quot; title=&quot;修改&quot;&gt;&lt;/a&gt;修改&lt;/h4&gt;&lt;p&gt;可能你写了一个新的模块，需要纳入项目的版本控制：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn add tools.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你发现某个模块已经陈旧了，不再使用了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn delete (del, remove, rm) utils.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你发现一个模块的命名不太合理，需要改名：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn move (mv) model.py models.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你要创建一个新的较大的模块，需要归档为目录的方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn mkdir groups&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可能你发现要写的模块代码布局类似于旧的模块，直接复制个代码模版：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn copy (cp) users/tests.py groups/tests.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然，其实最常见的情况其实还是打开编辑器，比如Vim，修改已经存在的代码，这个就跟SVN命令无关了。&lt;/p&gt;
&lt;h4 id=&quot;检查&quot;&gt;&lt;a href=&quot;#检查&quot; class=&quot;headerlink&quot; title=&quot;检查&quot;&gt;&lt;/a&gt;检查&lt;/h4&gt;&lt;p&gt;忙碌的一天过去了，或者一个任务完成了，这个时候一般会将你的工作成果，也就是代码更新到版本仓库。&lt;br&gt;习惯上会先检查下修改状态：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn status (stat, st)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看到一些SVN状态位信息，确认是修改了哪些文件，之后一般会自己code review一下代码的改动，可能有的人会习惯直接用SVN方式来查看：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn diff (di)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后本地运行下相关的单元测试，确认是否有问题。一般来说这个时候，没有什么特殊情况，就直接进入“提交”阶段了，然后结束一个工作日或工作周期，但难免会有些特殊情况出现。&lt;/p&gt;
&lt;h4 id=&quot;取消修改&quot;&gt;&lt;a href=&quot;#取消修改&quot; class=&quot;headerlink&quot; title=&quot;取消修改&quot;&gt;&lt;/a&gt;取消修改&lt;/h4&gt;&lt;p&gt;当你code review完后，发现有些改动不满意，你可能又会取消这些修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn revert main.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;解决冲突&quot;&gt;&lt;a href=&quot;#解决冲突&quot; class=&quot;headerlink&quot; title=&quot;解决冲突&quot;&gt;&lt;/a&gt;解决冲突&lt;/h4&gt;&lt;p&gt;当你打算提交时候，习惯上一般会再次更新自己的工作目录，现在合并下别人的工作成果（如果有的话）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn update (up)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能这个时候更新完代码，你对某个模块的代码有改动，别人也改动了同一个模块的代码，可能就会产生代码冲突。&lt;/li&gt;
&lt;li&gt;也可能有的人没这习惯，就直接提交代码，发现提交没有成功，一看，原来是别人提交的代码刚好也改动了你提交的代码，也产生了冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论哪种情况，就是代码冲突了，需要解决冲突，一般会人工确认代码合并，处理冲突的代码，是选择别人的处理，还是自己的处理，还是要额外处理，处理完毕后，执行命令，比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn resolve main.py --accept working&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另外，也有个resolved命令，用来删除“冲突”状态，但官方说被上面命令替换了，不推荐使用了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn resolved main.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;提交&quot;&gt;&lt;a href=&quot;#提交&quot; class=&quot;headerlink&quot; title=&quot;提交&quot;&gt;&lt;/a&gt;提交&lt;/h4&gt;&lt;p&gt;最后，一切确认没问题了：code review完毕，自己觉得代码满意了；然后也合并完别人的修改并且没有冲突了；运行单元测试也通过了。那么就提交代码吧：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn commit (ci)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;在分支工作&quot;&gt;&lt;a href=&quot;#在分支工作&quot; class=&quot;headerlink&quot; title=&quot;在分支工作&quot;&gt;&lt;/a&gt;在分支工作&lt;/h3&gt;&lt;p&gt;在 &lt;a href=&quot;http://zhengkun.info/2013/09/01/vcs-svn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源代码的管理和发布：以SVN为例&lt;/a&gt; 这篇文章中，介绍的SVN开发模式中，涉及分支的概念，一般来说会有以下3种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贡献新特性。也就是说，为了增加新的功能，或者对旧功能的改进等等。&lt;/li&gt;
&lt;li&gt;“除虫”。就是日常说的缺陷修复。&lt;/li&gt;
&lt;li&gt;发布阶段（发布分支）-&amp;gt;旧版本维护（旧版本维护分支）。这个概念稍微复杂，trunk研发到某个阶段，代码符合某个版本发布条件了，就会新建1个发布分支，测试没问题了，就在这个分支上进行发布；发布完成后，这个版本的维护就在这个维护分支上进行了；这个时候trunk已经进行最新版本的研发了，所以说这个分支是个旧版本维护分支。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述说的3种分支情况，前两个分支的生命周期比较短，新特性搞定或“除虫”完毕，合并代码到trunk后就结束自己的生命周期了。&lt;/p&gt;
&lt;p&gt;最后一种情况，生命周期相对较长，如果这个分支需要维护的版本还要支持，那么就得一直存在，直到不再维护为止。&lt;/p&gt;
&lt;p&gt;下面说下在分支工作的实际场景，按顺序：&lt;/p&gt;
&lt;h4 id=&quot;创建新分支&quot;&gt;&lt;a href=&quot;#创建新分支&quot; class=&quot;headerlink&quot; title=&quot;创建新分支&quot;&gt;&lt;/a&gt;创建新分支&lt;/h4&gt;&lt;p&gt;当上述3种场景发生，确定要新开个分支来写代码，先复制trunk到分支，这里以贡献新特性为例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn copy (cp) https://scms.ship.it/svn/norther/trunk https://scms.ship.it/svn/norther/branches/feature1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;切换到新分支&quot;&gt;&lt;a href=&quot;#切换到新分支&quot; class=&quot;headerlink&quot; title=&quot;切换到新分支&quot;&gt;&lt;/a&gt;切换到新分支&lt;/h4&gt;&lt;p&gt;一般来说这个时候本地的工作目录是trunk，确定本地工作目录是干净的，为后续在分支工作，以及合并分支做好准备，避免可能的各种代码冲突或工作成果代码被覆盖等情况出现。&lt;/p&gt;
&lt;p&gt;确认当前所在的SVN工作目录，比如，可能是在trunk的SVN路径：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn info&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认工作目录干净：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn status (st)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;切换到刚才新创建的分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn switch (sw) https://scms.ship.it/svn/norther/branches/feature1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认切换后的SVN工作目录，应该就是在刚才新创建的分支的SVN路径了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn info&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;在新分支工作&quot;&gt;&lt;a href=&quot;#在新分支工作&quot; class=&quot;headerlink&quot; title=&quot;在新分支工作&quot;&gt;&lt;/a&gt;在新分支工作&lt;/h4&gt;&lt;p&gt;类似，“日常工作”中的工作周期操作，这个时候，你就可以在新分支中进行大刀阔斧的工作了，直到分支中代码符合合并到trunk的的条件了。&lt;/p&gt;
&lt;h4 id=&quot;合并分支到trunk&quot;&gt;&lt;a href=&quot;#合并分支到trunk&quot; class=&quot;headerlink&quot; title=&quot;合并分支到trunk&quot;&gt;&lt;/a&gt;合并分支到trunk&lt;/h4&gt;&lt;p&gt;在分支中工作一段时间后，确认相关的功能代码、测试代码、文档等都提交完毕了，单元测试通过，大家code review一致认为没问题，审核通过，最后该分支的持续集成（CI）完整build通过。这个时候，就可以进行合并到trunk的操作了。&lt;/p&gt;
&lt;p&gt;确保下面操作是在工作目录的根目录下进行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/projects/norther/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认分支工作目录干净，没有需要提交的代码了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn status (st)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;切换工作目录回trunk，如果由于代码变动大有冲突，就解决冲突，特别如果有目录变动很可能有目录冲突：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn switch (sw) https://scms.ship.it/svn/norther/trunk&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认切换后的SVN工作目录是trunk：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn info&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;先在本地合并分支的代码，合并过程可能会有代码冲突，解决冲突，合并会指定版本范围，一般都是分支建立时候的版本号到分支工作完毕时候最后一次提交的版本号：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn merge -r9527:9549 https://scms.ship.it/svn/norther/branches/feature1 .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认本地代码变更，code review一下，执行下单元测试：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn status (st)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn diff (di)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;确认代码没问题，正式提交代码到trunk，SVN的提交日志说明下合并信息：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn commit (ci)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;删除分支&quot;&gt;&lt;a href=&quot;#删除分支&quot; class=&quot;headerlink&quot; title=&quot;删除分支&quot;&gt;&lt;/a&gt;删除分支&lt;/h4&gt;&lt;p&gt;如果确认工作完毕的分支不再需要了，那就记得及时清理掉：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn delete (del, remove, rm) https://scms.ship.it/svn/norther/branches/feature1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Ship-it&quot;&gt;&lt;a href=&quot;#Ship-it&quot; class=&quot;headerlink&quot; title=&quot;Ship it&quot;&gt;&lt;/a&gt;Ship it&lt;/h3&gt;&lt;p&gt;在上面说的发布分支工作一段时间后，并且测试完毕，大家觉得符合发布条件了。终于可以进入到版本发布阶段的工作了。&lt;br&gt;具体故事场景可以看 源代码的管理和发布：以SVN为例 这篇文章，有对“发布分支”的介绍。&lt;br&gt;一般来说这个时候已经将trunk复制一份到了发布分支了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn copy (cp) https://scms.ship.it/svn/norther/trunk https://scms.ship.it/branches/1.0.x&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;打标签&quot;&gt;&lt;a href=&quot;#打标签&quot; class=&quot;headerlink&quot; title=&quot;打标签&quot;&gt;&lt;/a&gt;打标签&lt;/h4&gt;&lt;p&gt;复制最新的发布分支为标签：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn copy (cp) https://scms.ship.it/svn/norther/branches/1.0.x https://scms.ship.it/svn/norther/tags/1.0.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;正式发布&quot;&gt;&lt;a href=&quot;#正式发布&quot; class=&quot;headerlink&quot; title=&quot;正式发布&quot;&gt;&lt;/a&gt;正式发布&lt;/h4&gt;&lt;p&gt;发布又是一个比较复杂的主题，比如：能快速发布、快速回滚（包括数据回滚）、灰度发布等等，在 构建发布工具 中会详细进行介绍，这里就简单罗列下。&lt;/p&gt;
&lt;p&gt;情况1：完整包。导出代码，然后执行打包命令，进行完整安装：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn export https://scms.ship.it/svn/norther/tags/1.0.0 norther&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;情况2：补丁升级包。相对复杂，可能会综合运用下列命令，制作补丁安装升级包：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn status (st)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn diff (di)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn patch&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;情况3：线上更新。一般不太推荐，需要注意不要泄露“.svn”，特别是旧版本的SVN，每个目录下都有“.svn”。可能会用到下列命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn update (up)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn switch (sw) https://scms.ship.it/svn/norther/tags/1.0.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一般来说，根据实际情况，可以记录下来发布相关的操作过程。很多环节可以写脚本将原来的人工操作改成自动化操作。以后只要执行发布脚本执行一键发布就可以了。&lt;/p&gt;
&lt;h3 id=&quot;其它场景&quot;&gt;&lt;a href=&quot;#其它场景&quot; class=&quot;headerlink&quot; title=&quot;其它场景&quot;&gt;&lt;/a&gt;其它场景&lt;/h3&gt;&lt;p&gt;可能还有很多别的场景，比较零散，但也算经常用到。&lt;/p&gt;
&lt;p&gt;code review查看代码，要知道对应代码是由谁写的，好询问了解具体代码的思路：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn blame (praise, annotate, ann)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;跟踪问题时候，会查看日志，更方便历史代码定位：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;经常碰到代码锁定或很多诡异情况：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn cleanup&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;编辑特定属性，比如：定义忽略规则；依赖其它SVN路径等等&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn propedit (pedit, pe) svn:ignore .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;svn propedit (pedit, pe) svn:externals .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;SVN客户端更新，使用新的SVN客户端了，有时候会发现本地工作目录SVN相关信息陈旧，会提示你升级：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn upgrade&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;好习惯&quot;&gt;&lt;a href=&quot;#好习惯&quot; class=&quot;headerlink&quot; title=&quot;好习惯&quot;&gt;&lt;/a&gt;好习惯&lt;/h3&gt;&lt;p&gt;这里顺带说下几个使用SVN的好习惯，但有的其实跟SVN联系也不算大，只是顺带提下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持工作目录干净。或者说工作目录中的代码变更就为了完成一个任务，即一次只做一件事。完成任务后，就直接&lt;code&gt;svn commit (ci)&lt;/code&gt;提交到版本仓库，而不用担心其它任务作出的代码变更无提交。并且，对于分支和trunk间切换更方便，而不用担心代码被覆盖或冲突的问题。&lt;/li&gt;
&lt;li&gt;SVN的日志信息足够有效。足够有效的意思，是说这次提交作出的变更摘要，只要别人阅读了日志就能知道大概，如果为了深入了解变更细节才会去查看具体代码变更。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn commit (ci)&lt;/code&gt;前先&lt;code&gt;svn update (up)&lt;/code&gt;。可能不更新提交也没问题，但也有可能会相关代码被别人改动了，而提交不了，为了避免这种情况，先本地更新完毕，确保别人的改动不影响你对代码修改的意图。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn commit (ci)&lt;/code&gt;前code review。code review本身就是个好习惯，提交前确认是一种更为严谨的方式，如果觉得自己code review发现不了什么问题，那么随便从身边抓个会代码的，跟别人讲解下代码变更的内容，说不定会发现你没考虑到的问题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svn commit (ci)&lt;/code&gt;前跑单元测试。写单元测试本身也是个不错的习惯，如果项目本身已经有了完备的单元测试覆盖了，那么你对代码的修改，应该能通过单元测试，所以提交前执行一遍是否通过。如果没通过，就得看下是功能代码写的有问题，还是测试代码有问题，比如：功能需求或接口设计有变化，而测试代码没有同步更新。&lt;/li&gt;
&lt;li&gt;有代码变更及时提交。有SVN这种版本控制工具，本身就是为了记录研发过程，避免意外导致代码丢失，如果为了完成某个任务需要很长时间，代码也很久没有提交，风险太高。这个时候，一般会自己开个分支，而将代码提交到分支中，既解决代码要及时提交的问题，又解决代码提交频繁，可能造成代码不稳定影响别人的问题，因为那个分支只有你自己在工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h3&gt;&lt;p&gt;这些场景覆盖的SVN命令其实很有限，如果要完整的熟悉，那就&lt;code&gt;svn help&lt;/code&gt;以及阅读下SVN的官方手册，有个系统的学习，基础才会更加牢固。&lt;/p&gt;
&lt;h3 id=&quot;后续&quot;&gt;&lt;a href=&quot;#后续&quot; class=&quot;headerlink&quot; title=&quot;后续&quot;&gt;&lt;/a&gt;后续&lt;/h3&gt;&lt;p&gt;另外，这里只是以程序员的场景来简单介绍SVN使用，对于系统管理员，可能有一部分职责是作为SVN版本仓库管理员，日常也会遇到的各种场景吧，后续也会简单介绍。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;原文：&lt;a href=&quot;http://pm.readthedocs.io/vcs/svn/usage.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://pm.readthedocs.io/vcs/svn/usage.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.subversion.org.cn/svnbook/1.4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.subversion.org.cn/svnbook/1.4/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;SVN有不少命令，其实常用的也就那么几个，可以结合下实际的使用场景，来说明下SVN的命令用法。&lt;br&gt;当然可能对很多人来说，最实用的熟悉方式，就是直接运行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;svn help (?, h)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就入门了，但为了更好的记忆，有个实际场景也是个不错的选择。&lt;br&gt;注解：括号中的是该命令的缩写或别名，有的可以少打几个字母，后面也有类似描述。&lt;br&gt;
    
    </summary>
    
      <category term="工具/效率" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%88%E7%8E%87/"/>
    
    
      <category term="SVN" scheme="http://blog.keepmovingxin.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>(译)tolua参考手册--accessing C/C++ code from Lua</title>
    <link href="http://blog.keepmovingxin.com/2016/05/14/Cocos2dx-tolua++/"/>
    <id>http://blog.keepmovingxin.com/2016/05/14/Cocos2dx-tolua++/</id>
    <published>2016-05-14T14:09:28.000Z</published>
    <updated>2016-06-01T03:24:11.000Z</updated>
    
    <content type="html">&lt;p&gt;项目使用Cocos2dx+lua框架做的，用到luabinding实现C++代码绑定到lua层使用，所以学习一下tolua++工具的原理和使用，在这做个记录。&lt;/p&gt;
&lt;p&gt;tolua++是tolua的扩展版本，是一款能够集成C/C++与lua代码的工具。在面向C++方面，tolua++包含了一些新的特性比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持&lt;code&gt;std::string&lt;/code&gt;作为基本类型（这个可以由一个命令行选项关闭）&lt;/li&gt;
&lt;li&gt;支持类模板&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tecgraf.puc-rio.br/~celes/tolua/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tolua&lt;/a&gt;这款工具，极大的简化了C/C++代码与lua代码的集成。基于一个干净的头文件（或者从实际头文件中提取），tolua会自动生成从lua访问C/C++功能的绑定代码。使用Lua API和标记方法设施，tolua解析C/C++常数，外部变量、函数、类和方法绑定到Lua。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/tolua-3.2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;tolua如何工作-How-tolua-works&quot;&gt;&lt;a href=&quot;#tolua如何工作-How-tolua-works&quot; class=&quot;headerlink&quot; title=&quot;tolua如何工作 (How tolua works)&quot;&gt;&lt;/a&gt;tolua如何工作 (How tolua works)&lt;/h3&gt;&lt;p&gt;使用tolua，我们需要创建一个package文件（译者注：pkg文件），即一个从C/C++实际头文件整理后的头文件，列举出我们想导出到lua环境中的那些常量、变量、函数、类以及方法，然后tolua会解析该文件并且创建自动绑定C/C++代码到lua的C/C++文件，如果将创建的文件同我们的应用链接起来，我们就可以从lua中访问指定的C/C++代码。&lt;/p&gt;
&lt;p&gt;让我们先看一些例子。如果我们指定下面的c头文件作为输入到tolua:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define FALSE 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define TRUE 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enum &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; POINT = 100, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; LINE, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; POLYGON&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object* createObejct (int type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void drawObject (Object* obj, double red, double green, double blue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int isSelected (Object* obj);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;会自动生成一个绑定上面代码到Lua层的C文件。这样，我们在lua代码里就可以访问C代码。如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myLine = createObject(LINE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if isSelected(myLine) == TRUE then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  drawObject(myLine, 1.0, 0.0, 0.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  drawObject(myLine, 1.0, 1.0, 1.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此外，考虑下面类似C++头文件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define FALSE 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define TRUE 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Shape&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void draw (void);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void draw (double red, double green, double blue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int isSelected (void);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Line : public Shape&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Line (double x1, double y1, double x2, double y2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ~Line (void);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果将上面的C++头文件输入给tolua，会自定生成一个Lua层访问C++代码的C++文件。这样，就可以使用如下Lua代码访问C++:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myLine = Line:new (0,0,1,1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if myLine:isSelected() == TRUE then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; myLine:draw(1.0,0.0,0.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; myLine:draw()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myLine:delete()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;传给tolua的package文件(.pkg)不是原本的C/C++头文件，而是手动处理过的版本。例如，外部代码访问的C++方法应该是public的，但并没有public修饰。tolua并没有实现对C/C++代码的完全解析，但它能够导出一些声明用于描述的功能到Lua层。因此，tolua将会提取出用户指定的代码以用于解析头文件。&lt;/p&gt;
&lt;h3 id=&quot;tolua的使用-How-to-use-toLua&quot;&gt;&lt;a href=&quot;#tolua的使用-How-to-use-toLua&quot; class=&quot;headerlink&quot; title=&quot;tolua的使用 (How to use toLua)&quot;&gt;&lt;/a&gt;tolua的使用 (How to use toLua)&lt;/h3&gt;&lt;p&gt;tolua由两部分代码组成：可执行程序和静态库（an executable and a library）。可执行程序用于解析，读入package文件，然后输出C/C++代码，该代码提供了从lua层访问C/C++层的绑定。如果package文件是与C++类似的代码（例如包括类的定义），就会生成一份C++代码。如果package文件是与C类似的代码（例如不包括类），就会生成一份C代码。tolua可接受一些选项。运行&lt;code&gt;tolua -h&lt;/code&gt;显示当前可接受的选项。例如，要解析一个名为&lt;code&gt;myfile.pkg&lt;/code&gt;生成一个名为&lt;code&gt;myfile.c&lt;/code&gt;的绑定代码，我们需要输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tolua -o myfile.c myfile.pkg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生成的代码必须编译并和应用程序链接，才能提供给Lua进行访问。每个被解析的文件代表导出到Lua的package。默认情况下，package的名称就是输入文件的根名称（例子中为&lt;code&gt;myfile&lt;/code&gt;），用户可以指定一个不同的名称给package：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tolua -n pkgname -o myfile.c myfile.pkg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;package还应该明确的初始化。为了从C/C++代码中初始化package，我们必须声明和调用初始化函数。初始化函数被定义为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int tolua_pkgname_open (void);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中pkgname表示绑定的package名称。如果我们使用C++，我们可以选择自动初始化：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tolua -a -n pkgname -o myfile.c myfile.pkg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当前tolua版本还导出绑定的关闭功能，可称为解绑定package：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void tolua_pkgname_close (void);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还有，&lt;code&gt;open&lt;/code&gt;和&lt;code&gt;close&lt;/code&gt;功能的原型可以输出一个头文件，通过&lt;code&gt;-H&lt;/code&gt;选项设置。&lt;/p&gt;
&lt;p&gt;tolua生成的绑定代码使用了一系列tolua库里面的函数。因此，这个库同样需要被链接到应用程序中。&lt;code&gt;tolua.h&lt;/code&gt;也是有必须要编译生成的代码。。&lt;/p&gt;
&lt;p&gt;应用程序无需绑定任何package文件也可以使用tolua的面向对象框架。在这种情况下，应用程序必须调用tolua初始化函数（此函数被任何package文件初始化函数调用）：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int tolua_open (void);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果要使用多个Lua状态(&lt;code&gt;Lua state&lt;/code&gt;)，设置一个Lua状态(&lt;code&gt;Lua state&lt;/code&gt;)后，我们需要调用一个函数来恢复tolua内部状态:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void tolua_restorestate (void);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;tolua的一些基本概念-Basic-Concepts&quot;&gt;&lt;a href=&quot;#tolua的一些基本概念-Basic-Concepts&quot; class=&quot;headerlink&quot; title=&quot;tolua的一些基本概念 (Basic Concepts)&quot;&gt;&lt;/a&gt;tolua的一些基本概念 (Basic Concepts)&lt;/h3&gt;&lt;p&gt;使用tolua的第一步就是创建package文件。我们从真正的头文件入手，将想要暴露给lua的特性转换成tolua可以理解的格式。tolua能够理解的格式就是一些简单的C/C++声明。我们从下面几个方面来讨论：&lt;/p&gt;
&lt;h4 id=&quot;文件包含&quot;&gt;&lt;a href=&quot;#文件包含&quot; class=&quot;headerlink&quot; title=&quot;文件包含&quot;&gt;&lt;/a&gt;文件包含&lt;/h4&gt;&lt;p&gt;一个package文件可以包含另外的package文件。一般格式是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$&amp;lt;include_file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;基本类型-Basic-types&quot;&gt;&lt;a href=&quot;#基本类型-Basic-types&quot; class=&quot;headerlink&quot; title=&quot;基本类型 (Basic types)&quot;&gt;&lt;/a&gt;基本类型 (Basic types)&lt;/h4&gt;&lt;p&gt;tolua会自动映射C/C++的基本类型到lua的基本类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;char&lt;/code&gt;,&lt;code&gt;int&lt;/code&gt;,&lt;code&gt;float&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;类型被映射为lua中的&lt;code&gt;number&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char*&lt;/code&gt;被映射为lua中的&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void*&lt;/code&gt;被映射为lua中的&lt;code&gt;userdata&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C/C++中的数据类型前面可能有修饰语（如unsigned, static, short, const等等）。然而我们要注意到tolua会忽略基本类型前面的修饰语const。因此，我们给lua传递一个基本类型常量然后再从lua中传递回给C/C++代码，常量到非常量的转换会被悄悄的完成。&lt;/p&gt;
&lt;p&gt;C/C++函数也可以对lua对象进行明确的操作。&lt;code&gt;lua_Object&lt;/code&gt;被认为是一个基本类型，任何lua值都符合。&lt;/p&gt;
&lt;p&gt;tolua++新特性：C++中的&lt;code&gt;string&lt;/code&gt;类型同样被认为是基本类型，会被当作值传递给lua(使用c_str()方法)。这个功能可以使用命令行选项&lt;code&gt;-S&lt;/code&gt;进行关闭。&lt;/p&gt;
&lt;h4 id=&quot;用户定义的类型-User-defined-types&quot;&gt;&lt;a href=&quot;#用户定义的类型-User-defined-types&quot; class=&quot;headerlink&quot; title=&quot;用户定义的类型 (User defined types)&quot;&gt;&lt;/a&gt;用户定义的类型 (User defined types)&lt;/h4&gt;&lt;p&gt;在package文件里的所有其他类型都会被认为是用户自定义类型。它们会映射到lua的userdata类型。lua只能存储指向用户自定义类型的指针；但是，tolua会自动采取措施来处理引用和值。例如，如果一个函数或方法返回一个用户定义类型的值，当这个值返回给lua的时候，tolua会分配一个克隆对象，同时会设置垃圾收集标记，以便在lua不再使用该对象时会自动释放。&lt;/p&gt;
&lt;p&gt;对于用户定义类型，常量是被保留的，因此将用户自定义类型的非常量作为常量传递给一个函数时，会产生类型不匹配的错误。&lt;/p&gt;
&lt;h4 id=&quot;NULL和nil-NULL-and-nil&quot;&gt;&lt;a href=&quot;#NULL和nil-NULL-and-nil&quot; class=&quot;headerlink&quot; title=&quot;NULL和nil (NULL and nil)&quot;&gt;&lt;/a&gt;NULL和nil (NULL and nil)&lt;/h4&gt;&lt;p&gt;C/C++的NULL或0指针映射到lua中的nil类型。反之，nil却可以被指定为任何C/C++指针类型。这对任何类型都有效：&lt;code&gt;char*&lt;/code&gt;, &lt;code&gt;void*&lt;/code&gt;以及用户自定义类型指针。&lt;/p&gt;
&lt;h4 id=&quot;宏定义类型-Typedefs&quot;&gt;&lt;a href=&quot;#宏定义类型-Typedefs&quot; class=&quot;headerlink&quot; title=&quot;宏定义类型 (Typedefs)&quot;&gt;&lt;/a&gt;宏定义类型 (Typedefs)&lt;/h4&gt;&lt;p&gt;tolua还接受简单类型定义的package文件。任何发生的一种定义是由tolua映射后的基类型。他们是非常有用的，因为几个包定义基本的C/C++类型自己的类型。例如，可以定义一个真正代表两个类型。在这种情况下,真正的可以用来指定变量类型package文件由tolua解释，但前提是我们包括以下定义之前使用的实际类型&lt;code&gt;real&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef double real;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;否则，&lt;code&gt;real&lt;/code&gt;将被解释为一个用户定义的类型和不会被映射到Lua数字(&lt;code&gt;numbers&lt;/code&gt;)。&lt;br&gt;包含&lt;code&gt;real&lt;/code&gt;的头文件(Including real header files)&lt;/p&gt;
&lt;p&gt;在package文件中，我们必须指定哪个是真正(&lt;code&gt;real&lt;/code&gt;)的头文件,应包含生成的代码可以访问常量,变量,函数,类具有约束。package文件中的任意行开始&lt;code&gt;$ (except $&amp;lt;...&amp;gt;, $[ , and $] lines)&lt;/code&gt;插入到生成绑定C/C++代码没有任何变化，但 &lt;code&gt;$&lt;/code&gt; 本身的消除。我们使用这个特性，包括真正(&lt;code&gt;real&lt;/code&gt;)的头文件。所以，我们的package文件通常会入手一套 &lt;code&gt;$&lt;/code&gt; 开始行指定的文件必须包括在内，也就是说，这些文件是基于package文件。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* specify the files to be included */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$#include &amp;quot;header1.h&amp;quot;                 // include first header&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$#include &amp;quot;header2.h&amp;quot;                 // include second header&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;额外说明，tolua还接受注释，使用C或C++惯例,包内的文件。也可以使用嵌套C注释。&lt;/p&gt;
&lt;p&gt;在下面几节中,我们描述了如何指定C/C++代码绑定到Lua。格式是简单有效的C/C++语句。它非常简单的将是一个真正的C/C++头文件转换成package文件。&lt;/p&gt;
&lt;h3 id=&quot;绑定常量-Binding-constants&quot;&gt;&lt;a href=&quot;#绑定常量-Binding-constants&quot; class=&quot;headerlink&quot; title=&quot;绑定常量 (Binding constants)&quot;&gt;&lt;/a&gt;绑定常量 (Binding constants)&lt;/h3&gt;&lt;p&gt;绑定常量，tolua支持两种绑定常量的方式：&lt;code&gt;define&lt;/code&gt;和 &lt;code&gt;enum&lt;/code&gt;。&lt;br&gt;&lt;code&gt;define&lt;/code&gt;通常的格式是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define NAME [ VALUE ]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的VALUE是可选的。如果这样的代码出现在被解析的文件中，tolua会将&lt;code&gt;NAME&lt;/code&gt;作为lua的全局变量，该全局变量是C/C++的常量，值为VALUE。这里只接受数字常量。&lt;/p&gt;
&lt;p&gt;tolua++新特性：所有的其他预处理指令会被忽略。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;enum&lt;/code&gt;的一般格式：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;enum &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NAME1 [ = VALUE1 ] ,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NAME2 [ = VALUE2 ] ,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NAMEn [ = VALUEn ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同样的，tolua会创建一系列全局变量，命名为&lt;code&gt;NAMEi&lt;/code&gt;，对应着各自的值。&lt;/p&gt;
&lt;h3 id=&quot;绑定外部变量-Binding-external-variables&quot;&gt;&lt;a href=&quot;#绑定外部变量-Binding-external-variables&quot; class=&quot;headerlink&quot; title=&quot;绑定外部变量 (Binding external variables)&quot;&gt;&lt;/a&gt;绑定外部变量 (Binding external variables)&lt;/h3&gt;&lt;p&gt;全局的外部变量也可以被导出。在package头文件指定为:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[extern] type var;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;tolua绑定这样的声明Lua全局变量。因此，在Lua中，我们自然地可以访问C/C++变量。如果非恒定的变量，我们也可以从Lua变量分配一个新值。全局变量表示数组的值也可以绑定到Lua。数组可以是任何类型的。相应的Lua对象数组是Lua表与数值索引；然而，请注意，指数1在Lua中映射到索引0 C/C++数组。数组必须预先设置长度。例如:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;double v[10];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绑定函数-Binding-functions&quot;&gt;&lt;a href=&quot;#绑定函数-Binding-functions&quot; class=&quot;headerlink&quot; title=&quot;绑定函数 (Binding functions)&quot;&gt;&lt;/a&gt;绑定函数 (Binding functions)&lt;/h3&gt;&lt;p&gt;函数也指传统C/C++声明:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type funcname (type1 par1[, type2 par2[,...typeN parN]]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回类型可以为空(void)，这意味着没有返回值。一个函数也可以没有参数。在这种情况下，void可能的列表中指定的参数。参数类型必须遵守已经发布的规则。tolua会创建一个Lua函数绑定C/C++函数。从Lua调用一个函数时，参数类型必须匹配相应的C/C++类型，否则，tolua会生成一个错误报告指定的参数是错误的。如果省略参数名称，tolua会自动命名，但类型应该是基本类型(basic type)或之前使用过的用户类型(user type)。&lt;/p&gt;
&lt;h4 id=&quot;Arrays-数组&quot;&gt;&lt;a href=&quot;#Arrays-数组&quot; class=&quot;headerlink&quot; title=&quot;Arrays (数组)&quot;&gt;&lt;/a&gt;Arrays (数组)&lt;/h4&gt;&lt;p&gt;tolua也处理函数或方法参数表示数组的值。阵列的优点是，它们的值更新相应的Lua表如果C/C++函数改变数组的内容。&lt;br&gt;数组必须指定大小。例如:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (double a[3]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;是一个有效的函数声明为tolua和从Lua不调用这个函数，例如:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p = &amp;#123;1.0,1.5,8.6&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func (p)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;数组维数不需要一个常数表达式，指定的大小也可以由任何表达式，可以在运行时进行。例如:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (int n, int m, double image[n*m]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;也有效的自表达式&lt;code&gt;n * m&lt;/code&gt;绑定函数范围是有效的。然而，请注意，tolua使用动态分配绑定这个函数，能降低性能。&lt;/p&gt;
&lt;p&gt;尽管大小规范，重要的是要知道所有数组传递给实际的C/C++函数在本地绑定函数的范围。所以，如果C/C++函数被称为需要保存数组指针以备后用，绑定的代码将无法正常工作。&lt;/p&gt;
&lt;h4 id=&quot;Overloaded-functions-重载函数&quot;&gt;&lt;a href=&quot;#Overloaded-functions-重载函数&quot; class=&quot;headerlink&quot; title=&quot;Overloaded functions (重载函数)&quot;&gt;&lt;/a&gt;Overloaded functions (重载函数)&lt;/h4&gt;&lt;p&gt;函数重载是支持的。记住名称相同的两个函数之间的区别是基于映射到Lua的参数类型。所以，尽管&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (int a); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void func (double a);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;代表两个不同的函数在C++中，他们是tolua相同的函数，因为int和double映射到相同的Lua类型:数字。&lt;/p&gt;
&lt;p&gt;另一个棘手的情况发生在导出指针。假设:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (char* s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void func (void* p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void func (Object1* ptr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void func (Object2* prt);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;虽然这四个函数代表不同的函数在C++中,Lua声明:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func(nil)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;匹配所有的函数。&lt;/p&gt;
&lt;p&gt;重要的是要知道tolua决定函数将调用在运行时，试图匹配每个提供的函数。tolua首先试图调用指定的函数;如果失败了，tolua然后试之前一个。重复这个过程，直到一个函数调用代码匹配或第一个函数。出于这个原因，失配误差信息，当它发生时，是基于第一个函数规范。当然性能是很重要的，我们可以指定最常用函数作为最后一个，因为它将放在第一位。&lt;/p&gt;
&lt;p&gt;tolua允许使用重载函数在C语言中，查看详细&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/tolua-3.2.html#renaming&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Renaming&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Default-parameter-values-默认参数值&quot;&gt;&lt;a href=&quot;#Default-parameter-values-默认参数值&quot; class=&quot;headerlink&quot; title=&quot;Default parameter values (默认参数值)&quot;&gt;&lt;/a&gt;Default parameter values (默认参数值)&lt;/h4&gt;&lt;p&gt;最后一个函数参数可以有相关联的默认值。在这种情况下，如果用更少的参数，函数被调用的默认值。格式指定默认值是一样的一个用于C++代码:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type funcname (..., typeN-1 parN-1 [= valueN-1], typeN parN [= valueN]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;toLua实现这个功能没有使用任何C++机制;因此，它也可以使用绑定C函数。&lt;/p&gt;
&lt;p&gt;我们也可以指定数组的元素的默认值(没有办法为数组本身，指定一个默认值)。例如:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (int a[5]=0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置默认元素值为零，因此，从Lua函数可以调用未初始化表。&lt;/p&gt;
&lt;p&gt;Lua对象类型(lua_Object)，tolua定义一个常数，可用于指定空值作为默认值:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (lua_Object lo = TOLUA_NIL);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Multiple-returned-values-多个返回值&quot;&gt;&lt;a href=&quot;#Multiple-returned-values-多个返回值&quot; class=&quot;headerlink&quot; title=&quot;Multiple returned values (多个返回值)&quot;&gt;&lt;/a&gt;Multiple returned values (多个返回值)&lt;/h4&gt;&lt;p&gt;In Lua, a function may return any number of values. tolua uses this feature to simulate values passed by reference. If a function parameter is specified as a pointer to or reference of a basic type or a pointer to or reference of a pointer to an user defined type, tolua accepts the corresponding type as input and returns, besides the conventional function returned value, if any, the updated parameter value.&lt;/p&gt;
&lt;p&gt;For instance, consider a C function that swaps two values:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void swap (double* x, double* y);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void swap (double&amp;amp; x, double&amp;amp; y);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If such a function is declared in the package file, tolua binds it as a function receiving two numbers as input and returning two numbers. So, a valid Lua code would be:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x,y = swap(x,y)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If the input values are not used, the use of default parameter value allows calling the function from Lua without specifying them:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void getBox (double* xmin=0, double* xmax=0, double* ymin=0, double* ymax=0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In Lua:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;xmin, xmax, ymin, ymax = getBox()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;With user defined types, we would have for instance:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void update (Point** p);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void update (Point*&amp;amp; p);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绑定结构体-Binding-struct-fields&quot;&gt;&lt;a href=&quot;#绑定结构体-Binding-struct-fields&quot; class=&quot;headerlink&quot; title=&quot;绑定结构体 (Binding struct fields)&quot;&gt;&lt;/a&gt;绑定结构体 (Binding struct fields)&lt;/h3&gt;&lt;p&gt;User defined types are nicely bound by tolua. For each variable or function type that does not correspond to a basic type, tolua automatically creates a tagged userdata to represent the C/C++ type. If the type corresponds to a struct, the struct fields can be directly accessed from Lua, indexing a variable that holds an object of such a type. In C code, these types are commonly defined using typedef’s:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct [name] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   type1 fieldname1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   type2 fieldname2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   typeN fieldnameN;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; typename;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If such a code is inserted in the package file being processed, tolua allows any variable that holds an object of type typename to access any listed field indexing the variable by the field name. For instance, if var holds a such object, &lt;code&gt;var.fieldnamei&lt;/code&gt; accesses the field named fieldnamei.&lt;/p&gt;
&lt;p&gt;Fields that represent arrays of values can also be mapped:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int x[10]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int y[10]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; Example;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绑定类和方法-Binding-classes-and-methods&quot;&gt;&lt;a href=&quot;#绑定类和方法-Binding-classes-and-methods&quot; class=&quot;headerlink&quot; title=&quot;绑定类和方法 (Binding classes and methods)&quot;&gt;&lt;/a&gt;绑定类和方法 (Binding classes and methods)&lt;/h3&gt;&lt;p&gt;C++ class definitions are also supported by tolua. Actually, the tolua deals with single inheritance and polymorphism in a natural way. The subsections below describe what can be exported by a class definition.&lt;/p&gt;
&lt;h4 id=&quot;Specifying-inheritance-指定继承&quot;&gt;&lt;a href=&quot;#Specifying-inheritance-指定继承&quot; class=&quot;headerlink&quot; title=&quot;Specifying inheritance (指定继承)&quot;&gt;&lt;/a&gt;Specifying inheritance (指定继承)&lt;/h4&gt;&lt;p&gt;If var is a Lua variable that holds an object of a derived class, var can be used wherever its base class type is expected and var can access any method of its base class. For this mechanism to take effect, we must indicate that the derived class actually inherits the base class. This is done in the conventional way:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class classname : public basename&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; /* class definition */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;Specifying-exported-members-and-methods-指定导出成员和方法&quot;&gt;&lt;a href=&quot;#Specifying-exported-members-and-methods-指定导出成员和方法&quot; class=&quot;headerlink&quot; title=&quot;Specifying exported members and methods (指定导出成员和方法)&quot;&gt;&lt;/a&gt;Specifying exported members and methods (指定导出成员和方法)&lt;/h4&gt;&lt;p&gt;As for struct fields, class fields, static or not, can be exported. Class methods and class static methods can also be exported. Of course, they must be declared as public in the actual C++ code (although the public: keyword may not appear in the package files).&lt;br&gt;For each bound class, tolua creates a Lua table and stores it at a global variable which name is the name of the C++ class. Static exported fields are accessed by indexing this table with the field names (similar to struct fields). Non static exported fields are accessed by indexing the variable that holds the object. Class methods follow the format of the function declaration showed above. They can be accessed from Lua code using the conventional way Lua uses to call methods, applied of course to a variable that holds the appropriate object or to the class table, for static methods.&lt;/p&gt;
&lt;p&gt;There are a few special methods that are also supported by tolua. Constructors are called as static methods, named new. Destructors are called as a conventional method called delete.&lt;/p&gt;
&lt;p&gt;Note that tolua does support overload. This applies even for constructors. Also note that the virtual keyword has no effect in the package file.&lt;/p&gt;
&lt;p&gt;The following code exemplifies class definitions that can be interpreted by tolua.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Point &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   static int n;    // represents the total number of created Points&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   double x;        // represents the x coordinate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   double y;        // represents the y coordinate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   static char* className (void);   // returns the name of the class&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Point (void);                          // constructor 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Point (double px, double py);          // constructor 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ~Point (void);                         // destructor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Point add (Point&amp;amp; other);              // add points, returning another one&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class ColorPoint : public Color &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int red;      // red color component [0 - 255]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int green;    // green color component [0 - 255]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int blue;     // blue color component [0 - 255]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ColorPoint (double px, double py, int r, int g, int b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If this segment of code is processed by tolua, we would be able to write the following Lua statements:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p1 = Point:new(0.0,1.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p2 = ColorPoint:new(1.5,2.2,0,0,255)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(Point.n)                     -- would print 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p3 = p1:add(p2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(p3.x,p3.y)                   -- would print 1.5 and 3.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(p2.red,p2.green,p2.blue)     -- would print 0, 0, and 255&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p1:delete()                        -- call destructor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p2:delete()                        -- call destructor&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Note that we can only explicitly delete objects that we explicitly create. In the example above, the point p3 will be garbage-collected by tolua automatically; we cannot delete it.&lt;br&gt;Of course, we need to specify only the methods and members we want to access from Lua. Sometimes, it will be necessary to declare a class with no member or method just for the sake of not breaking a chain of inheritances.&lt;/p&gt;
&lt;h4 id=&quot;Overloaded-operators（重载的运算符）&quot;&gt;&lt;a href=&quot;#Overloaded-operators（重载的运算符）&quot; class=&quot;headerlink&quot; title=&quot;Overloaded operators（重载的运算符）&quot;&gt;&lt;/a&gt;Overloaded operators（重载的运算符）&lt;/h4&gt;&lt;p&gt;tolua automatically binds the following binary operators:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;operator+   operator-   operator*   operator/ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;operator&amp;lt;   operator&amp;gt;   operator&amp;lt;=  operator&amp;gt;=&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;For the relational operators, toLua also automatically converts a returned 0 value into nil, so false in C becomes false in Lua.&lt;br&gt;As an example, suppose that in the code above, instead of having:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Point add (Point&amp;amp; other);              // add points, returning another one&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;we had:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Point operator+ (Point&amp;amp; other);        // add points, returning another one&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In that case, in Lua, we could simply write:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p3 = p1 + p2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The indexing operator (&lt;code&gt;operator[]&lt;/code&gt;) when receiving a numeric parameter can also be exported to Lua. In this case, tolua accepts reference as returned value, even for basic types. Then if a reference is returned, from Lua, the programmer can either get or set the value. If the returned value is not a reference, the programmer can only get the value. An example may clarify: suppose we have a vector class and bind the following operator:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;double&amp;amp; operator[] (int index);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In this case, in Lua, we would be able to write: &lt;code&gt;value = myVector[i]&lt;/code&gt; and also &lt;code&gt;myVector[i] = value&lt;/code&gt;, what updates the C++ object. However, if the bound operator was:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;double operator[] (int index);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;we would only be able to write: &lt;code&gt;value = myVector[i]&lt;/code&gt;.&lt;br&gt;Free functions (i.e., not class members) that overload operators are not supported.&lt;/p&gt;
&lt;h3 id=&quot;模块定义-Module-definition&quot;&gt;&lt;a href=&quot;#模块定义-Module-definition&quot; class=&quot;headerlink&quot; title=&quot;模块定义 (Module definition)&quot;&gt;&lt;/a&gt;模块定义 (Module definition)&lt;/h3&gt;&lt;p&gt;tolua allows us to group constants, variables, and functions in a module. The module itself is mapped to a table in Lua, and its constants, variables, and functions are mapped to fields in that table. The general format to specify a module is:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;module name &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ... // constant, variable, and function declarations &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Thus, if we bound the following module declaration:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;module mod &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; #define N &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; extern int var; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; int func (...): &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In Lua we would be able to access such features by indexing the module: &lt;code&gt;mod.N, mod.var, mod.func&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;命名常量、变量和函数-Renaming-constants-variables-and-functions&quot;&gt;&lt;a href=&quot;#命名常量、变量和函数-Renaming-constants-variables-and-functions&quot; class=&quot;headerlink&quot; title=&quot;命名常量、变量和函数 (Renaming constants, variables and functions)&quot;&gt;&lt;/a&gt;命名常量、变量和函数 (Renaming constants, variables and functions)&lt;/h3&gt;&lt;p&gt;When exporting constants, variable, and functions (members of a class or not), we can rename them, such that they will be bound with a different name from their C/C++ counterparts. To do that, we write the name they will be referenced in Lua after the character &lt;code&gt;@&lt;/code&gt;. For instance:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;extern int cvar @ lvar;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define CNAME @ LNAME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enum &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CITEM1 @ LITEM1, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CITEM2 @ LITEM2, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void cfunc @ lfunc (...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class T &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   double cfield @ lfield; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   void cmeth @ lmeth (...); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In such a case, the global variable &lt;code&gt;cvar&lt;/code&gt; would be identified in Lua by &lt;code&gt;lvar&lt;/code&gt;, the constant &lt;code&gt;CNAME&lt;/code&gt; by &lt;code&gt;LNAME&lt;/code&gt;, and so on. Note that class cannot be renamed, because they represent types in C.&lt;/p&gt;
&lt;p&gt;This renaming feature allows function overload in C, because we can choose to export two different C functions with a same Lua name:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void glVertex3d @ glVertex (double x, double y, double z=0.0); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void glVertexdv @ glVertex (double v[3]=0.0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;存储额外字段-Storing-additional-fields&quot;&gt;&lt;a href=&quot;#存储额外字段-Storing-additional-fields&quot; class=&quot;headerlink&quot; title=&quot;存储额外字段 (Storing additional fields)&quot;&gt;&lt;/a&gt;存储额外字段 (Storing additional fields)&lt;/h3&gt;&lt;p&gt;Finally, it is important to know that even though the variables that hold C/C++ objects are actually tagged userdata for Lua, tolua creates a mechanism that allows us to store any additional field attached to these objects. That is, these objects can be seen as conventional Lua tables.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;obj = ClassName:new()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.myfield = 1  -- even though &amp;quot;myfield&amp;quot; does not represent a field of ClassName&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Such a construction is possible because, if needed, tolua automatically creates a Lua table and associates it with the object. So that, the object can store additional fields not mapped to C/C++, but actually stored in the conjugate table. The Lua programmer accesses the C/C++ features and these additional fields in an uniform way. Note that, in fact, these additional fields overwrite C/C++ fields or methods when the names are the same.&lt;/p&gt;
&lt;h3 id=&quot;导出工具函数-Exported-utility-functions&quot;&gt;&lt;a href=&quot;#导出工具函数-Exported-utility-functions&quot; class=&quot;headerlink&quot; title=&quot;导出工具函数 (Exported utility functions)&quot;&gt;&lt;/a&gt;导出工具函数 (Exported utility functions)&lt;/h3&gt;&lt;p&gt;tolua uses itself to export some utility functions to Lua, including its object-oriented framework. The package file used by tolua is shown below:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;module tolua &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void tolua_using @ using (lua_Table module); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; char* tolua_type @ type (lua_Object lo); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void tolua_foreach @ foreach (lua_Object lo, lua_Function f); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void tolua_class @ class (lua_Table derived, lua_Table base=TOLUA_NIL); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void tolua_instance @ instance (lua_Table instance, lua_Table classobj); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; lua_Object tolua_base @ base (lua_Object lo); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;tolua-using-table&quot;&gt;&lt;a href=&quot;#tolua-using-table&quot; class=&quot;headerlink&quot; title=&quot;tolua.using (table)&quot;&gt;&lt;/a&gt;tolua.using (table)&lt;/h4&gt;&lt;p&gt;This functions receives a table and maps all its fields to the global environment. Thus we can map an entire module and access its features without the module prefix. For instance, if in our Lua code we do:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tolua.using(tolua)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;all tolua utility functions are mapped to the global environment.&lt;/p&gt;
&lt;h4 id=&quot;tolua-type-var&quot;&gt;&lt;a href=&quot;#tolua-type-var&quot; class=&quot;headerlink&quot; title=&quot;tolua.type (var)&quot;&gt;&lt;/a&gt;tolua.type (var)&lt;/h4&gt;&lt;p&gt;Returns a string representing the object type. For instance, &lt;code&gt;tolua.type(tolua)&lt;/code&gt; returns the string &lt;code&gt;generic module&lt;/code&gt; and &lt;code&gt;tolua.type(tolua.type)&lt;/code&gt; returns &lt;code&gt;cfunction&lt;/code&gt;. Similarly, if &lt;code&gt;var&lt;/code&gt; is a variable holding a user defined type &lt;code&gt;T, tolua.type(var)&lt;/code&gt; would return const &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;, depending whether it is a constant reference.&lt;/p&gt;
&lt;h4 id=&quot;tolua-tag-“type”&quot;&gt;&lt;a href=&quot;#tolua-tag-“type”&quot; class=&quot;headerlink&quot; title=&quot;tolua.tag (“type”)&quot;&gt;&lt;/a&gt;tolua.tag (“type”)&lt;/h4&gt;&lt;p&gt;Returns type corresponding tag number.&lt;/p&gt;
&lt;h4 id=&quot;tolua-foreach-object&quot;&gt;&lt;a href=&quot;#tolua-foreach-object&quot; class=&quot;headerlink&quot; title=&quot;tolua.foreach (object)&quot;&gt;&lt;/a&gt;tolua.foreach (object)&lt;/h4&gt;&lt;p&gt;Allows us to traverse the conjugate table of an user defined instance. If applied to conventional table, it has a similar behavior as the Lua built-in &lt;code&gt;foreach&lt;/code&gt; function. The difference is that this function filters all fields starting with a dot, not passing them to the provided callback function. This filter is need because tolua adds “hidden” fields to the tables it manipulates, and all its “hidden” fields start with a dot.&lt;/p&gt;
&lt;h4 id=&quot;tolua-cast-object-“typename”&quot;&gt;&lt;a href=&quot;#tolua-cast-object-“typename”&quot; class=&quot;headerlink&quot; title=&quot;tolua.cast (object, “typename”)&quot;&gt;&lt;/a&gt;tolua.cast (object, “typename”)&lt;/h4&gt;&lt;p&gt;Returns the object “casted” to the given type. The object must represent an user type, otherwise the function returns &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;tolua-takeownership-object&quot;&gt;&lt;a href=&quot;#tolua-takeownership-object&quot; class=&quot;headerlink&quot; title=&quot;tolua.takeownership (object)&quot;&gt;&lt;/a&gt;tolua.takeownership (object)&lt;/h4&gt;&lt;p&gt;Asks tolua to take the ownership of the given object. This means the C/C++ object will be freed/ destructed when garbage-collected by Lua.  The object must represent an user type, otherwise an execution error is generated.&lt;/p&gt;
&lt;h4 id=&quot;tolua-class-table-base-nil&quot;&gt;&lt;a href=&quot;#tolua-class-table-base-nil&quot; class=&quot;headerlink&quot; title=&quot;tolua.class (table, base=nil)&quot;&gt;&lt;/a&gt;tolua.class (table, base=nil)&lt;/h4&gt;&lt;p&gt;Creates a class by setting the appropriate tag methods to the given table. The created class can inherit from a base class, previously created.&lt;/p&gt;
&lt;h4 id=&quot;tolua-instance-table-class&quot;&gt;&lt;a href=&quot;#tolua-instance-table-class&quot; class=&quot;headerlink&quot; title=&quot;tolua.instance (table, class)&quot;&gt;&lt;/a&gt;tolua.instance (table, class)&lt;/h4&gt;&lt;p&gt;Sets the given table to be an instance of the given class. This and the previous utility functions allow object-oriented programming in Lua. As an example consider:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define a Point class &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;classPoint = &amp;#123; x=0, y=0 &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tolua.class(classPoint) -- set as a class&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define print method &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function classPoint:print () &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   print(self.x,self.y) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define add method &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function classPoint:add (p2) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   return Point&amp;#123;x=self.x+p2.x,y=self.y+p2.y&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define a Point constructor &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function Point (p) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   tolua.instance(p,classPoint) -- set as an instance of classPoint &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return p end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define a Color Point class &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;classColorPoint = &amp;#123; color = &amp;apos;black&amp;apos; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tolua.class(classColorPoint,classPoint) -- set as class inheriting from classPoint&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define class methods &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function classColorPoint:print () &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   print(self.x,self.y,self.color) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define Color Point constructor &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function ColorPoint (p) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   tolua.instance(p,classColorPoint) -- set as an instance of classColorPoint &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   return p &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- Some valid codes would then be &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p = Point&amp;#123;x=1&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;q = ColorPoint&amp;#123;x=2,y=3,color=2&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r = p:add(q) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r:print() --&amp;gt; would print &amp;quot;3 3&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Lua嵌入代码-Embedded-Lua-code&quot;&gt;&lt;a href=&quot;#Lua嵌入代码-Embedded-Lua-code&quot; class=&quot;headerlink&quot; title=&quot;Lua嵌入代码 (Embedded Lua code)&quot;&gt;&lt;/a&gt;Lua嵌入代码 (Embedded Lua code)&lt;/h3&gt;&lt;p&gt;tolua allows us to embed Lua code in the C/C++ generated code. To do that, it compiles the specified Lua code and creates a C constant string, storing the corresponding bytecodes, in the generated code.  When the package is opened, such a string is executed. The format to embed Lua code is:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;embedded Lua code &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;As an example consider the following .pkg excerpt:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* Bind a Point class */ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Point &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Point (int x, int y); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ~Point (); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void print (); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; CPoint;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-- Create a Point constructor &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function Point (self) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; local cobj = CPoint:new(self.x or 0, self.y or 0) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; tolua.takeownership(cobj) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; return cobj &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Binding such a code would allow us to write the following Lua code:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p = Point&amp;#123; x=2, y=3 &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p:print() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;基本步骤&quot;&gt;&lt;a href=&quot;#基本步骤&quot; class=&quot;headerlink&quot; title=&quot;基本步骤&quot;&gt;&lt;/a&gt;基本步骤&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;添加自定义类&lt;/li&gt;
&lt;li&gt;按照tolua改写规则，改写头文件(也可以在头文件加tolua能够识别的代码)生成tolua文件，这里分为两个方式，一是生成单独对应的tolua文件，二是追加到已有的tolua文件中&lt;/li&gt;
&lt;li&gt;运行脚本，生成绑定文件，根据第二步tolua生成方式的不同，生成的绑定也是两个方式：一是生成单独对应的绑定文件.h/.cpp，而是生成的内容分别追加到已有的绑定文件.h/.cpp中&lt;/li&gt;
&lt;li&gt;载入luabinding接口文件&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;项目使用Cocos2dx+lua框架做的，用到luabinding实现C++代码绑定到lua层使用，所以学习一下tolua++工具的原理和使用，在这做个记录。&lt;/p&gt;
&lt;p&gt;tolua++是tolua的扩展版本，是一款能够集成C/C++与lua代码的工具。在面向C++方面，tolua++包含了一些新的特性比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持&lt;code&gt;std::string&lt;/code&gt;作为基本类型（这个可以由一个命令行选项关闭）&lt;/li&gt;
&lt;li&gt;支持类模板&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tecgraf.puc-rio.br/~celes/tolua/&quot;&gt;tolua&lt;/a&gt;这款工具，极大的简化了C/C++代码与lua代码的集成。基于一个干净的头文件（或者从实际头文件中提取），tolua会自动生成从lua访问C/C++功能的绑定代码。使用Lua API和标记方法设施，tolua解析C/C++常数，外部变量、函数、类和方法绑定到Lua。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/&quot;&gt;官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/tolua-3.2.html&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Cocos2d-x" scheme="http://blog.keepmovingxin.com/tags/Cocos2d-x/"/>
    
      <category term="Lua" scheme="http://blog.keepmovingxin.com/tags/Lua/"/>
    
      <category term="tolua" scheme="http://blog.keepmovingxin.com/tags/tolua/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x中动态纹理CCRenderTexture的使用</title>
    <link href="http://blog.keepmovingxin.com/2016/05/09/Cocos2dx-CCRenderTexture/"/>
    <id>http://blog.keepmovingxin.com/2016/05/09/Cocos2dx-CCRenderTexture/</id>
    <published>2016-05-09T14:31:28.000Z</published>
    <updated>2016-06-06T02:18:06.000Z</updated>
    
    <content type="html">&lt;p&gt;记录一下Cocos2d-x中动态纹理&lt;code&gt;CCRenderTexture&lt;/code&gt;的各种应用，实现截屏、阴影等等&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;CCRenderTexture&lt;/code&gt;需要做以下5步:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个新的&lt;code&gt;CCRenderTexture&lt;/code&gt;. 这里，你可以指定将要创建的纹理的宽度和高度。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;CCRenderTexture:begin&lt;/code&gt;. 这个方法会启动OpenGL，并且接下来，任何绘图的命令都会渲染到&lt;code&gt;CCRenderTexture&lt;/code&gt;里面去，而不是画到屏幕上。&lt;/li&gt;
&lt;li&gt;绘制纹理. 你可以使用原始的&lt;code&gt;OpenGL&lt;/code&gt;调用来绘图，或者你也可以使用cocos2d对象里面已经定义好的&lt;code&gt;visit&lt;/code&gt;方法。（这个visit方法就会调用一些opengl命令来绘制cocos2d对象）&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;CCRenderTexture:end&lt;/code&gt;. 这个方法会渲染纹理，并且会关闭渲染至&lt;code&gt;CCRenderTexture&lt;/code&gt;的通道。&lt;/li&gt;
&lt;li&gt;从生成的纹理中创建一个&lt;code&gt;sprite&lt;/code&gt;. 你现在可以用&lt;code&gt;CCRenderTexture&lt;/code&gt;的&lt;code&gt;sprite.texture&lt;/code&gt;属性来轻松创建新的精灵了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;截取当前屏幕图片&quot;&gt;&lt;a href=&quot;#截取当前屏幕图片&quot; class=&quot;headerlink&quot; title=&quot;截取当前屏幕图片&quot;&gt;&lt;/a&gt;截取当前屏幕图片&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;--[[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @des:截取当前屏幕图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @ret:截取的图片路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function getScreenshots()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local size = CCDirector:sharedDirector():getWinSize()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local renderTexture = CCRenderTexture:create(size.width, size.height,kCCTexture2DPixelFormat_RGBA8888)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:getSprite():setAnchorPoint( ccp(0.5,0.5) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:setPosition( ccp(size.width/2, size.height/2) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:setAnchorPoint( ccp(0.5,0.5) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local runingScene = CCDirector:sharedDirector():getRunningScene()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:begin()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    runingScene:visit()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:endToLua()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local picPath = CCFileUtils:sharedFileUtils():getWritablePath() .. &amp;quot;tempScreenshots.jpg&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;截屏图片:&amp;quot;,renderTexture:saveToFile(picPath))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return picPath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绘制精灵的影子&quot;&gt;&lt;a href=&quot;#绘制精灵的影子&quot; class=&quot;headerlink&quot; title=&quot;绘制精灵的影子&quot;&gt;&lt;/a&gt;绘制精灵的影子&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;--[[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @des:根据精灵绘制影子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @par:pSprite 精灵&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @ret:shadowSprite 精灵影子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function getShadowSprite( pSprite )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local size = pSprite:getContentSize()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local renderTexture = CCRenderTexture:create(size.width, size.height,kCCTexture2DPixelFormat_RGBA8888)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:getSprite():setAnchorPoint( ccp(0.5,0.5) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:setPosition( ccp(size.width/2, size.height/2) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:setAnchorPoint( ccp(0.5,0.5) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:beginWithClear(0,0,0,0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pSprite:visit()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:endToLua()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local shadowSprite = CCSprite:createWithTexture(renderTexture:getSprite():getTexture())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return shadowSprite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绘制动态精灵&quot;&gt;&lt;a href=&quot;#绘制动态精灵&quot; class=&quot;headerlink&quot; title=&quot;绘制动态精灵&quot;&gt;&lt;/a&gt;绘制动态精灵&lt;/h3&gt;&lt;p&gt;　　注意，我们这里不是调用的&lt;code&gt;CCRenderTexture:begin&lt;/code&gt;方法，而是调用另外一个较方便的方法&lt;code&gt;beginWithClear:g:b:a:&lt;/code&gt;，这个方法可以用给定的颜色来清除纹理的背景，相当于设置画布的颜色。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(CCSprite *)spriteWithColor:(ccColor4F)bgColor textureSize:(float)textureSize &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 1: Create new CCRenderTexture&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CCRenderTexture *rt = [CCRenderTexture renderTextureWithWidth:textureSize height:textureSize];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 2: Call CCRenderTexture:begin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[rt beginWithClear:bgColor.r g:bgColor.g b:bgColor.b a:bgColor.a];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 3: Draw into the texture&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// We&amp;apos;ll add this later&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 4: Call CCRenderTexture:end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[rt end];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 5: Create a new Sprite from the texture&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return [CCSprite spriteWithTexture:rt.sprite.texture];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (ccColor4F)randomBrightColor &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (true) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        float requiredBrightness = 192;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ccColor4B randomColor = &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ccc4(arc4random() % 255,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 arc4random() % 255, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 arc4random() % 255, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 255);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (randomColor.r &amp;gt; requiredBrightness || &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            randomColor.g &amp;gt; requiredBrightness ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            randomColor.b &amp;gt; requiredBrightness) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return ccc4FFromccc4B(randomColor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)genBackground &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_background removeFromParentAndCleanup:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ccColor4F bgColor = [self randomBrightColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _background = [self spriteWithColor:bgColor textureWidth:IS_IPHONE_5 ? 1024:512 textureHeight:512];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGSize winSize = [CCDirector sharedDirector].winSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _background.position = ccp(winSize.width/2, winSize.height/2);        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self addChild:_background z:-1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void) onEnter &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super onEnter];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self genBackground];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self setTouchEnabled:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self genBackground];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;　　&lt;code&gt;randomBrightColor&lt;/code&gt;方法是一个辅助方法，用来创建一种随机颜色。注意，这里使用ccc4B（因此，我们能够在0-255的范围内指定R/G/B/A值），同时确保至少有一个颜色分量是大于192的，这样的话，我们就不会得到较暗的颜色。&lt;br&gt;　　然后，&lt;code&gt;genBackground&lt;/code&gt;调用我们之前写的&lt;code&gt;spriteWithColor&lt;/code&gt;方法，同时把它加屏幕中央。&lt;br&gt;　　至于&lt;code&gt;init&lt;/code&gt;函数，它调用&lt;code&gt;genBackground&lt;/code&gt;方法，同时激活&lt;code&gt;touches&lt;/code&gt;事件，这样的话，你就可以通过点击屏幕来获得另外的随机背景了。&lt;br&gt;　　编译并运行，这样你每一次点击屏幕，你都可以得到一张不同的单色背景图片啦！&lt;/p&gt;
&lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.raywenderlich.com/33266/how-to-create-dynamic-textures-with-ccrendertexture-in-cocos2d-2-x&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How To Create Dynamic Textures with CCRenderTexture in Cocos2D 2.X&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/andyque/archive/2011/07/01/2095479.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(译)如何使用CCRenderTexture来创建动态纹理&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下Cocos2d-x中动态纹理&lt;code&gt;CCRenderTexture&lt;/code&gt;的各种应用，实现截屏、阴影等等&lt;br&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Cocos2d-x" scheme="http://blog.keepmovingxin.com/tags/Cocos2d-x/"/>
    
  </entry>
  
  <entry>
    <title>shell学习笔记</title>
    <link href="http://blog.keepmovingxin.com/2016/05/02/Learn-shell/"/>
    <id>http://blog.keepmovingxin.com/2016/05/02/Learn-shell/</id>
    <published>2016-05-02T08:50:52.000Z</published>
    <updated>2016-06-07T03:11:28.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Shell脚本&quot;&gt;&lt;a href=&quot;#Shell脚本&quot; class=&quot;headerlink&quot; title=&quot;Shell脚本&quot;&gt;&lt;/a&gt;Shell脚本&lt;/h3&gt;&lt;h4 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;headerlink&quot; title=&quot;格式&quot;&gt;&lt;/a&gt;格式&lt;/h4&gt;&lt;p&gt;首行        &lt;code&gt;#!/bin/bash 指定解释器&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h4&gt;&lt;p&gt;&lt;code&gt;&amp;#39;#&amp;#39;&lt;/code&gt;开头的行，&lt;code&gt;&amp;#39;#!&amp;#39;&lt;/code&gt;是例外&lt;br&gt;此外，&lt;code&gt;#&lt;/code&gt; 是特殊字符，可以出现在一些参数代换结构和在数值常量表达式中，具有特殊含义，而不会开启一个注释。&lt;code&gt;‘\#’&lt;/code&gt;也不会开启一个注释。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;function funname(){…}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;funname()
{
    statements;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只需要使用函数名就可以调用某个函数：&lt;code&gt;funname&lt;/code&gt;&lt;br&gt;参数可以传递给函数，使用方法就好像函数是个新脚本一样：&lt;br&gt;&lt;code&gt;funname arg1 arg2...;    #传递参数&lt;/code&gt;&lt;br&gt;在函数中使用传入的参数：&lt;code&gt;$1&lt;/code&gt; 第一个参数；&lt;code&gt;$@&lt;/code&gt; 所有参数。&lt;br&gt;其中：&lt;code&gt;&amp;quot;$@&amp;quot;&lt;/code&gt;被扩展成&lt;code&gt;&amp;quot;$1&amp;quot;&amp;quot;$2&amp;quot;&amp;quot;$3&amp;quot;&lt;/code&gt;；&lt;br&gt;&lt;code&gt;&amp;quot;$*&amp;quot;&lt;/code&gt;被扩展成&lt;code&gt;&amp;quot;$1c$2c$3&amp;quot;&lt;/code&gt;，即一个字符串。c为IFS的第一个字符。&lt;br&gt;有时我们需要知道命令或者函数的执行状态，用$?可以查看前一个命令的返回值，如果命令成功退出，那么退出状态为0，否则非0。&lt;/p&gt;
&lt;h4 id=&quot;正文部分&quot;&gt;&lt;a href=&quot;#正文部分&quot; class=&quot;headerlink&quot; title=&quot;正文部分&quot;&gt;&lt;/a&gt;正文部分&lt;/h4&gt;&lt;p&gt;流程控制+命令&lt;/p&gt;
&lt;h4 id=&quot;执行：修改权限&quot;&gt;&lt;a href=&quot;#执行：修改权限&quot; class=&quot;headerlink&quot; title=&quot;执行：修改权限&quot;&gt;&lt;/a&gt;执行：修改权限&lt;/h4&gt;&lt;p&gt;转为可执行程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #执行脚本
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#### 流程控制条件语句&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if :&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

if condition
then
    command1 
    command2
    ...
    commandN
fi
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;```&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if `ps -ef | grep ssh`;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;then &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	echo hello; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


if else-if else :
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;if condition1&lt;br&gt;then&lt;br&gt;    command1&lt;br&gt;elif condition2&lt;br&gt;    command2&lt;br&gt;else&lt;br&gt;    commandN&lt;br&gt;fi&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
循环语句
for :
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;for var in item1 item2 … itemN&lt;br&gt;do&lt;br&gt;    command1&lt;br&gt;    command2&lt;br&gt;    …&lt;br&gt;    commandN&lt;br&gt;done&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;```for var in item1 item2 ... itemN; do command1; command2… done;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;while :&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;i=1;total=0;while [ $i -le 10 ]do    let total+=i    let i++    echo $total,$idone&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;i=1; total=0;while((i&amp;lt;=10))do    ((total+=i, i++))    echo $total,$idone&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```case语句: case语句可以用户处理自定义参数。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;case $num in&lt;br&gt;1) echo “January”;;                 #双分号结束&lt;br&gt;2) echo “Feburary”;;&lt;br&gt;5) echo “may”                          #每个case可以有多条命令&lt;br&gt;   echo “sdfd”&lt;br&gt;   echo “sdf”;;                       #但最后一条命令一定是双分号结束&lt;br&gt;&lt;em&gt;) echo “not correct input”;;       #&lt;/em&gt;）是其他值、default的意思&lt;br&gt;esac&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;

#### while read line
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;while read line; do something ; done```#### 参数处理a)	`&amp;quot;$*&amp;quot;`将所有的参数解释成一个字符串，而`&amp;quot;$@&amp;quot;`是一个参数数组。b)	Shell内建函数`getopts “:a:bc” opt`主要变量：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```$OPTIND	: 存储所处理的选项在参数列表中的位置$OPTARG	: 存储相应选项所带的参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```例子：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

while getopts &amp;quot;:a:b:cef&amp;quot; opt
do
    case $opt in
        a)echo &amp;quot;the $OPTIND has arg:$OPTARG&amp;quot;;;#$OPTIND=3
        b)echo &amp;quot;the b has arg:$OPTARG&amp;quot;;;
        c | e | f)echo &amp;quot;the $opt has no arg&amp;quot;;;
        \?)echo &amp;quot;the $opt is invalid param&amp;quot;;;
    esac
done
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;c)    &lt;code&gt;shift n&lt;/code&gt;  将位置命令左移n个&lt;/p&gt;
&lt;h4 id=&quot;条件判断&quot;&gt;&lt;a href=&quot;#条件判断&quot; class=&quot;headerlink&quot; title=&quot;条件判断&quot;&gt;&lt;/a&gt;条件判断&lt;/h4&gt;&lt;p&gt;条件判断应该放进方括号里，且方括号两边都应该留有空格。 &lt;code&gt;[  ]&lt;/code&gt;&lt;br&gt;a)    字符串判断&lt;br&gt;字符串比较时，最好用双中括号，因为有时候采用单中括号会产生错误，所以最好避开它们。&lt;code&gt;[[ $str1 = $str2 ]]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;=    当两个串有相同内容、长度时为真
!=    当串str1和str2不等时为真
-n    当串的长度大于0时为真(串非空)
-z    当串的长度为0时为真(空串)
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;b)	数值判断```-eq     两数相等为真 -ne     两数不等为真 -gt     int1大于int2为真 -ge     int1大于等于int2为真 -lt     int1小于int2为真 -le     int1小于等于int2为真&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


c)    文件判断
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;-e file         若文件存在，则为真&lt;br&gt;-d file         若文件存在且是一个目录，则为真&lt;br&gt;-b file         若文件存在且是一个块特殊文件，则为真&lt;br&gt;-c file         若文件存在且是一个字符特殊文件，则为真&lt;br&gt;-f file         若文件存在且是一个规则文件，则为真&lt;br&gt;-g file         若文件存在且设置了SGID位的值，则为真&lt;br&gt;-h file         若文件存在且为一个符合链接，则为真&lt;br&gt;-k file         若文件存在且设置了”sticky”位的值&lt;br&gt;-p file         若文件存在且为一已命名管道，则为真&lt;br&gt;-r file         若文件存在且可读，则为真&lt;br&gt;-s file         若文件存在且其大小大于零，则为真&lt;br&gt;-u file         若文件存在且设置了SUID位，则为真&lt;br&gt;-w file         若文件存在且可写，则为真&lt;br&gt;-x file         若文件存在且可执行，则为真&lt;br&gt;-o file         若文件存在且被有效用户ID所拥有，则为真&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;d)	逻辑判断`! `  非`-a`  与 `&amp;amp;&amp;amp;``-o`  或	 `||``if [ $v –ne 0 –a $v –lt 2 ]` 等价 `if [ $v –ne 0 ] &amp;amp;&amp;amp; [ $v –lt 2 ]``if [ $v –ne 0 –o $v –lt 2 ]` 等价 `if [ $v –ne 0 ] || [ $v –lt 2 ]`条件判断部分可能会变得很长，一个优化的小技巧是利用`&amp;amp;&amp;amp;`和`||`运算符。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;if condition&lt;br&gt;then&lt;br&gt;    command1&lt;br&gt;else&lt;br&gt;    command2&lt;br&gt;fi&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[ condition ] &amp;amp;&amp;amp; command1 || command2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这样就用一行代替了上面的5行而实现的功能完全相同。
如果命令有多个，可以用{}括起来，当做一个命令块。
这样可以使判断语句变得非常简洁。

#### &amp;amp;&amp;amp;、||
`cmd1 &amp;amp;&amp;amp; cmd2`
表示，当cmd1执行成功后，就执行cmd2，否则不执行。
`cmd1 || cmd2`
表示，当cmd1执行失败后，就执行cmd2，否则不执行。

### 变量
#### 系统变量
$n 该变量与脚本被激活时所带的参数相对应。n是正整数，与参数位置相对应($1,$2...) 
$? 前一个命令执行后的退出状态
$# 提供脚本的参数号
$* 所有这些参数都被双引号引住。若一个脚本接收两个参数，$*等于$1$2 
$0 正在被执行命令的名字。对于shell脚本而言，这是被激活命令的路径
$@ 所有这些参数都分别被双引号引住。若一个脚本接收到两个参数，$@等价于$1$2
$$ 当前shell的进程号。对于shell脚本，这是其正在执行时的进程ID
$! 前一个后台命令的进程号

#### 普通变量
1)    赋值：`var=value`
2)    #
获取字符串的长度。`len=${#var}`
3)    数值运算：let
let命令后面的变量不用带$，如：
`nu=10;`
`let nu+=10;    #nu=20`
但这个命令不能进行浮点数的运算。
4)    浮点数运算：bc
`echo &amp;quot;4 * 0.6&amp;quot; | bc`
bc是一个强大的计算器，还可以进项如下操作：
设定小数精度，`scale=2,eg:echo &amp;quot;scale=2;3 / 8&amp;quot; | bc`
\#.37  这是bc的特性，小于0的数，是不显示小数点前的0的。
进制转换。用ibase设定输入数字的进制，obase设定输出数字的进制。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;no=10&lt;br&gt;echo “obase=2;ibase=10;$no” | bc   #1010&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;计算平方以及平方根。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;echo “10^4” | bc        #1000    平方&lt;br&gt;echo “sqrt(100)” | bc     #10        平方根&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
#### IFS
全称是Internal Field Separtor，内部分隔符。
Shell 的环境变量分为 set, env 两种，其中 set 变量可以通过 export 工具导入到 env 变量中。其中，set 是显示设置shell变量，仅在本 shell 中有效；env 是显示设置用户环境变量 ，仅在当前会话中有效。换句话说，set 变量里包含了 env 变量，但 set 变量不一定都是 env 变量。这两种变量不同之处在于变量的作用域不同。显然，env 变量的作用域要大些，它可以在 subshell 中使用。
而 IFS 是一种 set 变量，当 shell 处理&amp;quot;命令替换&amp;quot;和&amp;quot;参数替换&amp;quot;时，shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;eg：$ cat test.txt123$ out=$(cat test.txt)$ echo $out1 2 3			#shell将(cat test.txt)的结果拆解，并用默认的分隔符（空格）重新组合，赋值给out，因此echo $out的结果不包含换行。```如果要保留`cat test.txt`中的换行符，一般情况下要做两步：1是，设定IFS为换行：`IFS=&amp;apos;\n&amp;apos;`2是，将`$(cat test.txt)`用双引号引起来，表示不用若指定IFS为换行符。#### UID特殊的环境变量，如果UID=0，表示当前以root用户运行脚本。否则不是root### 自增Linux Shell中写循环时，常常要用到变量的自增，现在总结一下整型变量自增的方法。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

1)    i=`expr $i + 1`;
2)    let i+=1;
3)    ((i++));    #双括号结构
4)    i=$[$i+1];
5)    i=$(( $i + 1 ))
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;双括号结构&quot;&gt;&lt;a href=&quot;#双括号结构&quot; class=&quot;headerlink&quot; title=&quot;双括号结构(())&quot;&gt;&lt;/a&gt;双括号结构(())&lt;/h3&gt;&lt;p&gt;双括号结构是对shell中算数及赋值运算的扩展。&lt;br&gt;语法：&lt;br&gt;((表达式1,表达式2…))&lt;/p&gt;
&lt;p&gt;特点：&lt;br&gt;1)    在双括号结构中，所有表达式可以像c语言一样，如：&lt;code&gt;a++&lt;/code&gt;,&lt;code&gt;b--&lt;/code&gt;等。&lt;br&gt;2)    在双括号结构中，所有变量可以不加入：“$”符号前缀。&lt;br&gt;3)    双括号可以进行逻辑运算，四则运算.eg. &lt;code&gt;echo $((a&amp;gt;1?2:3))&lt;/code&gt;;注意四则运算中仍然不支持浮点数运算&lt;br&gt;4)    支持多个表达式运算，各个表达式之间用“，”分开. eg:&lt;code&gt;((a+1,b++,c++))&lt;/code&gt;&lt;br&gt;5)    双括号结构 扩展了&lt;code&gt;for&lt;/code&gt;，&lt;code&gt;while&lt;/code&gt;,&lt;code&gt;if&lt;/code&gt;条件测试运算&lt;/p&gt;
&lt;h3 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h3&gt;&lt;p&gt;1)    取数组长度 – &lt;code&gt;&amp;#39;#&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arr=(1 2 3 4 5)
len=${#arr[@]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)    打印特定索引的数组元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo ${arr[2]}        #2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3)    打印出数组中的所有值-&lt;code&gt;&amp;#39;*&amp;#39;&lt;/code&gt;、&lt;code&gt;&amp;#39;@&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo ${arr[*]}
echo ${arr[@]}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;关联数组&quot;&gt;&lt;a href=&quot;#关联数组&quot; class=&quot;headerlink&quot; title=&quot;关联数组&quot;&gt;&lt;/a&gt;关联数组&lt;/h3&gt;&lt;p&gt;在关联数组中，可以用任意的文本作为数组索引。先声明才能使用&lt;br&gt;1)    声明一个关联数组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;declare –A ass_array
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)    赋值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a)    ass_array=([index1]=val1 [index2]=val2)
b)    ass_array[index1]=val1
ass_array[index2]=val2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3)    &lt;code&gt;echo ${ass_array[index1]}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4)    列出数组索引：&lt;br&gt;&lt;code&gt;echo ${!ass_array[@]}&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;临时文件或目录&quot;&gt;&lt;a href=&quot;#临时文件或目录&quot; class=&quot;headerlink&quot; title=&quot;临时文件或目录&quot;&gt;&lt;/a&gt;临时文件或目录&lt;/h3&gt;&lt;p&gt;在shell脚本中经常要保存临时的数据，如果使用认为创建临时文件用户保存临时数据，则有可能出现重名的情况，导致覆盖原来的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mktemp prefile.xxx&lt;/code&gt; 创建以prefile开头的随机文件文件，并返回文件名，指定前缀时必须包含至少3个xxx。&lt;/p&gt;
&lt;p&gt;主要参数：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-d : 创建一个目录，dirname=`mktemp -d`-u : 仅生成随机文件名，但不创建实际的文件或目录，tmpfile=`mktemp -u`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/chengmo/archive/2010/10/19/1855577.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;linux shell “(())” 双括号运算符使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Shell脚本&quot;&gt;&lt;a href=&quot;#Shell脚本&quot; class=&quot;headerlink&quot; title=&quot;Shell脚本&quot;&gt;&lt;/a&gt;Shell脚本&lt;/h3&gt;&lt;h4 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;headerlink&quot; title=&quot;格式&quot;&gt;&lt;/a&gt;格式&lt;/h4&gt;&lt;p&gt;首行        &lt;code&gt;#!/bin/bash 指定解释器&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h4&gt;&lt;p&gt;&lt;code&gt;&amp;#39;#&amp;#39;&lt;/code&gt;开头的行，&lt;code&gt;&amp;#39;#!&amp;#39;&lt;/code&gt;是例外&lt;br&gt;此外，&lt;code&gt;#&lt;/code&gt; 是特殊字符，可以出现在一些参数代换结构和在数值常量表达式中，具有特殊含义，而不会开启一个注释。&lt;code&gt;‘\#’&lt;/code&gt;也不会开启一个注释。&lt;/p&gt;
    
    </summary>
    
      <category term="工具/效率" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%88%E7%8E%87/"/>
    
    
      <category term="shell" scheme="http://blog.keepmovingxin.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>利用pngquant压缩png图片</title>
    <link href="http://blog.keepmovingxin.com/2016/04/30/pngquant-compress-png/"/>
    <id>http://blog.keepmovingxin.com/2016/04/30/pngquant-compress-png/</id>
    <published>2016-04-30T13:11:28.000Z</published>
    <updated>2016-06-06T02:18:06.000Z</updated>
    
    <content type="html">&lt;p&gt;项目包体积越来越大，为了压缩包大小找到一个比较好用的png图片压缩工具，在这记录一下。&lt;/p&gt;
&lt;h3 id=&quot;安装并配置全局变量&quot;&gt;&lt;a href=&quot;#安装并配置全局变量&quot; class=&quot;headerlink&quot; title=&quot;安装并配置全局变量&quot;&gt;&lt;/a&gt;安装并配置全局变量&lt;/h3&gt;&lt;p&gt;安装：&lt;br&gt;去官网下载压缩包 或者 源码: &lt;code&gt;git clone git://github.com/pornel/pngquant.git&lt;/code&gt;&lt;br&gt;也可以使用HomeBrew安装：&lt;code&gt;brew install pngquant&lt;/code&gt;&lt;br&gt;配置全局变量(使用HomeBrew安装请忽略)：&lt;br&gt;&lt;code&gt;ln –s /下载的位置/pngquant /usr/local/bin/pngquant&lt;/code&gt;&lt;br&gt;pngquant 可以愉快的玩耍啦！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;查看帮助信息&quot;&gt;&lt;a href=&quot;#查看帮助信息&quot; class=&quot;headerlink&quot; title=&quot;查看帮助信息&quot;&gt;&lt;/a&gt;查看帮助信息&lt;/h3&gt;&lt;p&gt;执行 pngquant -h 查看完整选项&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;--ext new.png&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设置输出图片的后缀。默认是 -or8.png 或者 -fs8.png 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--quality min-max&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使 pngquant 使用最少的颜色达到或超出 max 品质要求。如果转换结果低于 min 品质，图像不会被保存 (如果是输出到标准输出, 24-bit 原图像会被输出) 并且 pngquant 会退出并返回 99。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;min 和 max 范围在 0 (最差) 到 100 (最佳), 和 JPEG 相似。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pngquant --quality=65-80 image.png&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--speed N, -sN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;速度/质量 平衡 从 1 (强制) 到 10 (最快)。默认是 3。速度 10 相比减少图片 5% 质量, 但是 8 倍于默认的速度。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--iebug&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在 IE6 下, 只显示完全不透明的像素。pngquant 会使半透明像素以不透明方式显示并且不生产新的像素。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出版本信息。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从标准输入读取图像并输出到标准输出。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;不处理对象。允许使用文件名以 - 开头的文件。如果你在脚本中使用 pngquant , 建议在文件名前加上这个:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pngquant $OPTIONS -- &amp;quot;$FILE&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用示例&quot;&gt;&lt;a href=&quot;#使用示例&quot; class=&quot;headerlink&quot; title=&quot;使用示例&quot;&gt;&lt;/a&gt;使用示例&lt;/h3&gt;&lt;p&gt;压缩Downloads目录下所有的png，并替换当前图片&lt;br&gt;&lt;code&gt;find /Users/mac/Downloads/ -name &amp;quot;*.png&amp;quot; | while read line; do pngquant --ext .png --force $line; done&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;项目包体积越来越大，为了压缩包大小找到一个比较好用的png图片压缩工具，在这记录一下。&lt;/p&gt;
&lt;h3 id=&quot;安装并配置全局变量&quot;&gt;&lt;a href=&quot;#安装并配置全局变量&quot; class=&quot;headerlink&quot; title=&quot;安装并配置全局变量&quot;&gt;&lt;/a&gt;安装并配置全局变量&lt;/h3&gt;&lt;p&gt;安装：&lt;br&gt;去官网下载压缩包 或者 源码: &lt;code&gt;git clone git://github.com/pornel/pngquant.git&lt;/code&gt;&lt;br&gt;也可以使用HomeBrew安装：&lt;code&gt;brew install pngquant&lt;/code&gt;&lt;br&gt;配置全局变量(使用HomeBrew安装请忽略)：&lt;br&gt;&lt;code&gt;ln –s /下载的位置/pngquant /usr/local/bin/pngquant&lt;/code&gt;&lt;br&gt;pngquant 可以愉快的玩耍啦！&lt;/p&gt;
    
    </summary>
    
      <category term="工具/效率" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%88%E7%8E%87/"/>
    
    
      <category term="pngquant" scheme="http://blog.keepmovingxin.com/tags/pngquant/"/>
    
  </entry>
  
  <entry>
    <title>vi/vim显示中文字符并且去掉^M的方法</title>
    <link href="http://blog.keepmovingxin.com/2016/04/29/vi-vim-delete-M/"/>
    <id>http://blog.keepmovingxin.com/2016/04/29/vi-vim-delete-M/</id>
    <published>2016-04-29T05:39:31.000Z</published>
    <updated>2016-06-06T02:18:06.000Z</updated>
    
    <content type="html">&lt;p&gt;处理项目xml配置时vim打开经常会碰到中文显示不正常的现象，也就是传说中的乱码，搜索找到一个解决办法，记录一下，但是gbk编码的正常了，utf8的又不对了，于是稍微改了一点。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;用户目录下创建-vimrc文件&quot;&gt;&lt;a href=&quot;#用户目录下创建-vimrc文件&quot; class=&quot;headerlink&quot; title=&quot;用户目录下创建.vimrc文件&quot;&gt;&lt;/a&gt;用户目录下创建.vimrc文件&lt;/h3&gt;&lt;p&gt;加入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set fileencodings=utf-8,gb2312,gbk,gb18030
set termencoding=utf-8
set fileformats=unix
set encoding=prc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fileencodings中utf-8要在前面&lt;br&gt;这样就能正常显示中文了，配合pietty，可以完全正常显示、编辑中文了。&lt;/p&gt;
&lt;h3 id=&quot;几种去除-M的方法&quot;&gt;&lt;a href=&quot;#几种去除-M的方法&quot; class=&quot;headerlink&quot; title=&quot;几种去除^M的方法&quot;&gt;&lt;/a&gt;几种去除^M的方法&lt;/h3&gt;&lt;p&gt;1、&lt;code&gt;cat filename1 | tr -d &amp;quot;\r&amp;quot; &amp;gt; newfile&lt;/code&gt;&lt;br&gt;2、 &lt;code&gt;sed -e &amp;quot;s/^V^M//&amp;quot; filename &amp;gt; outputfilename&lt;/code&gt;&lt;br&gt;3、vi： 用vi打开文件&lt;br&gt;(1) 按ESC键&lt;br&gt;(2) 输入 :&lt;code&gt;%s/^M//g&lt;/code&gt;&lt;br&gt;确定 &lt;code&gt;^M&lt;/code&gt;是使用 &lt;code&gt;&amp;quot;CTRL-V CTRL-M&amp;quot;&lt;/code&gt; 而不是字面上的 &lt;code&gt;^M&lt;/code&gt;。&lt;br&gt;这个正则式将替换所有回车符前的 ^M为空($是为了保证^M出现在行尾)&lt;br&gt;4、用 vim 输入 :&lt;code&gt;set notextmode&lt;/code&gt;&lt;br&gt;可惜，经过上面的处理以后，^M是不存在了，但是换行不成功。所有的东西都在一行上面，看着很费劲。这说明处理的时候文件缺少”\n”，可以在替换的时候添加上即可：&lt;br&gt;&lt;code&gt;cat filename | tr &amp;quot;\r&amp;quot; &amp;quot;\n&amp;quot; &amp;gt; newfile&lt;/code&gt;&lt;br&gt;注: ^M 可以用Sublime Text编辑器查看&lt;br&gt;一些linux版本有 dos2unix 程序，可以用来祛除^M&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;处理项目xml配置时vim打开经常会碰到中文显示不正常的现象，也就是传说中的乱码，搜索找到一个解决办法，记录一下，但是gbk编码的正常了，utf8的又不对了，于是稍微改了一点。&lt;/p&gt;
    
    </summary>
    
      <category term="工具/效率" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%88%E7%8E%87/"/>
    
    
      <category term="Vim" scheme="http://blog.keepmovingxin.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令学习</title>
    <link href="http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/"/>
    <id>http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/</id>
    <published>2016-04-28T08:02:52.000Z</published>
    <updated>2016-10-09T14:01:26.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;同步时间&quot;&gt;&lt;a href=&quot;#同步时间&quot; class=&quot;headerlink&quot; title=&quot;同步时间&quot;&gt;&lt;/a&gt;同步时间&lt;/h3&gt;&lt;p&gt;以管理员身份执行如下命令，可以自动与网络时间同步：&lt;br&gt;time.nist.gov 是一个时间服务器&lt;br&gt;&lt;code&gt;$ rdate -s time.nist.gov&lt;/code&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;管道符：&quot;&gt;&lt;a href=&quot;#管道符：&quot; class=&quot;headerlink&quot; title=&quot;管道符： |&quot;&gt;&lt;/a&gt;管道符： |&lt;/h3&gt;&lt;p&gt;就是把前面的命令运行的要放入标准输出的结果丢给后面的命令&lt;br&gt;&lt;code&gt;cat 1.txt | cat&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h3&gt;&lt;p&gt;由一般字符和特殊字符（meta字符）组成&lt;br&gt;meta元字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\ 通常用于打开或关闭后续字符的特殊含义，如\(...\)与\{...\}
. 匹配任何单个字符（除NULL）
\* 匹配前面的子表达式任意次，例：a* 匹配任意多个a
? 匹配前面的子表达式零次或一次匹配前面的子表达式一次或多次。
\+ 匹配前面的子表达式一次或多次
^ 匹配输入字符串的开始位置
$ 匹配输入字符串的结束位置
[] 匹配方括号内的任一字符，其中可用连字符（-）指的连续字符的范围；^符号若出现在方括号的第一个位置，则表示匹配不在列表中的任一字符
(x|y) 匹配x或y，比如：(g|f)ood，匹配good或food
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;文件通配符&quot;&gt;&lt;a href=&quot;#文件通配符&quot; class=&quot;headerlink&quot; title=&quot;文件通配符&quot;&gt;&lt;/a&gt;文件通配符&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;\* 匹配文件名中的任何字符串，包括空字符串。
? 匹配文件名中的任何单个字符。
[...] 匹配[ ]中所包含的任何字符。可以用 – 连接，表示范围
[!...] 匹配[ ]中非 感叹号！之后的字符。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5* 5开头的所有字符串
*5 5结尾的所有字符串
*5? 以5为倒数第二个字符的字符串
[0－9] 所有以数字的字符
[1,2] 1或者2
[!0-9] 不是数字的字符
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;echo-打印&quot;&gt;&lt;a href=&quot;#echo-打印&quot; class=&quot;headerlink&quot; title=&quot;echo 打印&quot;&gt;&lt;/a&gt;echo 打印&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-n    打印语句后不会换行。
-e 开启转义，即可以打印后面的 \t,\r 等转义字符
可以打印彩色文本。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;printf-格式化输出&quot;&gt;&lt;a href=&quot;#printf-格式化输出&quot; class=&quot;headerlink&quot; title=&quot;printf 格式化输出&quot;&gt;&lt;/a&gt;printf 格式化输出&lt;/h3&gt;&lt;p&gt;用于格式化输出，使用的参数和C语言中的printf函数一样&lt;br&gt;eg：printf “%-5s %-10s %-4.2f\n” 1 James 80.9968&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-：表示左对齐，默认为右对齐
s：表示打印的是字符串
f：表示打印一个浮点数，其中4表示宽度，.2表示保留2位小数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;printf默认不带换行，需要手动添加&lt;/p&gt;
&lt;h3 id=&quot;cat-查看文件&quot;&gt;&lt;a href=&quot;#cat-查看文件&quot; class=&quot;headerlink&quot; title=&quot;cat 查看文件&quot;&gt;&lt;/a&gt;cat 查看文件&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-n：为每行前面加上行号。-n会为空白行也加上行号，-b选项则会跳过空白行。
-s：压缩相邻的空白行，即连续的空白行将压缩为一行。
-T：用^I符号表示制表符\t
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;grep-匹配&quot;&gt;&lt;a href=&quot;#grep-匹配&quot; class=&quot;headerlink&quot; title=&quot;grep 匹配&quot;&gt;&lt;/a&gt;grep 匹配&lt;/h3&gt;&lt;p&gt;grep [options] [表达式]&lt;br&gt;1)    [options]列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-c    ：只输出匹配行的统计数
-n    ：显示匹配行及行号
-A2    ：列出匹配行及下面2行
-B2    ：列出匹配行及上面2行
-C2    ：列出匹配行及上下2行
-I    ：不区分大小写(只适用于单字符)
-h    ：查询多文件时不显示文件名
-H    ：查询多文件时显示文件名（默认）
-l    ：查询多文件时只输出包含匹配字符的文件名
-o    : 每行只输出匹配部分
-s    ：不显示不存在或无匹配文本的错误信息
-v    ：显示不包含匹配文本的所有行
-r    ：递归匹配目录下所有文件及目录
-E    : 扩展grep，增加了额外的正则表达式元字符集
-e    ：指定多个匹配样式，样式间“或”的关系
-f pattern_file    ：    样式文件pattern_file中逐行存放要匹配的样式，可匹配多个样式，样式之间是“或”的关系
--color    ：    为匹配项显示不同颜色
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)    &lt;code&gt;grep –E &amp;quot;pattern1|pattern2&amp;quot; files&lt;/code&gt; ：显示匹配 pattern1 或 pattern2 的行&lt;br&gt;3)    &lt;code&gt;grep –e pattern1 –e pattern2 files&lt;/code&gt; : 匹配pattern1或pattern2&lt;br&gt;4)    &lt;code&gt;grep pattern1 files | grep pattern2&lt;/code&gt; ：显示既匹配 pattern1 又匹配 pattern2 的行&lt;br&gt;5)    &lt;code&gt;egrep &amp;quot;t_hero|t_item&amp;quot;&lt;/code&gt;   匹配t_hero或者t_item的项&lt;br&gt;6)    &lt;code&gt;grep &amp;quot;t_hero\|t_item&amp;quot;&lt;/code&gt;    可以实现与上面同样的功能&lt;/p&gt;
&lt;h3 id=&quot;sed-处理内容&quot;&gt;&lt;a href=&quot;#sed-处理内容&quot; class=&quot;headerlink&quot; title=&quot;sed 处理内容&quot;&gt;&lt;/a&gt;sed 处理内容&lt;/h3&gt;&lt;p&gt;&lt;code&gt;sed [options] &amp;#39;command&amp;#39; file(s) 或sed [options] -f scriptfile file(s)&lt;/code&gt;&lt;br&gt;一次处理一行内容 不改变文件内容&lt;br&gt;[options]列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-n    :    取消默认的输出,使用安静(silent)模式。
-r    :    使用正则表达式，及表达式中不需要进行转义
-f filename :    指定sed脚本的文件名filename
-e &amp;apos;&amp;apos; :    允许多重编辑·  
-i    :    将替换结果应用于源文件
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1)    替换字符串&lt;br&gt;&lt;code&gt;sed &amp;#39;s/pattern/string/&amp;#39; file&lt;/code&gt;&lt;br&gt;或者&lt;br&gt;&lt;code&gt;cat file | sed &amp;#39;s/pattern/string/&amp;#39;&lt;/code&gt;&lt;br&gt;2)    替换文件中所有匹配内容，使用参数g&lt;br&gt;&lt;code&gt;sed &amp;#39;s/pattern/string/g&amp;#39; file&lt;/code&gt;&lt;br&gt;但如果你想从第N处匹配开始替换，可以使用参数/Ng&lt;br&gt;&lt;code&gt;$ echo thisthisthisthis | sed &amp;#39;s/this/THIS/2g&amp;#39;
thisTHISTHISTHIS&lt;/code&gt;&lt;br&gt;3)    sed的定界符’/‘.当匹配模式中含有’/‘字符时，我们需要用’\’对定界符’/‘进行转义&lt;br&gt;&lt;code&gt;$ echo a/b | sed &amp;#39;s/a\/b/a*b/&amp;#39;
a*b&lt;/code&gt;&lt;br&gt;为了避免转义字符造成的理解困难，我们可以使用其它定界符，比如|,:,@,#,$,%,+等等&lt;br&gt;&lt;code&gt;$ echo a/b | sed &amp;#39;s:a/b:a*b:&amp;#39;
a*b&lt;/code&gt;&lt;br&gt;4)    移除匹配样式行  &lt;code&gt;sed &amp;#39;/pattern/d&amp;#39; file&lt;/code&gt;&lt;br&gt;&lt;code&gt;$ sed -r &amp;#39;/^ *$/d&amp;#39; args.txt        #移除空白行，含有一个或多个空格的行&lt;/code&gt;&lt;br&gt;5)    组合多个表达式&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ echo abd | sed &amp;apos;s/a/A/&amp;apos; | sed &amp;apos;s/d/D/&amp;apos;  #用管道组合$ echo abd | sed &amp;apos;s/a/A/;s/d/D/&amp;apos;           #用分号组合$ echo abd | sed -e &amp;apos;s/a/A/&amp;apos; -e &amp;apos;s/d/D/&amp;apos;  #用-e选项组合```6)	已匹配字符串标记（&amp;amp;）&amp;amp;代表匹配给定样式的字符串，常用于对给定样式增加[]，&amp;#123;&amp;#125;等不需要改变样式的情况```$ echo &amp;quot;this is an example&amp;quot; | sed &amp;apos;s/\w\+/[&amp;amp;]/g&amp;apos;   #\w\+ 匹配每个单词[this] [is] [an] [example]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```7)	子串匹配标记（\1）有时我们希望对匹配给定的样式标记出一些子串来，方便后续引用\(pattern\) 用于匹配子串pattern\1 用于引用第一个匹配到的子串，\n 对应第n个匹配到的子串。```$ echo 123 asd | sed &amp;apos;s/\([0-9]\+\) \([a-z]\+\)/\2+\1/&amp;apos; asd+123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```其中\1对应数字123，\2对应字母asd对于子串的引用，在样式里一定要用\(\)括起来，如果加上-r选项，则不需要转义：```$ echo 123 asd | sed -r &amp;apos;s/([0-9]+) ([a-z]+)/\2+\1/&amp;apos;asd+123```8)	引用在脚本中有用的一点，用双引号引用的sed表达式，会对表达式求值来进行扩展，如使用前面定义的变量等```$ text=hello$ echo hello world | sed &amp;quot;s/$text/HELLO/&amp;quot;HELLO world&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;tail-查看文件&quot;&gt;&lt;a href=&quot;#tail-查看文件&quot; class=&quot;headerlink&quot; title=&quot;tail 查看文件&quot;&gt;&lt;/a&gt;tail 查看文件&lt;/h3&gt;&lt;p&gt;用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件&lt;br&gt;主要参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-f ：    循环读取   #可以用在监控线上有没有报错信息
-q ：    不显示处理信息
-v ：    显示详细的处理信息
-c&amp;lt;数目&amp;gt; ：    显示的字节数
-n&amp;lt;行数&amp;gt; ：    显示行数
--pid=PID ：    与-f合用,表示在进程ID,PID死掉之后结束. 
-q, --quiet, --silent ：    从不输出给出文件名的首部
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;find-查找&quot;&gt;&lt;a href=&quot;#find-查找&quot; class=&quot;headerlink&quot; title=&quot;find 查找&quot;&gt;&lt;/a&gt;find 查找&lt;/h3&gt;&lt;p&gt;&lt;code&gt;find dir [option] &amp;#39;command&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;dir&lt;/code&gt;: 目录名，用空格隔开多个目录&lt;br&gt;1) [option]列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-name wildcard 文件名，wildcard表示通配符，并非正则式
    find dir1 dir2 -name &amp;apos;*.c&amp;apos; –print  在目录dir1和dir2中查找文件，并打印路径
    如果在-name后面紧跟一个-prune，则表示此目录应被修剪
    find . \( -name &amp;quot;.svn&amp;quot; -prune \) -o –print 表示对于查找的目录，要么修剪掉（.svn），要么打印出来（其他）。
-iname 忽略名字大小写
-path 指定目录，如果在-path前面加上 ！ ，则表示忽略此目录，目录名可以使用通配符匹配。
-type 文件类型
    f:普通文件 d:目录 l:符号连接文件 c:字符设备文件 b:块设备文件 p:管道文件
-size ±nc 查找大于（+）或小于（-）n字节的文件，注意c（charter）
-mtime ±ndays 文件最近修改时间
-user,-nouser 文件所有者
-group,-nogroup 指定文件用户组
多条件的与（-a）/或（-o）/非（！）
    find . \( -name &amp;quot;*.txt&amp;quot; –o –name &amp;quot;*.sh&amp;quot; \) –print
    括号两边应该有空格
-maxdepth n 指定最大目录深度，n=1表示最大为当前目录
-mindepth n 指定最小目录深度，n=2表示不打印当前目录下的文件
  -maxdepth和-mindepth应作为find的第三个参数出现，以提高效率
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2) ‘command’命令列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-print  打印路径名
-delete 对找到的文件进行删除 
-exec   对查找到的目标执行某一命令。
    find ${workdir} -name &amp;quot;$filename&amp;quot; -exec  |grep $uid
    -exec 参数后面跟的是bash命令，但只能跟一个命令，如果想执行多个命令，那么可以将多个命令放进一个shell脚本，然后执行这个脚本。
    bash命令的终止，使用 &amp;apos;;&amp;apos; (分号）来判定，在后面必须有一个 &amp;apos;;&amp;apos;在分号前应该加上转义字符&amp;apos;\&amp;apos;
    &amp;apos;{}&amp;apos;，使用{}来表示文件名，也就是find前面处理过程中过滤出来的文件，用于bash命令进行处理
-ok     与-exec类似，只是对查找到符合条件的目标执行一个命令前需要经过确认
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;cut-剪切&quot;&gt;&lt;a href=&quot;#cut-剪切&quot; class=&quot;headerlink&quot; title=&quot;cut 剪切&quot;&gt;&lt;/a&gt;cut 剪切&lt;/h3&gt;&lt;p&gt;&lt;code&gt;cut&lt;/code&gt; 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出，必须指定 &lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;-c&lt;/code&gt; 或&lt;code&gt;-f&lt;/code&gt; 标志之一。&lt;br&gt;主要参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-b: 以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。
-c: 以字符为单位进行分割。（单个字母等）
    cut –c2-5 file    ，表示将文件file每行的第2-5个字符作为一列显示出来。
-d: 自定义分隔符，默认为制表符。
-f: 与-d一起使用，指定显示哪个区域。
    例子：cat file.txt | cut -d&amp;apos;]&amp;apos; -f7；
        cat file.txt | cut -d&amp;apos;]&amp;apos; –f4,7；//打印4和7列
        cat file.txt | cut -d&amp;apos;]&amp;apos; –f4-7；//打印4到7列
-n: 取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的&amp;lt;br /&amp;gt;范围之内，该字符将被写出；否则，该字符将被排除。
--complement: 与-f一起使用，指定显示哪个区域的补集。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;sort-排序&quot;&gt;&lt;a href=&quot;#sort-排序&quot; class=&quot;headerlink&quot; title=&quot;sort 排序&quot;&gt;&lt;/a&gt;sort 排序&lt;/h3&gt;&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按&lt;code&gt;ASCII&lt;/code&gt;码值进行比较，最后将他们按升序输出。&lt;br&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-u: 去除重复行
-r: sort默认的排序方式是升序，如果想改成降序，用此参数
-o file: 把排序结果输出到文件file，file可以是原文件
-n: 以数值排序
-t: 指定间隔符
-k: 指定域排序，常与-t连用。sort –t &amp;apos;:&amp;apos; –k 2
    在指定域的时候还可细分，比如指定第二个域的第3个字符开始比较，用-k 2.3;
    比如指定第二个域的第3个字符到第二个域的第5个字符进行排序，用-k 2.3,2.5
    比如只指定第二个域的第3个字符进行排序，用-k 2.3,2.3
-b: 忽略每一行前面的所有空白部分，从第一个可见字符开始比较
-f: 忽略大小写进行排序
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;uniq-去重&quot;&gt;&lt;a href=&quot;#uniq-去重&quot; class=&quot;headerlink&quot; title=&quot;uniq 去重&quot;&gt;&lt;/a&gt;uniq 去重&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-c : 统计重复的行数
-u : 只显示不重复的那些行
-d : 只显示重复的那些行
-s n : 指定跳过前n个字符
-w n : 指定用于比较的最大字符数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;wc-统计&quot;&gt;&lt;a href=&quot;#wc-统计&quot; class=&quot;headerlink&quot; title=&quot;wc 统计&quot;&gt;&lt;/a&gt;wc 统计&lt;/h3&gt;&lt;p&gt;使用wc的各种选项来统计行数、单词数和字符数。&lt;br&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-l ：行数
-w ：单词数
-c ：字符数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;seq-产生整数&quot;&gt;&lt;a href=&quot;#seq-产生整数&quot; class=&quot;headerlink&quot; title=&quot;seq 产生整数&quot;&gt;&lt;/a&gt;seq 产生整数&lt;/h3&gt;&lt;p&gt;&lt;code&gt;seq A B&lt;/code&gt;: 用于产生从某个数到另外一个数之间的所有整数&lt;br&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-f：指定格式。默认是&amp;quot;%g&amp;quot;，表示按宽度为1输出。可以在g的前面加入一些字符，表示不同的含义，如：
   %2g：表示按宽度为2右对齐。
   %02g：表示按宽度为2右对齐，不足的部分用0补足。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可用于构造日志文件名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i in `seq -f &amp;quot;log.20160407&amp;quot;%02g 5 12`; do echo $i; done
   str%03g：表示按宽度为3右对齐，补足的位数用0补，并在前面加上str子串。
    %-3g：表示按宽度为3左对齐。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;mkdir-创建目录&quot;&gt;&lt;a href=&quot;#mkdir-创建目录&quot; class=&quot;headerlink&quot; title=&quot;mkdir 创建目录&quot;&gt;&lt;/a&gt;mkdir 创建目录&lt;/h3&gt;&lt;p&gt;常用参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-p: 可以是一个路径名称。此时若路径中的某些目录尚不存在，加上此选项后,系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录;
-m &amp;lt;777&amp;gt;: 模式，设定权限&amp;lt;模式&amp;gt;
-v: 在创建目录的同时输出信息。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;date-时间&quot;&gt;&lt;a href=&quot;#date-时间&quot; class=&quot;headerlink&quot; title=&quot;date 时间&quot;&gt;&lt;/a&gt;date 时间&lt;/h3&gt;&lt;p&gt;1) 显示时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date [OPTION]... [+FORMAT]
date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;  #显示当前的年月日时分秒
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2) 设置时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date -s //设置当前时间，只有root权限才能设置，其他只能查看。
date -s 20080523 //设置成20080523，这样会把具体时间设置成空00:00:00
date -s 15:20:30 //设置时间
date +%s //当前时间时间戳
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3) 转换时间&lt;br&gt;把linux下的时间戳转换成现实中的年月日时分秒&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date –d @timestamp
eg:$date -d @1433087999
 2015年 05月 31日 星期日 23:59:59 CST
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;md5sum-MD5&quot;&gt;&lt;a href=&quot;#md5sum-MD5&quot; class=&quot;headerlink&quot; title=&quot;md5sum MD5&quot;&gt;&lt;/a&gt;md5sum MD5&lt;/h3&gt;&lt;p&gt;MD5全称是报文摘要算法（Message-Digest Algorithm 5），此算法对任意长度的信息逐位进行计算，产生一个二进制长度为128位（十六进制长度32位）的“指纹”（或称“报文摘要”），即使两个文件只相差一个字符，产生的校验和也完全不同。&lt;br&gt;1) 使用md5sum来产生指纹（报文摘要）命令如下：&lt;br&gt;     &lt;code&gt;md5sum file &amp;gt; file.md5&lt;/code&gt;&lt;br&gt;若不指定文件名，则从标准输入读取，也可输出到标准输出设备，因此可与管道符“|”连用。&lt;br&gt; 可以使用文件通配符，将多个文件的md5值输出到同一个文件。&lt;br&gt;文件file.md5的内容如下：&lt;br&gt;      &lt;code&gt;c0e207c045c344ebf363c3e9a6de1076  file&lt;/code&gt;&lt;br&gt; 第一列是md5校验和，第二列是对应文件名。&lt;br&gt;2) 使用md5报文摘要验证文件。&lt;br&gt;将生成的file.md5文件放在对应file文件的同一目录下。使用如下命令验证：&lt;br&gt;     &lt;code&gt;md5sum -c file.md5&lt;/code&gt;&lt;br&gt;若验证成功，输出“file: 确定”；验证失败则输出“file: 失败”，并打印警告信息：“md5sum: 警告：1/1 生成的校验和不匹配”。&lt;/p&gt;
&lt;h3 id=&quot;ln-链接&quot;&gt;&lt;a href=&quot;#ln-链接&quot; class=&quot;headerlink&quot; title=&quot;ln 链接&quot;&gt;&lt;/a&gt;ln 链接&lt;/h3&gt;&lt;p&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-f : 链结时先将与 dist 同档名的档案删除
-d : 允许系统管理者硬链结自己的目录
-i : 在删除与 dist 同档名的档案时先进行询问
-n : 在进行软连结时，将 dist 视为一般的档案
-s : 进行软链结(symbolic link)
     ln –s target new
     为target文件建立一个软链接new指向target
-v : 在连结之前显示其档名
-b : 将在链结时会被覆写或删除的档案进行备份
-S SUFFIX : 将备份的档案都加上 SUFFIX 的字尾
-V METHOD : 指定备份的方式
--help : 显示辅助说明
--version : 显示版本
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;split-大文件切割&quot;&gt;&lt;a href=&quot;#split-大文件切割&quot; class=&quot;headerlink&quot; title=&quot;split 大文件切割&quot;&gt;&lt;/a&gt;split 大文件切割&lt;/h3&gt;&lt;p&gt; &lt;code&gt;split -b 500m file newfile_prefix&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-l：行数，指定每多少行切成一个小文件。
-b：指定每多少字就要切成一个小文件。支持单位:m,k
-C：与-b参数类似，但切割时尽量维持每行的完整性。
-d：指定切割后的文件名以数字作为后缀
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;合并： &lt;code&gt;cat newfile_prefix* &amp;gt; newfile&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;alias-别名&quot;&gt;&lt;a href=&quot;#alias-别名&quot; class=&quot;headerlink&quot; title=&quot;alias 别名&quot;&gt;&lt;/a&gt;alias 别名&lt;/h3&gt;&lt;p&gt;&lt;code&gt;alias myssh=’sh filename.sh’&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;chmod-权限&quot;&gt;&lt;a href=&quot;#chmod-权限&quot; class=&quot;headerlink&quot; title=&quot;chmod 权限&quot;&gt;&lt;/a&gt;chmod 权限&lt;/h3&gt;&lt;p&gt;使用chmod命令设置文件权限。&lt;br&gt;&lt;code&gt;chmod a+x file&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;u ： 指定用户权限
g ： 指定用户组权限
o ： 指定其他用户权限
a ： 指定所有类别
+ ： 增加权限
- ： 删除权限
r ： 可读
w ： 可写
x ： 可执行，对目录文件来说表示可访问目录中的文件和子目录
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;vim-文本编辑工具&quot;&gt;&lt;a href=&quot;#vim-文本编辑工具&quot; class=&quot;headerlink&quot; title=&quot;vim 文本编辑工具&quot;&gt;&lt;/a&gt;vim 文本编辑工具&lt;/h3&gt;&lt;p&gt;&lt;code&gt;vimdiff&lt;/code&gt; 文本差异对比&lt;br&gt;&lt;code&gt;vimdiff  FILE_LEFT  FILE_RIGHT&lt;/code&gt;&lt;br&gt;常用命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ctrl-w K 把当前窗口移到最上边
Ctrl-w H 把当前窗口移到最左边
Ctrl-w J 把当前窗口移到最下边
Ctrl-w L 把当前窗口移到最右边
Ctrl-w,w  在两个文件之间来回跳转
]c   跳转到下一差异点
[c   跳转到上一差异点，可在前面加上数字，表示跳转多少个差异
dp(diff put) 把一个差异点中当前文件的内容复制到另一个文件中
do(diff get) 另一个文件的内容复制到当前行中
:diffupdate 手工来刷新比较结果
zo(folding open) 展开被折叠的相同的文本行
zc(folding close) 重新折叠
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;paste-拼接&quot;&gt;&lt;a href=&quot;#paste-拼接&quot; class=&quot;headerlink&quot; title=&quot;paste 拼接&quot;&gt;&lt;/a&gt;paste 拼接&lt;/h3&gt;&lt;p&gt;用paste命令实现按列拼接。&lt;br&gt;&lt;code&gt;$ paste file1 file2 file3...&lt;/code&gt;&lt;br&gt;参数：&lt;br&gt;&lt;code&gt;-d：指定定界符&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;ls-列出目录&quot;&gt;&lt;a href=&quot;#ls-列出目录&quot; class=&quot;headerlink&quot; title=&quot;ls 列出目录&quot;&gt;&lt;/a&gt;ls 列出目录&lt;/h3&gt;&lt;p&gt;以下是几种方法列出当前路径下的目录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls –d */
ls –F | grep &amp;quot;/$&amp;quot;
ls –l | grep &amp;quot;^d&amp;quot;
find . –type d –maxdepth 1 –print
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;jps-显示java进程&quot;&gt;&lt;a href=&quot;#jps-显示java进程&quot; class=&quot;headerlink&quot; title=&quot;jps 显示java进程&quot;&gt;&lt;/a&gt;jps 显示java进程&lt;/h3&gt;&lt;p&gt;显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。&lt;br&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数
-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null
-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名
-v 输出传递给JVM的参数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;xargs-参数传递&quot;&gt;&lt;a href=&quot;#xargs-参数传递&quot; class=&quot;headerlink&quot; title=&quot;xargs 参数传递&quot;&gt;&lt;/a&gt;xargs 参数传递&lt;/h3&gt;&lt;p&gt;&lt;code&gt;xargs [-0opt] [-E eofstr] [-I replstr [-R replacements]] [-J replstr] [-L number] [-n number [-x]] [-P maxprocs] [-s size] [utility [argument ...]]&lt;/code&gt;&lt;br&gt;给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。&lt;br&gt;最经典应用模式：  &lt;code&gt;somecommand | xargs -item  command&lt;/code&gt;&lt;br&gt;不带&lt;code&gt;command&lt;/code&gt;，默认的使用&lt;code&gt;echo&lt;/code&gt;输出&lt;/p&gt;
&lt;p&gt;用途：&lt;br&gt;1.构造参数列表并运行命令，即将接收的参数传递给后面的&lt;code&gt;command&lt;/code&gt;命令执行&lt;br&gt;2.将多行输入转换为单行（特殊功效）&lt;/p&gt;
&lt;p&gt;优点：&lt;br&gt;1.将输入参数整理后，去除&lt;code&gt;&amp;lt;newline&amp;gt;&lt;/code&gt;换行符，以一个列表形式处理&lt;br&gt;2.避免参数过长引发的问题，使用&lt;code&gt;xargs -n&lt;/code&gt; 参数适当控制，对于经常产生大量输出的命令如&lt;code&gt;find&lt;/code&gt;、&lt;code&gt;locate&lt;/code&gt;和&lt;code&gt;grep&lt;/code&gt;来说非常有用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-item&lt;/code&gt; 代表选项:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-0      当sdtin含有特殊字元时候，将其当成一般字符，想/&amp;apos;空格等
-a file 从文件中读入作为sdtin
-e flag 注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。
-E EOF  指定输入结束符
-n num  后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。
-p      操作具有可交互性，每次执行comand都交互式提示用户选择，当每次执行一个argument的时候询问一次用户
-t      表示先打印命令，然后再执行。
-i      或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给{}，可以用{}代替。
-r      no-run-if-empty 如果没有要处理的参数传递给xargs，xargs 默认是带 空参数运行一次，如果你希望无参数时，停止 xargs，直接退出，使用 -r 选项即可，其可以防止xargs 后面命令带空参数运行报错。
-s      num xargs后面那个命令的最大命令行字符数(含空格) 
-L      从标准输入一次读取num行送给Command命令 ，-l和-L功能一样
-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符
-x      exit的意思，如果有任何 Command 行大于 -s Size 标志指定的字节数，停止运行 xargs 命令，-L -I -n 默认打开-x参数，主要是配合-s使用
-P      修改最大的进程数，默认是1，为0时候为as many as it can.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;which-查看可执行文件的位置&quot;&gt;&lt;a href=&quot;#which-查看可执行文件的位置&quot; class=&quot;headerlink&quot; title=&quot;which 查看可执行文件的位置&quot;&gt;&lt;/a&gt;which 查看可执行文件的位置&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：查找可执行文件。&lt;br&gt;&lt;strong&gt;语　　法&lt;/strong&gt;：which [文件…]&lt;br&gt;&lt;strong&gt;补充说明&lt;/strong&gt;：which指令会在环境变量$PATH设置的目录里查找符合条件的文件。&lt;br&gt;&lt;strong&gt;参　　数&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-n&amp;lt;文件名长度&amp;gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
-p&amp;lt;文件名长度&amp;gt; 　与-n参数相同，但此处的&amp;lt;文件名长度&amp;gt;包括了文件的路径。
-w 　指定输出时栏位的宽度。
-V 　显示版本信息
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;whereis-查看文件的位置&quot;&gt;&lt;a href=&quot;#whereis-查看文件的位置&quot; class=&quot;headerlink&quot; title=&quot;whereis 查看文件的位置&quot;&gt;&lt;/a&gt;whereis 查看文件的位置&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：查找文件。&lt;br&gt;&lt;strong&gt;语　　法&lt;/strong&gt;：whereis [-bfmsu][-B &amp;lt;目录&amp;gt;…][-M &amp;lt;目录&amp;gt;…][-S &amp;lt;目录&amp;gt;…][文件…]&lt;br&gt;&lt;strong&gt;补充说明&lt;/strong&gt;：whereis指令会在特定目录中查找符合条件的文件。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。&lt;br&gt;&lt;strong&gt;参　　数&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-b 　只查找二进制文件。
-B&amp;lt;目录&amp;gt; 　只在设置的目录下查找二进制文件。
-f 　不显示文件名前的路径名称。
-m 　只查找说明文件。
-M&amp;lt;目录&amp;gt; 　只在设置的目录下查找说明文件。
-s 　只查找原始代码文件。
-S&amp;lt;目录&amp;gt; 　只在设置的目录下查找原始代码文件。
-u 　查找不包含指定类型的文件。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;zip-压缩&quot;&gt;&lt;a href=&quot;#zip-压缩&quot; class=&quot;headerlink&quot; title=&quot;zip 压缩&quot;&gt;&lt;/a&gt;zip 压缩&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：文件压缩(打包)。&lt;br&gt;&lt;strong&gt;语　　法&lt;/strong&gt;：&lt;br&gt;&lt;code&gt;zip -q -r -e -m -o [yourName].zip someThing&lt;/code&gt;&lt;br&gt;&lt;strong&gt;参　　数&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-q 表示不显示压缩进度状态
-r 表示子目录子文件全部压缩为zip  //这部比较重要，不然的话只有something这个文件夹被压缩，里面的没有被压缩进去
-e 表示你的压缩文件需要加密，终端会提示你输入密码的
// 还有种加密方法，这种是直接在命令行里做的，比如zip -r -P Password01! modudu.zip SomeDir, 就直接用Password01!来加密modudu.zip了。
-m 表示压缩完删除原文件
-o 表示设置所有被压缩文件的最后修改时间为当前压缩时间
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当跨目录的时候是这么操作的&lt;br&gt;&lt;code&gt;zip -q -r -e -m -o &amp;#39;\user\someone\someDir\someFile.zip&amp;#39; &amp;#39;\users\someDir&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;scp-远程拷贝&quot;&gt;&lt;a href=&quot;#scp-远程拷贝&quot; class=&quot;headerlink&quot; title=&quot;scp 远程拷贝&quot;&gt;&lt;/a&gt;scp 远程拷贝&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：scp是secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。&lt;br&gt;&lt;strong&gt;语　　法&lt;/strong&gt;：scp [参数] [原路径] [目标路径]&lt;br&gt;&lt;strong&gt;参　　数&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-1  强制scp命令使用协议ssh1  
-2  强制scp命令使用协议ssh2  
-4  强制scp命令只使用IPv4寻址  
-6  强制scp命令只使用IPv6寻址  
-B  使用批处理模式（传输过程中不询问传输口令或短语）  
-C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）  
-p 保留原文件的修改时间，访问时间和访问权限。  
-q  不显示传输进度条。  
-r  递归复制整个目录。  
-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。   
-c cipher  以cipher将数据传输进行加密，这个选项将直接传递给ssh。   
-F ssh_config  指定一个替代的ssh配置文件，此参数直接传递给ssh。  
-i identity_file  从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。    
-l limit  限定用户所能使用的带宽，以Kbit/s为单位。     
-o ssh_option  如果习惯于使用ssh_config(5)中的参数传递方式，   
-P port  注意是大写的P, port是指定数据传输用到的端口号   
-S program  指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;实　　例&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从本地服务器复制到远程服务器： &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(1) 复制文件&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scp local_file remote_username@remote_ip:remote_folder  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或者  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scp local_file remote_username@remote_ip:remote_file  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或者  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scp local_file remote_ip:remote_folder  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或者  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scp local_file remote_ip:remote_file&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名&lt;br&gt;第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名&lt;/p&gt;
&lt;p&gt;(2) 复制目录&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scp -r local_folder remote_username@remote_ip:remote_folder  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或者  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scp -r local_folder remote_ip:remote_folder&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第1个指定了用户名，命令执行后需要输入用户密码；&lt;br&gt;第2个没有指定用户名，命令执行后需要输入用户名和密码；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从远程服务器复制到本地服务器：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(1) 从远处复制文件到本地目录&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scp root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;br&gt;从192.168.120.204机器上的/opt/soft/的目录中下载nginx-0.5.38.tar.gz 文件到本地/opt/soft/目录中&lt;/p&gt;
&lt;p&gt;(2) 从远处复制到本地&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scp -r root@192.168.120.204:/opt/soft/mongodb /opt/soft/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;br&gt;从192.168.120.204机器上的/opt/soft/中下载mongodb 目录到本地的/opt/soft/目录来。&lt;/p&gt;
&lt;p&gt;(3) 上传本地文件到远程机器指定目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scp /opt/soft/nginx-0.5.38.tar.gz root@192.168.120.204:/opt/soft/scptest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明：&lt;br&gt;上传本地目录 /opt/soft/mongodb到远程机器192.168.120.204上/opt/soft/scptest的目录中去&lt;/p&gt;
&lt;h3 id=&quot;未完待续…&quot;&gt;&lt;a href=&quot;#未完待续…&quot; class=&quot;headerlink&quot; title=&quot;未完待续…&quot;&gt;&lt;/a&gt;未完待续…&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;同步时间&quot;&gt;&lt;a href=&quot;#同步时间&quot; class=&quot;headerlink&quot; title=&quot;同步时间&quot;&gt;&lt;/a&gt;同步时间&lt;/h3&gt;&lt;p&gt;以管理员身份执行如下命令，可以自动与网络时间同步：&lt;br&gt;time.nist.gov 是一个时间服务器&lt;br&gt;&lt;code&gt;$ rdate -s time.nist.gov&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具/效率" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%88%E7%8E%87/"/>
    
    
      <category term="Linux" scheme="http://blog.keepmovingxin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x使用CCGLProgram和Shader文件实现精灵置灰</title>
    <link href="http://blog.keepmovingxin.com/2016/04/27/cocos2d-x-GraySprite/"/>
    <id>http://blog.keepmovingxin.com/2016/04/27/cocos2d-x-GraySprite/</id>
    <published>2016-04-27T09:47:46.000Z</published>
    <updated>2016-06-06T02:18:06.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;1-实现方法&quot;&gt;&lt;a href=&quot;#1-实现方法&quot; class=&quot;headerlink&quot; title=&quot;1. 实现方法&quot;&gt;&lt;/a&gt;1. 实现方法&lt;/h4&gt;&lt;p&gt;&lt;code&gt;CCGraySprite&lt;/code&gt; 继承自 &lt;code&gt;CCSprite&lt;/code&gt; 覆盖&lt;code&gt;initWithTexture&lt;/code&gt;和&lt;code&gt;draw&lt;/code&gt;方法实现置灰。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;方法和属性声明&quot;&gt;&lt;a href=&quot;#方法和属性声明&quot; class=&quot;headerlink&quot; title=&quot;方法和属性声明&quot;&gt;&lt;/a&gt;方法和属性声明&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class CCGraySprite : public CCSprite&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CCGraySprite();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    virtual ~CCGraySprite();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* create(const char* pszFileName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool initWithTexture(CCTexture2D* pTexture, const CCRect&amp;amp; tRect);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* createWithSprite(CCSprite *pSprite);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* createWithNodeAndItChild(CCNode *pNode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void setGray(bool isGray);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    virtual void draw();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool m_isGray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CCGLProgram* pProgram;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m_isGray&lt;/code&gt; 是否置灰&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pProgram&lt;/code&gt; 保存置灰的GL程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2-shader字符串&quot;&gt;&lt;a href=&quot;#2-shader字符串&quot; class=&quot;headerlink&quot; title=&quot;2. shader字符串&quot;&gt;&lt;/a&gt;2. shader字符串&lt;/h4&gt;&lt;p&gt;可以像官方那样写在一个.h文件中&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GLchar* pszFragSource = (GLchar*)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;#ifdef GL_ES \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        precision mediump float; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #endif \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uniform sampler2D u_texture; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        varying vec2 v_texCoord; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        varying vec4 v_fragmentColor; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        void main(void) \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Convert to greyscale using NTSC weightings \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vec4 col = texture2D(u_texture, v_texCoord); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        float grey = dot(col.rgb, vec3(0.299, 0.587, 0.114)); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        gl_FragColor = vec4(grey, grey, grey, col.a); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;3-核心代码&quot;&gt;&lt;a href=&quot;#3-核心代码&quot; class=&quot;headerlink&quot; title=&quot;3. 核心代码&quot;&gt;&lt;/a&gt;3. 核心代码&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;覆盖父类的&lt;code&gt;initWithTexture&lt;/code&gt;和&lt;code&gt;draw&lt;/code&gt;方法，根据&lt;code&gt;m_isGray&lt;/code&gt;调用对应GL程序进行渲染绘制精灵&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void CCGraySprite::setGray(bool isGray) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m_isGray = isGray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (isGray == true) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;setShaderProgram(pProgram);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;setShaderProgram(CCShaderCache::sharedShaderCache()-&amp;gt;programForKey(kCCShader_PositionTextureColor));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool CCGraySprite::initWithTexture(CCTexture2D* pTexture, const CCRect&amp;amp; tRect )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m_isGray = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CC_BREAK_IF(!CCSprite::initWithTexture(pTexture, tRect));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        GLchar* pszFragSource = (GLchar*)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;#ifdef GL_ES \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        precision mediump float; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #endif \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uniform sampler2D u_texture; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        varying vec2 v_texCoord; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        varying vec4 v_fragmentColor; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        void main(void) \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Convert to greyscale using NTSC weightings \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vec4 col = texture2D(u_texture, v_texCoord); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        float grey = dot(col.rgb, vec3(0.299, 0.587, 0.114)); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        gl_FragColor = vec4(grey, grey, grey, col.a); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pProgram = new CCGLProgram();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pProgram-&amp;gt;initWithVertexShaderByteArray(ccPositionTextureColor_vert, pszFragSource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;setShaderProgram(pProgram);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHECK_GL_ERROR_DEBUG();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;addAttribute(kCCAttributeNamePosition, kCCVertexAttrib_Position);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;addAttribute(kCCAttributeNameColor, kCCVertexAttrib_Color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;addAttribute(kCCAttributeNameTexCoord, kCCVertexAttrib_TexCoords);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHECK_GL_ERROR_DEBUG();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;link();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHECK_GL_ERROR_DEBUG();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;updateUniforms();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHECK_GL_ERROR_DEBUG();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; while (0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CCGraySprite::draw()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (this-&amp;gt;getTexture() == NULL) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(m_isGray == false)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CCSprite::draw();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ccGLEnableVertexAttribs(kCCVertexAttribFlag_PosColorTex );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ccGLBlendFunc( m_sBlendFunc.src, m_sBlendFunc.dst );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this-&amp;gt;getShaderProgram()-&amp;gt;use();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this-&amp;gt;getShaderProgram()-&amp;gt;setUniformsForBuiltins();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ccGLBindTexture2D( this-&amp;gt;getTexture()-&amp;gt;getName() );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#define kQuadSize sizeof(m_sQuad.bl)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long offset = (long)&amp;amp;m_sQuad;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // vertex&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int diff = offsetof( ccV3F_C4B_T2F, vertices);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    glVertexAttribPointer(kCCVertexAttrib_Position, 3, GL_FLOAT, GL_FALSE, kQuadSize, (void*) (offset + diff));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // texCoods&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    diff = offsetof( ccV3F_C4B_T2F, texCoords);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, kQuadSize, (void*)(offset + diff));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // color&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    diff = offsetof( ccV3F_C4B_T2F, colors);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_UNSIGNED_BYTE, GL_TRUE, kQuadSize, (void*)(offset + diff));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CC_INCREMENT_GL_DRAWS(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;4-lua使用示例&quot;&gt;&lt;a href=&quot;#4-lua使用示例&quot; class=&quot;headerlink&quot; title=&quot;4. lua使用示例&quot;&gt;&lt;/a&gt;4. lua使用示例&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;需手写.pkg文件，使用tolua++工具导出Lua binding文件，在AppDelegate::applicationDidFinishLaunching()注册后，方可在lua层使用&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local nameBgSp = CCGraySprite:create(&amp;quot;images/namebg.png&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local normalSp = CCSprite:create(&amp;quot;images/namebg.png&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local graySp = CCGraySprite:createWithNodeAndItChild(normalSp)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local frameSp = CCGraySprite:create(&amp;quot;images/frame.png&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frameSp:setGray(isGray)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-实现方法&quot;&gt;&lt;a href=&quot;#1-实现方法&quot; class=&quot;headerlink&quot; title=&quot;1. 实现方法&quot;&gt;&lt;/a&gt;1. 实现方法&lt;/h4&gt;&lt;p&gt;&lt;code&gt;CCGraySprite&lt;/code&gt; 继承自 &lt;code&gt;CCSprite&lt;/code&gt; 覆盖&lt;code&gt;initWithTexture&lt;/code&gt;和&lt;code&gt;draw&lt;/code&gt;方法实现置灰。&lt;br&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Cocos2d-x" scheme="http://blog.keepmovingxin.com/tags/Cocos2d-x/"/>
    
  </entry>
  
  <entry>
    <title>Git Config命令查看配置文件</title>
    <link href="http://blog.keepmovingxin.com/2016/04/27/Git-Config/"/>
    <id>http://blog.keepmovingxin.com/2016/04/27/Git-Config/</id>
    <published>2016-04-27T08:31:28.000Z</published>
    <updated>2016-06-06T02:18:06.000Z</updated>
    
    <content type="html">&lt;p&gt;git config命令的基本使用&lt;/p&gt;
&lt;h3 id=&quot;配置文件如何生效&quot;&gt;&lt;a href=&quot;#配置文件如何生效&quot; class=&quot;headerlink&quot; title=&quot;配置文件如何生效&quot;&gt;&lt;/a&gt;配置文件如何生效&lt;/h3&gt;&lt;p&gt;对于 &lt;code&gt;git&lt;/code&gt; 来说，配置文件的权重是 仓库&amp;gt;全局&amp;gt;系统。&lt;br&gt;&lt;code&gt;Git&lt;/code&gt; 会使用这一系列的配置文件来存储你定义的偏好，它首先会查找 &lt;code&gt;/etc/gitconfig&lt;/code&gt; 文件（系统级），该文件含有对系统上所有用户及他们所拥有的仓库都生效的配置值。&lt;br&gt;接下来 &lt;code&gt;Git&lt;/code&gt; 会查找每个用户的 &lt;code&gt;~/.gitconfig&lt;/code&gt; 文件（全局级）。&lt;br&gt;最后 &lt;code&gt;Git&lt;/code&gt; 会查找由用户定义的各个库中&lt;code&gt;Git&lt;/code&gt;目录下的配置文件 &lt;code&gt;.git/config&lt;/code&gt;（仓库级），该文件中的值只对当前所属仓库有效。&lt;br&gt;以上阐述的三 层配置从一般到特殊层层推进，如果定义的值有冲突，以后面层中定义的为准，例如：&lt;code&gt;.git/config&lt;/code&gt; 和 &lt;code&gt;/etc/gitconfig&lt;/code&gt; 的较量中， &lt;code&gt;.git/config&lt;/code&gt; 取得了胜利。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;使用-git-config-命令查看配置文件&quot;&gt;&lt;a href=&quot;#使用-git-config-命令查看配置文件&quot; class=&quot;headerlink&quot; title=&quot;使用 git config 命令查看配置文件&quot;&gt;&lt;/a&gt;使用 git config 命令查看配置文件&lt;/h3&gt;&lt;p&gt;命令参数–list, 简写 -l&lt;br&gt;格式：&lt;code&gt;git config [–local|–global|–system] -l&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;查看仓库级的 config，命令：git config –local -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看全局级的 config，命令：git config –global -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看系统级的 config，命令：git config –system -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看当前生效的配置，  命令：git config -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;使用-git-config-命令编辑配置文件&quot;&gt;&lt;a href=&quot;#使用-git-config-命令编辑配置文件&quot; class=&quot;headerlink&quot; title=&quot;使用 git config 命令编辑配置文件&quot;&gt;&lt;/a&gt;使用 git config 命令编辑配置文件&lt;/h3&gt;&lt;p&gt;命令参数 –edit, 简写 -e&lt;br&gt;格式：&lt;code&gt;git config [–local|–global|–system] -e&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;查看仓库级的config，命令：git config –local -e，与–list参数不同的是，git config -e默认是编辑仓库级的配置文件。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看全局级的config，命令：git config –global -e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看系统级的config，命令：git config –system -e&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行这个命令的时候，git 会用配置文件中设定的编辑器打开配置文件。&lt;/p&gt;
&lt;h3 id=&quot;增加一个配置项&quot;&gt;&lt;a href=&quot;#增加一个配置项&quot; class=&quot;headerlink&quot; title=&quot;增加一个配置项&quot;&gt;&lt;/a&gt;增加一个配置项&lt;/h3&gt;&lt;p&gt;参数 –add&lt;br&gt;格式: &lt;code&gt;git config [–local|–global|–system] –add section.key value&lt;/code&gt; (默认是添加在 local 配置中)&lt;br&gt;注意 add 后面的 section,key,value 一项都不能少，否则添加失败。比如我们执行：&lt;code&gt;git config –add man.name jim&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取一个配置项&quot;&gt;&lt;a href=&quot;#获取一个配置项&quot; class=&quot;headerlink&quot; title=&quot;获取一个配置项&quot;&gt;&lt;/a&gt;获取一个配置项&lt;/h3&gt;&lt;p&gt;有时候，我们并不需要查看所有配置的值，而是查看某个配置项的值，怎么做呢？&lt;br&gt;命令参数 –get&lt;br&gt;格式：&lt;code&gt;git config [–local|–global|–system] –get section.key&lt;/code&gt; (默认是获取 local 配置中内容) 我们先往 global 配置中写入一个 man .name=jim 的配置项，再使用 &lt;code&gt;git config –get man.name&lt;/code&gt; 看看得到的是什么&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;扫描二维码或在微信中搜索 KeepMovingXin&lt;br&gt;&lt;img src=&quot;/images/qrcode.jpg&quot; alt=&quot;欢迎关注微信公众号！&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;git config命令的基本使用&lt;/p&gt;
&lt;h3 id=&quot;配置文件如何生效&quot;&gt;&lt;a href=&quot;#配置文件如何生效&quot; class=&quot;headerlink&quot; title=&quot;配置文件如何生效&quot;&gt;&lt;/a&gt;配置文件如何生效&lt;/h3&gt;&lt;p&gt;对于 &lt;code&gt;git&lt;/code&gt; 来说，配置文件的权重是 仓库&amp;gt;全局&amp;gt;系统。&lt;br&gt;&lt;code&gt;Git&lt;/code&gt; 会使用这一系列的配置文件来存储你定义的偏好，它首先会查找 &lt;code&gt;/etc/gitconfig&lt;/code&gt; 文件（系统级），该文件含有对系统上所有用户及他们所拥有的仓库都生效的配置值。&lt;br&gt;接下来 &lt;code&gt;Git&lt;/code&gt; 会查找每个用户的 &lt;code&gt;~/.gitconfig&lt;/code&gt; 文件（全局级）。&lt;br&gt;最后 &lt;code&gt;Git&lt;/code&gt; 会查找由用户定义的各个库中&lt;code&gt;Git&lt;/code&gt;目录下的配置文件 &lt;code&gt;.git/config&lt;/code&gt;（仓库级），该文件中的值只对当前所属仓库有效。&lt;br&gt;以上阐述的三 层配置从一般到特殊层层推进，如果定义的值有冲突，以后面层中定义的为准，例如：&lt;code&gt;.git/config&lt;/code&gt; 和 &lt;code&gt;/etc/gitconfig&lt;/code&gt; 的较量中， &lt;code&gt;.git/config&lt;/code&gt; 取得了胜利。&lt;/p&gt;
    
    </summary>
    
      <category term="工具/效率" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7-%E6%95%88%E7%8E%87/"/>
    
    
      <category term="Git" scheme="http://blog.keepmovingxin.com/tags/Git/"/>
    
  </entry>
  
</feed>
