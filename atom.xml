<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KeepMoving</title>
  <subtitle>KP_小新的技术Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.keepmovingxin.com/"/>
  <updated>2016-05-17T03:34:38.000Z</updated>
  <id>http://blog.keepmovingxin.com/</id>
  
  <author>
    <name>KP_小新</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(译)tolua参考手册--accessing C/C++ code from Lua</title>
    <link href="http://blog.keepmovingxin.com/2016/05/14/Cocos2dx-tolua++/"/>
    <id>http://blog.keepmovingxin.com/2016/05/14/Cocos2dx-tolua++/</id>
    <published>2016-05-14T14:09:28.000Z</published>
    <updated>2016-05-17T03:34:38.000Z</updated>
    
    <content type="html">&lt;p&gt;项目使用Cocos2dx+lua框架做的，用到luabinding实现C++代码绑定到lua层使用，所以学习一下tolua++工具的原理和使用，在这做个记录。&lt;/p&gt;
&lt;p&gt;tolua++是tolua的扩展版本，是一款能够集成C/C++与lua代码的工具。在面向C++方面，tolua++包含了一些新的特性比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持&lt;code&gt;std::string&lt;/code&gt;作为基本类型（这个可以由一个命令行选项关闭）&lt;/li&gt;
&lt;li&gt;支持类模板&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tecgraf.puc-rio.br/~celes/tolua/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tolua&lt;/a&gt;这款工具，极大的简化了C/C++代码与lua代码的集成。基于一个干净的头文件（或者从实际头文件中提取），tolua会自动生成从lua访问C/C++功能的绑定代码。使用Lua API和标记方法设施，tolua解析C/C++常数，外部变量、函数、类和方法绑定到Lua。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/tolua-3.2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;tolua如何工作-How-tolua-works&quot;&gt;&lt;a href=&quot;#tolua如何工作-How-tolua-works&quot; class=&quot;headerlink&quot; title=&quot;tolua如何工作 (How tolua works)&quot;&gt;&lt;/a&gt;tolua如何工作 (How tolua works)&lt;/h3&gt;&lt;p&gt;使用tolua，我们需要创建一个package文件（译者注：pkg文件），即一个从C/C++实际头文件整理后的头文件，列举出我们想导出到lua环境中的那些常量、变量、函数、类以及方法，然后tolua会解析该文件并且创建自动绑定C/C++代码到lua的C/C++文件，如果将创建的文件同我们的应用链接起来，我们就可以从lua中访问指定的C/C++代码。&lt;/p&gt;
&lt;p&gt;让我们先看一些例子。如果我们指定下面的c头文件作为输入到tolua:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define FALSE 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define TRUE 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enum &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; POINT = 100, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; LINE, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; POLYGON&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object* createObejct (int type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void drawObject (Object* obj, double red, double green, double blue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int isSelected (Object* obj);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;会自动生成一个绑定上面代码到Lua层的C文件。这样，我们在lua代码里就可以访问C代码。如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myLine = createObject(LINE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if isSelected(myLine) == TRUE then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  drawObject(myLine, 1.0, 0.0, 0.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  drawObject(myLine, 1.0, 1.0, 1.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此外，考虑下面类似C++头文件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define FALSE 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define TRUE 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Shape&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void draw (void);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void draw (double red, double green, double blue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int isSelected (void);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Line : public Shape&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Line (double x1, double y1, double x2, double y2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ~Line (void);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果将上面的C++头文件输入给tolua，会自定生成一个Lua层访问C++代码的C++文件。这样，就可以使用如下Lua代码访问C++:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myLine = Line:new (0,0,1,1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if myLine:isSelected() == TRUE then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; myLine:draw(1.0,0.0,0.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; myLine:draw()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myLine:delete()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;传给tolua的package文件(.pkg)不是原本的C/C++头文件，而是手动处理过的版本。例如，外部代码访问的C++方法应该是public的，但并没有public修饰。tolua并没有实现对C/C++代码的完全解析，但它能够导出一些声明用于描述的功能到Lua层。因此，tolua将会提取出用户指定的代码以用于解析头文件。&lt;/p&gt;
&lt;h3 id=&quot;tolua的使用-How-to-use-toLua&quot;&gt;&lt;a href=&quot;#tolua的使用-How-to-use-toLua&quot; class=&quot;headerlink&quot; title=&quot;tolua的使用 (How to use toLua)&quot;&gt;&lt;/a&gt;tolua的使用 (How to use toLua)&lt;/h3&gt;&lt;p&gt;tolua由两部分代码组成：可执行程序和静态库（an executable and a library）。可执行程序用于解析，读入package文件，然后输出C/C++代码，该代码提供了从lua层访问C/C++层的绑定。如果package文件是与C++类似的代码（例如包括类的定义），就会生成一份C++代码。如果package文件是与C类似的代码（例如不包括类），就会生成一份C代码。tolua可接受一些选项。运行&lt;code&gt;tolua -h&lt;/code&gt;显示当前可接受的选项。例如，要解析一个名为&lt;code&gt;myfile.pkg&lt;/code&gt;生成一个名为&lt;code&gt;myfile.c&lt;/code&gt;的绑定代码，我们需要输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tolua -o myfile.c myfile.pkg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生成的代码必须编译并和应用程序链接，才能提供给Lua进行访问。每个被解析的文件代表导出到Lua的package。默认情况下，package的名称就是输入文件的根名称（例子中为&lt;code&gt;myfile&lt;/code&gt;），用户可以指定一个不同的名称给package：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tolua -n pkgname -o myfile.c myfile.pkg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;package还应该明确的初始化。为了从C/C++代码中初始化package，我们必须声明和调用初始化函数。初始化函数被定义为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int tolua_pkgname_open (void);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中pkgname表示绑定的package名称。如果我们使用C++，我们可以选择自动初始化：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tolua -a -n pkgname -o myfile.c myfile.pkg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当前tolua版本还导出绑定的关闭功能，可称为解绑定package：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void tolua_pkgname_close (void);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还有，&lt;code&gt;open&lt;/code&gt;和&lt;code&gt;close&lt;/code&gt;功能的原型可以输出一个头文件，通过&lt;code&gt;-H&lt;/code&gt;选项设置。&lt;/p&gt;
&lt;p&gt;tolua生成的绑定代码使用了一系列tolua库里面的函数。因此，这个库同样需要被链接到应用程序中。&lt;code&gt;tolua.h&lt;/code&gt;也是有必须要编译生成的代码。。&lt;/p&gt;
&lt;p&gt;应用程序无需绑定任何package文件也可以使用tolua的面向对象框架。在这种情况下，应用程序必须调用tolua初始化函数（此函数被任何package文件初始化函数调用）：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int tolua_open (void);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果要使用多个Lua状态(&lt;code&gt;Lua state&lt;/code&gt;)，设置一个Lua状态(&lt;code&gt;Lua state&lt;/code&gt;)后，我们需要调用一个函数来恢复tolua内部状态:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void tolua_restorestate (void);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;tolua的一些基本概念-Basic-Concepts&quot;&gt;&lt;a href=&quot;#tolua的一些基本概念-Basic-Concepts&quot; class=&quot;headerlink&quot; title=&quot;tolua的一些基本概念 (Basic Concepts)&quot;&gt;&lt;/a&gt;tolua的一些基本概念 (Basic Concepts)&lt;/h3&gt;&lt;p&gt;使用tolua的第一步就是创建package文件。我们从真正的头文件入手，将想要暴露给lua的特性转换成tolua可以理解的格式。tolua能够理解的格式就是一些简单的C/C++声明。我们从下面几个方面来讨论：&lt;/p&gt;
&lt;h4 id=&quot;文件包含&quot;&gt;&lt;a href=&quot;#文件包含&quot; class=&quot;headerlink&quot; title=&quot;文件包含&quot;&gt;&lt;/a&gt;文件包含&lt;/h4&gt;&lt;p&gt;一个package文件可以包含另外的package文件。一般格式是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$&amp;lt;include_file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;基本类型-Basic-types&quot;&gt;&lt;a href=&quot;#基本类型-Basic-types&quot; class=&quot;headerlink&quot; title=&quot;基本类型 (Basic types)&quot;&gt;&lt;/a&gt;基本类型 (Basic types)&lt;/h4&gt;&lt;p&gt;tolua会自动映射C/C++的基本类型到lua的基本类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;char&lt;/code&gt;,&lt;code&gt;int&lt;/code&gt;,&lt;code&gt;float&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;类型被映射为lua中的&lt;code&gt;number&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char*&lt;/code&gt;被映射为lua中的&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void*&lt;/code&gt;被映射为lua中的&lt;code&gt;userdata&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C/C++中的数据类型前面可能有修饰语（如unsigned, static, short, const等等）。然而我们要注意到tolua会忽略基本类型前面的修饰语const。因此，我们给lua传递一个基本类型常量然后再从lua中传递回给C/C++代码，常量到非常量的转换会被悄悄的完成。&lt;/p&gt;
&lt;p&gt;C/C++函数也可以对lua对象进行明确的操作。&lt;code&gt;lua_Object&lt;/code&gt;被认为是一个基本类型，任何lua值都符合。&lt;/p&gt;
&lt;p&gt;tolua++新特性：C++中的&lt;code&gt;string&lt;/code&gt;类型同样被认为是基本类型，会被当作值传递给lua(使用c_str()方法)。这个功能可以使用命令行选项&lt;code&gt;-S&lt;/code&gt;进行关闭。&lt;/p&gt;
&lt;h4 id=&quot;用户定义的类型-User-defined-types&quot;&gt;&lt;a href=&quot;#用户定义的类型-User-defined-types&quot; class=&quot;headerlink&quot; title=&quot;用户定义的类型 (User defined types)&quot;&gt;&lt;/a&gt;用户定义的类型 (User defined types)&lt;/h4&gt;&lt;p&gt;在package文件里的所有其他类型都会被认为是用户自定义类型。它们会映射到lua的userdata类型。lua只能存储指向用户自定义类型的指针；但是，tolua会自动采取措施来处理引用和值。例如，如果一个函数或方法返回一个用户定义类型的值，当这个值返回给lua的时候，tolua会分配一个克隆对象，同时会设置垃圾收集标记，以便在lua不再使用该对象时会自动释放。&lt;/p&gt;
&lt;p&gt;对于用户定义类型，常量是被保留的，因此将用户自定义类型的非常量作为常量传递给一个函数时，会产生类型不匹配的错误。&lt;/p&gt;
&lt;h4 id=&quot;NULL和nil-NULL-and-nil&quot;&gt;&lt;a href=&quot;#NULL和nil-NULL-and-nil&quot; class=&quot;headerlink&quot; title=&quot;NULL和nil (NULL and nil)&quot;&gt;&lt;/a&gt;NULL和nil (NULL and nil)&lt;/h4&gt;&lt;p&gt;C/C++的NULL或0指针映射到lua中的nil类型。反之，nil却可以被指定为任何C/C++指针类型。这对任何类型都有效：&lt;code&gt;char*&lt;/code&gt;, &lt;code&gt;void*&lt;/code&gt;以及用户自定义类型指针。&lt;/p&gt;
&lt;h4 id=&quot;宏定义类型-Typedefs&quot;&gt;&lt;a href=&quot;#宏定义类型-Typedefs&quot; class=&quot;headerlink&quot; title=&quot;宏定义类型 (Typedefs)&quot;&gt;&lt;/a&gt;宏定义类型 (Typedefs)&lt;/h4&gt;&lt;p&gt;tolua还接受简单类型定义的package文件。任何发生的一种定义是由tolua映射后的基类型。他们是非常有用的，因为几个包定义基本的C/C++类型自己的类型。例如，可以定义一个真正代表两个类型。在这种情况下,真正的可以用来指定变量类型package文件由tolua解释，但前提是我们包括以下定义之前使用的实际类型&lt;code&gt;real&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef double real;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;否则，&lt;code&gt;real&lt;/code&gt;将被解释为一个用户定义的类型和不会被映射到Lua数字(&lt;code&gt;numbers&lt;/code&gt;)。&lt;br&gt;包含&lt;code&gt;real&lt;/code&gt;的头文件(Including real header files)&lt;/p&gt;
&lt;p&gt;在package文件中，我们必须指定哪个是真正(&lt;code&gt;real&lt;/code&gt;)的头文件,应包含生成的代码可以访问常量,变量,函数,类具有约束。package文件中的任意行开始&lt;code&gt;$ (except $&amp;lt;...&amp;gt;, $[ , and $] lines)&lt;/code&gt;插入到生成绑定C/C++代码没有任何变化，但 &lt;code&gt;$&lt;/code&gt; 本身的消除。我们使用这个特性，包括真正(&lt;code&gt;real&lt;/code&gt;)的头文件。所以，我们的package文件通常会入手一套 &lt;code&gt;$&lt;/code&gt; 开始行指定的文件必须包括在内，也就是说，这些文件是基于package文件。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* specify the files to be included */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$#include &amp;quot;header1.h&amp;quot;                 // include first header&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$#include &amp;quot;header2.h&amp;quot;                 // include second header&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;额外说明，tolua还接受注释，使用C或C++惯例,包内的文件。也可以使用嵌套C注释。&lt;/p&gt;
&lt;p&gt;在下面几节中,我们描述了如何指定C/C++代码绑定到Lua。格式是简单有效的C/C++语句。它非常简单的将是一个真正的C/C++头文件转换成package文件。&lt;/p&gt;
&lt;h3 id=&quot;绑定常量-Binding-constants&quot;&gt;&lt;a href=&quot;#绑定常量-Binding-constants&quot; class=&quot;headerlink&quot; title=&quot;绑定常量 (Binding constants)&quot;&gt;&lt;/a&gt;绑定常量 (Binding constants)&lt;/h3&gt;&lt;p&gt;绑定常量，tolua支持两种绑定常量的方式：&lt;code&gt;define&lt;/code&gt;和 &lt;code&gt;enum&lt;/code&gt;。&lt;br&gt;&lt;code&gt;define&lt;/code&gt;通常的格式是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define NAME [ VALUE ]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的VALUE是可选的。如果这样的代码出现在被解析的文件中，tolua会将&lt;code&gt;NAME&lt;/code&gt;作为lua的全局变量，该全局变量是C/C++的常量，值为VALUE。这里只接受数字常量。&lt;/p&gt;
&lt;p&gt;tolua++新特性：所有的其他预处理指令会被忽略。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;enum&lt;/code&gt;的一般格式：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;enum &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NAME1 [ = VALUE1 ] ,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NAME2 [ = VALUE2 ] ,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NAMEn [ = VALUEn ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同样的，tolua会创建一系列全局变量，命名为&lt;code&gt;NAMEi&lt;/code&gt;，对应着各自的值。&lt;/p&gt;
&lt;h3 id=&quot;绑定外部变量-Binding-external-variables&quot;&gt;&lt;a href=&quot;#绑定外部变量-Binding-external-variables&quot; class=&quot;headerlink&quot; title=&quot;绑定外部变量 (Binding external variables)&quot;&gt;&lt;/a&gt;绑定外部变量 (Binding external variables)&lt;/h3&gt;&lt;p&gt;全局的外部变量也可以被导出。在package头文件指定为:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[extern] type var;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;tolua绑定这样的声明Lua全局变量。因此，在Lua中，我们自然地可以访问C/C++变量。如果非恒定的变量，我们也可以从Lua变量分配一个新值。全局变量表示数组的值也可以绑定到Lua。数组可以是任何类型的。相应的Lua对象数组是Lua表与数值索引；然而，请注意，指数1在Lua中映射到索引0 C/C++数组。数组必须预先设置长度。例如:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;double v[10];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绑定函数-Binding-functions&quot;&gt;&lt;a href=&quot;#绑定函数-Binding-functions&quot; class=&quot;headerlink&quot; title=&quot;绑定函数 (Binding functions)&quot;&gt;&lt;/a&gt;绑定函数 (Binding functions)&lt;/h3&gt;&lt;p&gt;Functions are also specified as conventional C/C++ declarations:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type funcname (type1 par1[, type2 par2[,...typeN parN]]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The returned type can be void, meaning no value is returned. A function can also have no parameter. In that case, void may be specified in the place of the list of parameters. The parameter types must follow the rules already posted. tolua creates a Lua function binding the C/C++ function. When calling a function from Lua, the parameter types must match the corresponding C/C++ types, otherwise, tolua generates an error and reports which parameter is wrongly specified. If a parameter name is omitted, tolua names it automatically, but its type should be a basic type or user type previously used.&lt;/p&gt;
&lt;h4 id=&quot;Arrays-数组&quot;&gt;&lt;a href=&quot;#Arrays-数组&quot; class=&quot;headerlink&quot; title=&quot;Arrays (数组)&quot;&gt;&lt;/a&gt;Arrays (数组)&lt;/h4&gt;&lt;p&gt;tolua also deals with function or method parameters that represent arrays of values. The nice thing about arrays is that the corresponding Lua tables have their values updated if the C/C++ function changes the array contents.&lt;br&gt;The arrays must be pre dimensioned. For instance:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (double a[3]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;is a valid function declaration for tolua and calling this function from Lua would be done by, for instance:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p = &amp;#123;1.0,1.5,8.6&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func (p)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The array dimension need not be a constant expression; the dimension can also be specified by any expression that can be evaluated in run time. For instance:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (int n, int m, double image[n*m]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;is also valid since the expression &lt;code&gt;n*m&lt;/code&gt; is valid in the binding function scope. However, be aware that tolua uses dynamic allocation for binding this function, what can degrade the performance.&lt;/p&gt;
&lt;p&gt;Despite the dimension specification, it is important to know that all arrays passed to the actual C/C++ function are in the local scope of the binding function. So, if the C/C++ function being called needs to hold the array pointer for later use, the binding code will not work properly.&lt;/p&gt;
&lt;h4 id=&quot;Overloaded-functions-重载函数&quot;&gt;&lt;a href=&quot;#Overloaded-functions-重载函数&quot; class=&quot;headerlink&quot; title=&quot;Overloaded functions (重载函数)&quot;&gt;&lt;/a&gt;Overloaded functions (重载函数)&lt;/h4&gt;&lt;p&gt;Overloaded functions are accepted. Remember that the distinction between two functions with the same name is made based on the parameter types that are mapped to Lua. So, although&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (int a); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void func (double a);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;represent two different functions in C++, they are the same function for tolua, because both int and double are mapped to the same Lua type: number.&lt;/p&gt;
&lt;p&gt;Another tricky situation occurs when expecting pointers. Suppose:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (char* s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void func (void* p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void func (Object1* ptr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void func (Object2* prt);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Although these four functions represent different functions in C++, a Lua statement like:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func(nil)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;matches all of them.&lt;/p&gt;
&lt;p&gt;It is important to know that tolua decides which function will be called in run-time, trying to match each provided function. tolua first tries to call the last specified function; if it fails, tolua then tries the previous one. This process is repeated until one function matches the calling code or the first function is reached. For that reason, the mismatching error message, when it occurs, is based on the first function specification. When performance is important, we can specify the most used function as the last one, because it will be tried first.&lt;/p&gt;
&lt;p&gt;tolua allows the use of overloaded functions in C, see &lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/tolua-3.2.html#renaming&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Renaming&lt;/a&gt; for details.&lt;/p&gt;
&lt;h4 id=&quot;Default-parameter-values-默认参数值&quot;&gt;&lt;a href=&quot;#Default-parameter-values-默认参数值&quot; class=&quot;headerlink&quot; title=&quot;Default parameter values (默认参数值)&quot;&gt;&lt;/a&gt;Default parameter values (默认参数值)&lt;/h4&gt;&lt;p&gt;The last function parameters can have associated default values. In that case, if the function is called with fewer parameters, the default values are assumed. The format to specify the default values is the same as the one used in C++ code:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;type funcname (..., typeN-1 parN-1 [= valueN-1], typeN parN [= valueN]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;toLua implements this feature without using any C++ mechanism; so, it can be used also to bind C functions.&lt;/p&gt;
&lt;p&gt;We can also specify default values for the elements of an array (there is no way to specify a default value for the array itself, though). For instance:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (int a[5]=0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;sets the default element values to zero, thus the function can be called from Lua with an uninitialized table.&lt;/p&gt;
&lt;p&gt;For Lua object types (lua_Object), tolua defines a constant that can be used to specify nil as default value:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void func (lua_Object lo = TOLUA_NIL);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;Multiple-returned-values-多个返回值&quot;&gt;&lt;a href=&quot;#Multiple-returned-values-多个返回值&quot; class=&quot;headerlink&quot; title=&quot;Multiple returned values (多个返回值)&quot;&gt;&lt;/a&gt;Multiple returned values (多个返回值)&lt;/h4&gt;&lt;p&gt;In Lua, a function may return any number of values. tolua uses this feature to simulate values passed by reference. If a function parameter is specified as a pointer to or reference of a basic type or a pointer to or reference of a pointer to an user defined type, tolua accepts the corresponding type as input and returns, besides the conventional function returned value, if any, the updated parameter value.&lt;/p&gt;
&lt;p&gt;For instance, consider a C function that swaps two values:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void swap (double* x, double* y);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void swap (double&amp;amp; x, double&amp;amp; y);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If such a function is declared in the package file, tolua binds it as a function receiving two numbers as input and returning two numbers. So, a valid Lua code would be:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x,y = swap(x,y)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If the input values are not used, the use of default parameter value allows calling the function from Lua without specifying them:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void getBox (double* xmin=0, double* xmax=0, double* ymin=0, double* ymax=0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In Lua:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;xmin, xmax, ymin, ymax = getBox()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;With user defined types, we would have for instance:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void update (Point** p);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void update (Point*&amp;amp; p);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绑定结构体-Binding-struct-fields&quot;&gt;&lt;a href=&quot;#绑定结构体-Binding-struct-fields&quot; class=&quot;headerlink&quot; title=&quot;绑定结构体 (Binding struct fields)&quot;&gt;&lt;/a&gt;绑定结构体 (Binding struct fields)&lt;/h3&gt;&lt;p&gt;User defined types are nicely bound by tolua. For each variable or function type that does not correspond to a basic type, tolua automatically creates a tagged userdata to represent the C/C++ type. If the type corresponds to a struct, the struct fields can be directly accessed from Lua, indexing a variable that holds an object of such a type. In C code, these types are commonly defined using typedef’s:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct [name] &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   type1 fieldname1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   type2 fieldname2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   typeN fieldnameN;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; typename;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If such a code is inserted in the package file being processed, tolua allows any variable that holds an object of type typename to access any listed field indexing the variable by the field name. For instance, if var holds a such object, &lt;code&gt;var.fieldnamei&lt;/code&gt; accesses the field named fieldnamei.&lt;/p&gt;
&lt;p&gt;Fields that represent arrays of values can also be mapped:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int x[10]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int y[10]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; Example;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绑定类和方法-Binding-classes-and-methods&quot;&gt;&lt;a href=&quot;#绑定类和方法-Binding-classes-and-methods&quot; class=&quot;headerlink&quot; title=&quot;绑定类和方法 (Binding classes and methods)&quot;&gt;&lt;/a&gt;绑定类和方法 (Binding classes and methods)&lt;/h3&gt;&lt;p&gt;C++ class definitions are also supported by tolua. Actually, the tolua deals with single inheritance and polymorphism in a natural way. The subsections below describe what can be exported by a class definition.&lt;/p&gt;
&lt;h4 id=&quot;Specifying-inheritance-指定继承&quot;&gt;&lt;a href=&quot;#Specifying-inheritance-指定继承&quot; class=&quot;headerlink&quot; title=&quot;Specifying inheritance (指定继承)&quot;&gt;&lt;/a&gt;Specifying inheritance (指定继承)&lt;/h4&gt;&lt;p&gt;If var is a Lua variable that holds an object of a derived class, var can be used wherever its base class type is expected and var can access any method of its base class. For this mechanism to take effect, we must indicate that the derived class actually inherits the base class. This is done in the conventional way:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class classname : public basename&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; /* class definition */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;Specifying-exported-members-and-methods-指定导出成员和方法&quot;&gt;&lt;a href=&quot;#Specifying-exported-members-and-methods-指定导出成员和方法&quot; class=&quot;headerlink&quot; title=&quot;Specifying exported members and methods (指定导出成员和方法)&quot;&gt;&lt;/a&gt;Specifying exported members and methods (指定导出成员和方法)&lt;/h4&gt;&lt;p&gt;As for struct fields, class fields, static or not, can be exported. Class methods and class static methods can also be exported. Of course, they must be declared as public in the actual C++ code (although the public: keyword may not appear in the package files).&lt;br&gt;For each bound class, tolua creates a Lua table and stores it at a global variable which name is the name of the C++ class. Static exported fields are accessed by indexing this table with the field names (similar to struct fields). Non static exported fields are accessed by indexing the variable that holds the object. Class methods follow the format of the function declaration showed above. They can be accessed from Lua code using the conventional way Lua uses to call methods, applied of course to a variable that holds the appropriate object or to the class table, for static methods.&lt;/p&gt;
&lt;p&gt;There are a few special methods that are also supported by tolua. Constructors are called as static methods, named new. Destructors are called as a conventional method called delete.&lt;/p&gt;
&lt;p&gt;Note that tolua does support overload. This applies even for constructors. Also note that the virtual keyword has no effect in the package file.&lt;/p&gt;
&lt;p&gt;The following code exemplifies class definitions that can be interpreted by tolua.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Point &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   static int n;    // represents the total number of created Points&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   double x;        // represents the x coordinate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   double y;        // represents the y coordinate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   static char* className (void);   // returns the name of the class&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Point (void);                          // constructor 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Point (double px, double py);          // constructor 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ~Point (void);                         // destructor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Point add (Point&amp;amp; other);              // add points, returning another one&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class ColorPoint : public Color &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int red;      // red color component [0 - 255]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int green;    // green color component [0 - 255]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int blue;     // blue color component [0 - 255]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ColorPoint (double px, double py, int r, int g, int b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If this segment of code is processed by tolua, we would be able to write the following Lua statements:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p1 = Point:new(0.0,1.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p2 = ColorPoint:new(1.5,2.2,0,0,255)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(Point.n)                     -- would print 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p3 = p1:add(p2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(p3.x,p3.y)                   -- would print 1.5 and 3.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(p2.red,p2.green,p2.blue)     -- would print 0, 0, and 255&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p1:delete()                        -- call destructor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p2:delete()                        -- call destructor&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Note that we can only explicitly delete objects that we explicitly create. In the example above, the point p3 will be garbage-collected by tolua automatically; we cannot delete it.&lt;br&gt;Of course, we need to specify only the methods and members we want to access from Lua. Sometimes, it will be necessary to declare a class with no member or method just for the sake of not breaking a chain of inheritances.&lt;/p&gt;
&lt;h4 id=&quot;Overloaded-operators（重载的运算符）&quot;&gt;&lt;a href=&quot;#Overloaded-operators（重载的运算符）&quot; class=&quot;headerlink&quot; title=&quot;Overloaded operators（重载的运算符）&quot;&gt;&lt;/a&gt;Overloaded operators（重载的运算符）&lt;/h4&gt;&lt;p&gt;tolua automatically binds the following binary operators:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;operator+   operator-   operator*   operator/ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;operator&amp;lt;   operator&amp;gt;   operator&amp;lt;=  operator&amp;gt;=&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;For the relational operators, toLua also automatically converts a returned 0 value into nil, so false in C becomes false in Lua.&lt;br&gt;As an example, suppose that in the code above, instead of having:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Point add (Point&amp;amp; other);              // add points, returning another one&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;we had:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Point operator+ (Point&amp;amp; other);        // add points, returning another one&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In that case, in Lua, we could simply write:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p3 = p1 + p2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The indexing operator (&lt;code&gt;operator[]&lt;/code&gt;) when receiving a numeric parameter can also be exported to Lua. In this case, tolua accepts reference as returned value, even for basic types. Then if a reference is returned, from Lua, the programmer can either get or set the value. If the returned value is not a reference, the programmer can only get the value. An example may clarify: suppose we have a vector class and bind the following operator:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;double&amp;amp; operator[] (int index);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In this case, in Lua, we would be able to write: &lt;code&gt;value = myVector[i]&lt;/code&gt; and also &lt;code&gt;myVector[i] = value&lt;/code&gt;, what updates the C++ object. However, if the bound operator was:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;double operator[] (int index);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;we would only be able to write: &lt;code&gt;value = myVector[i]&lt;/code&gt;.&lt;br&gt;Free functions (i.e., not class members) that overload operators are not supported.&lt;/p&gt;
&lt;h3 id=&quot;模块定义-Module-definition&quot;&gt;&lt;a href=&quot;#模块定义-Module-definition&quot; class=&quot;headerlink&quot; title=&quot;模块定义 (Module definition)&quot;&gt;&lt;/a&gt;模块定义 (Module definition)&lt;/h3&gt;&lt;p&gt;tolua allows us to group constants, variables, and functions in a module. The module itself is mapped to a table in Lua, and its constants, variables, and functions are mapped to fields in that table. The general format to specify a module is:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;module name &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ... // constant, variable, and function declarations &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Thus, if we bound the following module declaration:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;module mod &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; #define N &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; extern int var; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; int func (...): &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In Lua we would be able to access such features by indexing the module: &lt;code&gt;mod.N, mod.var, mod.func&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;命名常量、变量和函数-Renaming-constants-variables-and-functions&quot;&gt;&lt;a href=&quot;#命名常量、变量和函数-Renaming-constants-variables-and-functions&quot; class=&quot;headerlink&quot; title=&quot;命名常量、变量和函数 (Renaming constants, variables and functions)&quot;&gt;&lt;/a&gt;命名常量、变量和函数 (Renaming constants, variables and functions)&lt;/h3&gt;&lt;p&gt;When exporting constants, variable, and functions (members of a class or not), we can rename them, such that they will be bound with a different name from their C/C++ counterparts. To do that, we write the name they will be referenced in Lua after the character &lt;code&gt;@&lt;/code&gt;. For instance:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;extern int cvar @ lvar;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define CNAME @ LNAME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enum &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CITEM1 @ LITEM1, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CITEM2 @ LITEM2, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void cfunc @ lfunc (...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class T &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   double cfield @ lfield; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   void cmeth @ lmeth (...); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In such a case, the global variable &lt;code&gt;cvar&lt;/code&gt; would be identified in Lua by &lt;code&gt;lvar&lt;/code&gt;, the constant &lt;code&gt;CNAME&lt;/code&gt; by &lt;code&gt;LNAME&lt;/code&gt;, and so on. Note that class cannot be renamed, because they represent types in C.&lt;/p&gt;
&lt;p&gt;This renaming feature allows function overload in C, because we can choose to export two different C functions with a same Lua name:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void glVertex3d @ glVertex (double x, double y, double z=0.0); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void glVertexdv @ glVertex (double v[3]=0.0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;存储额外字段-Storing-additional-fields&quot;&gt;&lt;a href=&quot;#存储额外字段-Storing-additional-fields&quot; class=&quot;headerlink&quot; title=&quot;存储额外字段 (Storing additional fields)&quot;&gt;&lt;/a&gt;存储额外字段 (Storing additional fields)&lt;/h3&gt;&lt;p&gt;Finally, it is important to know that even though the variables that hold C/C++ objects are actually tagged userdata for Lua, tolua creates a mechanism that allows us to store any additional field attached to these objects. That is, these objects can be seen as conventional Lua tables.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;obj = ClassName:new()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.myfield = 1  -- even though &amp;quot;myfield&amp;quot; does not represent a field of ClassName&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Such a construction is possible because, if needed, tolua automatically creates a Lua table and associates it with the object. So that, the object can store additional fields not mapped to C/C++, but actually stored in the conjugate table. The Lua programmer accesses the C/C++ features and these additional fields in an uniform way. Note that, in fact, these additional fields overwrite C/C++ fields or methods when the names are the same.&lt;/p&gt;
&lt;h3 id=&quot;导出工具函数-Exported-utility-functions&quot;&gt;&lt;a href=&quot;#导出工具函数-Exported-utility-functions&quot; class=&quot;headerlink&quot; title=&quot;导出工具函数 (Exported utility functions)&quot;&gt;&lt;/a&gt;导出工具函数 (Exported utility functions)&lt;/h3&gt;&lt;p&gt;tolua uses itself to export some utility functions to Lua, including its object-oriented framework. The package file used by tolua is shown below:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;module tolua &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void tolua_using @ using (lua_Table module); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; char* tolua_type @ type (lua_Object lo); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void tolua_foreach @ foreach (lua_Object lo, lua_Function f); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void tolua_class @ class (lua_Table derived, lua_Table base=TOLUA_NIL); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void tolua_instance @ instance (lua_Table instance, lua_Table classobj); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; lua_Object tolua_base @ base (lua_Object lo); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;tolua-using-table&quot;&gt;&lt;a href=&quot;#tolua-using-table&quot; class=&quot;headerlink&quot; title=&quot;tolua.using (table)&quot;&gt;&lt;/a&gt;tolua.using (table)&lt;/h4&gt;&lt;p&gt;This functions receives a table and maps all its fields to the global environment. Thus we can map an entire module and access its features without the module prefix. For instance, if in our Lua code we do:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tolua.using(tolua)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;all tolua utility functions are mapped to the global environment.&lt;/p&gt;
&lt;h4 id=&quot;tolua-type-var&quot;&gt;&lt;a href=&quot;#tolua-type-var&quot; class=&quot;headerlink&quot; title=&quot;tolua.type (var)&quot;&gt;&lt;/a&gt;tolua.type (var)&lt;/h4&gt;&lt;p&gt;Returns a string representing the object type. For instance, &lt;code&gt;tolua.type(tolua)&lt;/code&gt; returns the string &lt;code&gt;generic module&lt;/code&gt; and &lt;code&gt;tolua.type(tolua.type)&lt;/code&gt; returns &lt;code&gt;cfunction&lt;/code&gt;. Similarly, if &lt;code&gt;var&lt;/code&gt; is a variable holding a user defined type &lt;code&gt;T, tolua.type(var)&lt;/code&gt; would return const &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;, depending whether it is a constant reference.&lt;/p&gt;
&lt;h4 id=&quot;tolua-tag-“type”&quot;&gt;&lt;a href=&quot;#tolua-tag-“type”&quot; class=&quot;headerlink&quot; title=&quot;tolua.tag (“type”)&quot;&gt;&lt;/a&gt;tolua.tag (“type”)&lt;/h4&gt;&lt;p&gt;Returns type corresponding tag number.&lt;/p&gt;
&lt;h4 id=&quot;tolua-foreach-object&quot;&gt;&lt;a href=&quot;#tolua-foreach-object&quot; class=&quot;headerlink&quot; title=&quot;tolua.foreach (object)&quot;&gt;&lt;/a&gt;tolua.foreach (object)&lt;/h4&gt;&lt;p&gt;Allows us to traverse the conjugate table of an user defined instance. If applied to conventional table, it has a similar behavior as the Lua built-in &lt;code&gt;foreach&lt;/code&gt; function. The difference is that this function filters all fields starting with a dot, not passing them to the provided callback function. This filter is need because tolua adds “hidden” fields to the tables it manipulates, and all its “hidden” fields start with a dot.&lt;/p&gt;
&lt;h4 id=&quot;tolua-cast-object-“typename”&quot;&gt;&lt;a href=&quot;#tolua-cast-object-“typename”&quot; class=&quot;headerlink&quot; title=&quot;tolua.cast (object, “typename”)&quot;&gt;&lt;/a&gt;tolua.cast (object, “typename”)&lt;/h4&gt;&lt;p&gt;Returns the object “casted” to the given type. The object must represent an user type, otherwise the function returns &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;tolua-takeownership-object&quot;&gt;&lt;a href=&quot;#tolua-takeownership-object&quot; class=&quot;headerlink&quot; title=&quot;tolua.takeownership (object)&quot;&gt;&lt;/a&gt;tolua.takeownership (object)&lt;/h4&gt;&lt;p&gt;Asks tolua to take the ownership of the given object. This means the C/C++ object will be freed/ destructed when garbage-collected by Lua.  The object must represent an user type, otherwise an execution error is generated.&lt;/p&gt;
&lt;h4 id=&quot;tolua-class-table-base-nil&quot;&gt;&lt;a href=&quot;#tolua-class-table-base-nil&quot; class=&quot;headerlink&quot; title=&quot;tolua.class (table, base=nil)&quot;&gt;&lt;/a&gt;tolua.class (table, base=nil)&lt;/h4&gt;&lt;p&gt;Creates a class by setting the appropriate tag methods to the given table. The created class can inherit from a base class, previously created.&lt;/p&gt;
&lt;h4 id=&quot;tolua-instance-table-class&quot;&gt;&lt;a href=&quot;#tolua-instance-table-class&quot; class=&quot;headerlink&quot; title=&quot;tolua.instance (table, class)&quot;&gt;&lt;/a&gt;tolua.instance (table, class)&lt;/h4&gt;&lt;p&gt;Sets the given table to be an instance of the given class. This and the previous utility functions allow object-oriented programming in Lua. As an example consider:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define a Point class &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;classPoint = &amp;#123; x=0, y=0 &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tolua.class(classPoint) -- set as a class&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define print method &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function classPoint:print () &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   print(self.x,self.y) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define add method &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function classPoint:add (p2) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   return Point&amp;#123;x=self.x+p2.x,y=self.y+p2.y&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define a Point constructor &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function Point (p) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   tolua.instance(p,classPoint) -- set as an instance of classPoint &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return p end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define a Color Point class &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;classColorPoint = &amp;#123; color = &amp;apos;black&amp;apos; &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tolua.class(classColorPoint,classPoint) -- set as class inheriting from classPoint&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define class methods &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function classColorPoint:print () &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   print(self.x,self.y,self.color) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- define Color Point constructor &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function ColorPoint (p) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   tolua.instance(p,classColorPoint) -- set as an instance of classColorPoint &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   return p &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- Some valid codes would then be &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p = Point&amp;#123;x=1&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;q = ColorPoint&amp;#123;x=2,y=3,color=2&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r = p:add(q) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r:print() --&amp;gt; would print &amp;quot;3 3&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Lua嵌入代码-Embedded-Lua-code&quot;&gt;&lt;a href=&quot;#Lua嵌入代码-Embedded-Lua-code&quot; class=&quot;headerlink&quot; title=&quot;Lua嵌入代码 (Embedded Lua code)&quot;&gt;&lt;/a&gt;Lua嵌入代码 (Embedded Lua code)&lt;/h3&gt;&lt;p&gt;tolua allows us to embed Lua code in the C/C++ generated code. To do that, it compiles the specified Lua code and creates a C constant string, storing the corresponding bytecodes, in the generated code.  When the package is opened, such a string is executed. The format to embed Lua code is:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;embedded Lua code &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;As an example consider the following .pkg excerpt:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* Bind a Point class */ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Point &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Point (int x, int y); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ~Point (); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; void print (); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; CPoint;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-- Create a Point constructor &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function Point (self) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; local cobj = CPoint:new(self.x or 0, self.y or 0) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; tolua.takeownership(cobj) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; return cobj &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Binding such a code would allow us to write the following Lua code:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p = Point&amp;#123; x=2, y=3 &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p:print() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;基本步骤&quot;&gt;&lt;a href=&quot;#基本步骤&quot; class=&quot;headerlink&quot; title=&quot;基本步骤&quot;&gt;&lt;/a&gt;基本步骤&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;添加自定义类&lt;/li&gt;
&lt;li&gt;按照tolua改写规则，改写头文件(也可以在头文件加tolua能够识别的代码)生成tolua文件，这里分为两个方式，一是生成单独对应的tolua文件，二是追加到已有的tolua文件中&lt;/li&gt;
&lt;li&gt;运行脚本，生成绑定文件，根据第二步tolua生成方式的不同，生成的绑定也是两个方式：一是生成单独对应的绑定文件.h/.cpp，而是生成的内容分别追加到已有的绑定文件.h/.cpp中&lt;/li&gt;
&lt;li&gt;载入luabinding接口文件&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;项目使用Cocos2dx+lua框架做的，用到luabinding实现C++代码绑定到lua层使用，所以学习一下tolua++工具的原理和使用，在这做个记录。&lt;/p&gt;
&lt;p&gt;tolua++是tolua的扩展版本，是一款能够集成C/C++与lua代码的工具。在面向C++方面，tolua++包含了一些新的特性比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持&lt;code&gt;std::string&lt;/code&gt;作为基本类型（这个可以由一个命令行选项关闭）&lt;/li&gt;
&lt;li&gt;支持类模板&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tecgraf.puc-rio.br/~celes/tolua/&quot;&gt;tolua&lt;/a&gt;这款工具，极大的简化了C/C++代码与lua代码的集成。基于一个干净的头文件（或者从实际头文件中提取），tolua会自动生成从lua访问C/C++功能的绑定代码。使用Lua API和标记方法设施，tolua解析C/C++常数，外部变量、函数、类和方法绑定到Lua。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/&quot;&gt;官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/~celes/tolua/tolua-3.2.html&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Cocos2dx" scheme="http://blog.keepmovingxin.com/tags/Cocos2dx/"/>
    
      <category term="Lua" scheme="http://blog.keepmovingxin.com/tags/Lua/"/>
    
      <category term="tolua" scheme="http://blog.keepmovingxin.com/tags/tolua/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x中动态纹理CCRenderTexture的使用</title>
    <link href="http://blog.keepmovingxin.com/2016/05/09/Cocos2dx-CCRenderTexture/"/>
    <id>http://blog.keepmovingxin.com/2016/05/09/Cocos2dx-CCRenderTexture/</id>
    <published>2016-05-09T14:31:28.000Z</published>
    <updated>2016-05-16T04:56:26.000Z</updated>
    
    <content type="html">&lt;p&gt;记录一下Cocos2d-x中动态纹理&lt;code&gt;CCRenderTexture&lt;/code&gt;的各种应用，实现截屏、阴影等等&lt;br&gt;使用&lt;code&gt;CCRenderTexture&lt;/code&gt;需要做以下5步:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个新的&lt;code&gt;CCRenderTexture&lt;/code&gt;. 这里，你可以指定将要创建的纹理的宽度和高度。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;CCRenderTexture:begin&lt;/code&gt;. 这个方法会启动OpenGL，并且接下来，任何绘图的命令都会渲染到&lt;code&gt;CCRenderTexture&lt;/code&gt;里面去，而不是画到屏幕上。&lt;/li&gt;
&lt;li&gt;绘制纹理. 你可以使用原始的&lt;code&gt;OpenGL&lt;/code&gt;调用来绘图，或者你也可以使用cocos2d对象里面已经定义好的&lt;code&gt;visit&lt;/code&gt;方法。（这个visit方法就会调用一些opengl命令来绘制cocos2d对象）&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;CCRenderTexture:end&lt;/code&gt;. 这个方法会渲染纹理，并且会关闭渲染至&lt;code&gt;CCRenderTexture&lt;/code&gt;的通道。&lt;/li&gt;
&lt;li&gt;从生成的纹理中创建一个&lt;code&gt;sprite&lt;/code&gt;. 你现在可以用&lt;code&gt;CCRenderTexture&lt;/code&gt;的&lt;code&gt;sprite.texture&lt;/code&gt;属性来轻松创建新的精灵了。&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;截取当前屏幕图片&quot;&gt;&lt;a href=&quot;#截取当前屏幕图片&quot; class=&quot;headerlink&quot; title=&quot;截取当前屏幕图片&quot;&gt;&lt;/a&gt;截取当前屏幕图片&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;--[[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @des:截取当前屏幕图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @ret:截取的图片路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function getScreenshots()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local size = CCDirector:sharedDirector():getWinSize()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local renderTexture = CCRenderTexture:create(size.width, size.height,kCCTexture2DPixelFormat_RGBA8888)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:getSprite():setAnchorPoint( ccp(0.5,0.5) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:setPosition( ccp(size.width/2, size.height/2) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:setAnchorPoint( ccp(0.5,0.5) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local runingScene = CCDirector:sharedDirector():getRunningScene()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:begin()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    runingScene:visit()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:endToLua()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local picPath = CCFileUtils:sharedFileUtils():getWritablePath() .. &amp;quot;tempScreenshots.jpg&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;截屏图片:&amp;quot;,renderTexture:saveToFile(picPath))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return picPath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绘制精灵的影子&quot;&gt;&lt;a href=&quot;#绘制精灵的影子&quot; class=&quot;headerlink&quot; title=&quot;绘制精灵的影子&quot;&gt;&lt;/a&gt;绘制精灵的影子&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;--[[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @des:根据精灵绘制影子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @par:pSprite 精灵&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @ret:shadowSprite 精灵影子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function getShadowSprite( pSprite )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local size = pSprite:getContentSize()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local renderTexture = CCRenderTexture:create(size.width, size.height,kCCTexture2DPixelFormat_RGBA8888)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:getSprite():setAnchorPoint( ccp(0.5,0.5) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:setPosition( ccp(size.width/2, size.height/2) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:setAnchorPoint( ccp(0.5,0.5) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:beginWithClear(0,0,0,0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pSprite:visit()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderTexture:endToLua()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    local shadowSprite = CCSprite:createWithTexture(renderTexture:getSprite():getTexture())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return shadowSprite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;绘制动态精灵&quot;&gt;&lt;a href=&quot;#绘制动态精灵&quot; class=&quot;headerlink&quot; title=&quot;绘制动态精灵&quot;&gt;&lt;/a&gt;绘制动态精灵&lt;/h3&gt;&lt;p&gt;　　注意，我们这里不是调用的&lt;code&gt;CCRenderTexture:begin&lt;/code&gt;方法，而是调用另外一个较方便的方法&lt;code&gt;beginWithClear:g:b:a:&lt;/code&gt;，这个方法可以用给定的颜色来清除纹理的背景，相当于设置画布的颜色。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(CCSprite *)spriteWithColor:(ccColor4F)bgColor textureSize:(float)textureSize &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 1: Create new CCRenderTexture&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CCRenderTexture *rt = [CCRenderTexture renderTextureWithWidth:textureSize height:textureSize];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 2: Call CCRenderTexture:begin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[rt beginWithClear:bgColor.r g:bgColor.g b:bgColor.b a:bgColor.a];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 3: Draw into the texture&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// We&amp;apos;ll add this later&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 4: Call CCRenderTexture:end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[rt end];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 5: Create a new Sprite from the texture&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return [CCSprite spriteWithTexture:rt.sprite.texture];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (ccColor4F)randomBrightColor &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (true) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        float requiredBrightness = 192;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ccColor4B randomColor = &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ccc4(arc4random() % 255,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 arc4random() % 255, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 arc4random() % 255, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 255);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (randomColor.r &amp;gt; requiredBrightness || &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            randomColor.g &amp;gt; requiredBrightness ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            randomColor.b &amp;gt; requiredBrightness) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return ccc4FFromccc4B(randomColor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)genBackground &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_background removeFromParentAndCleanup:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ccColor4F bgColor = [self randomBrightColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _background = [self spriteWithColor:bgColor textureWidth:IS_IPHONE_5 ? 1024:512 textureHeight:512];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGSize winSize = [CCDirector sharedDirector].winSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _background.position = ccp(winSize.width/2, winSize.height/2);        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self addChild:_background z:-1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void) onEnter &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super onEnter];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self genBackground];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self setTouchEnabled:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self genBackground];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;　　&lt;code&gt;randomBrightColor&lt;/code&gt;方法是一个辅助方法，用来创建一种随机颜色。注意，这里使用ccc4B（因此，我们能够在0-255的范围内指定R/G/B/A值），同时确保至少有一个颜色分量是大于192的，这样的话，我们就不会得到较暗的颜色。&lt;br&gt;　　然后，&lt;code&gt;genBackground&lt;/code&gt;调用我们之前写的&lt;code&gt;spriteWithColor&lt;/code&gt;方法，同时把它加屏幕中央。&lt;br&gt;　　至于&lt;code&gt;init&lt;/code&gt;函数，它调用&lt;code&gt;genBackground&lt;/code&gt;方法，同时激活&lt;code&gt;touches&lt;/code&gt;事件，这样的话，你就可以通过点击屏幕来获得另外的随机背景了。&lt;br&gt;　　编译并运行，这样你每一次点击屏幕，你都可以得到一张不同的单色背景图片啦！&lt;/p&gt;
&lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.raywenderlich.com/33266/how-to-create-dynamic-textures-with-ccrendertexture-in-cocos2d-2-x&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How To Create Dynamic Textures with CCRenderTexture in Cocos2D 2.X&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/andyque/archive/2011/07/01/2095479.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(译)如何使用CCRenderTexture来创建动态纹理&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.keepmovingxin.com/2016/05/09/Cocos2dx-CCRenderTexture/&quot;&gt;http://blog.keepmovingxin.com/2016/05/09/Cocos2dx-CCRenderTexture/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下Cocos2d-x中动态纹理&lt;code&gt;CCRenderTexture&lt;/code&gt;的各种应用，实现截屏、阴影等等&lt;br&gt;使用&lt;code&gt;CCRenderTexture&lt;/code&gt;需要做以下5步:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个新的&lt;code&gt;CCRenderTexture&lt;/code&gt;. 这里，你可以指定将要创建的纹理的宽度和高度。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;CCRenderTexture:begin&lt;/code&gt;. 这个方法会启动OpenGL，并且接下来，任何绘图的命令都会渲染到&lt;code&gt;CCRenderTexture&lt;/code&gt;里面去，而不是画到屏幕上。&lt;/li&gt;
&lt;li&gt;绘制纹理. 你可以使用原始的&lt;code&gt;OpenGL&lt;/code&gt;调用来绘图，或者你也可以使用cocos2d对象里面已经定义好的&lt;code&gt;visit&lt;/code&gt;方法。（这个visit方法就会调用一些opengl命令来绘制cocos2d对象）&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;CCRenderTexture:end&lt;/code&gt;. 这个方法会渲染纹理，并且会关闭渲染至&lt;code&gt;CCRenderTexture&lt;/code&gt;的通道。&lt;/li&gt;
&lt;li&gt;从生成的纹理中创建一个&lt;code&gt;sprite&lt;/code&gt;. 你现在可以用&lt;code&gt;CCRenderTexture&lt;/code&gt;的&lt;code&gt;sprite.texture&lt;/code&gt;属性来轻松创建新的精灵了。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Cocos2d-x" scheme="http://blog.keepmovingxin.com/tags/Cocos2d-x/"/>
    
  </entry>
  
  <entry>
    <title>shell学习笔记</title>
    <link href="http://blog.keepmovingxin.com/2016/05/02/Learn-shell/"/>
    <id>http://blog.keepmovingxin.com/2016/05/02/Learn-shell/</id>
    <published>2016-05-02T08:50:52.000Z</published>
    <updated>2016-05-03T06:01:57.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-Shell脚本&quot;&gt;&lt;a href=&quot;#1-Shell脚本&quot; class=&quot;headerlink&quot; title=&quot;1.Shell脚本&quot;&gt;&lt;/a&gt;1.Shell脚本&lt;/h3&gt;&lt;h4 id=&quot;1-1-格式&quot;&gt;&lt;a href=&quot;#1-1-格式&quot; class=&quot;headerlink&quot; title=&quot;1.1 格式&quot;&gt;&lt;/a&gt;1.1 格式&lt;/h4&gt;&lt;p&gt;首行        #!/bin/bash    指定解释器&lt;/p&gt;
&lt;h4 id=&quot;1-2-注释&quot;&gt;&lt;a href=&quot;#1-2-注释&quot; class=&quot;headerlink&quot; title=&quot;1.2 注释&quot;&gt;&lt;/a&gt;1.2 注释&lt;/h4&gt;&lt;p&gt;‘#’开头的行，’#!’是例外&lt;/p&gt;
&lt;p&gt;此外，# 是特殊字符，可以出现在一些参数代换结构和在数值常量表达式中，具有特殊含义，而不会开启一个注释。‘#’也不会开启一个注释。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;1-3-函数&quot;&gt;&lt;a href=&quot;#1-3-函数&quot; class=&quot;headerlink&quot; title=&quot;1.3 函数&quot;&gt;&lt;/a&gt;1.3 函数&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;function funname(){…}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;funname()
{
    statements;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只需要使用函数名就可以调用某个函数：&lt;code&gt;funname&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数可以传递给函数，使用方法就好像函数是个新脚本一样：&lt;/p&gt;
&lt;p&gt;funname arg1 arg2…;    #传递参数&lt;/p&gt;
&lt;p&gt;在函数中使用传入的参数：$1    第一个参数；$@ 所有参数。&lt;/p&gt;
&lt;p&gt;其中：”$@”被扩展成”$1””$2””$3”；&lt;/p&gt;
&lt;p&gt;“$*”被扩展成”$1c$2c$3”，即一个字符串。c为IFS的第一个字符。&lt;/p&gt;
&lt;p&gt;有时我们需要知道命令或者函数的执行状态，用$?可以查看前一个命令的返回值，如果命令成功退出，那么退出状态为0，否则非0。&lt;/p&gt;
&lt;h4 id=&quot;1-4-正文部分&quot;&gt;&lt;a href=&quot;#1-4-正文部分&quot; class=&quot;headerlink&quot; title=&quot;1.4 正文部分&quot;&gt;&lt;/a&gt;1.4 正文部分&lt;/h4&gt;&lt;p&gt;流程控制+命令&lt;/p&gt;
&lt;h4 id=&quot;1-5-执行：修改权限&quot;&gt;&lt;a href=&quot;#1-5-执行：修改权限&quot; class=&quot;headerlink&quot; title=&quot;1.5 执行：修改权限&quot;&gt;&lt;/a&gt;1.5 执行：修改权限&lt;/h4&gt;&lt;p&gt;转为可执行程序&lt;/p&gt;
&lt;p&gt;chmod +x ./test.sh  #使脚本具有执行权限&lt;/p&gt;
&lt;p&gt;./test.sh  #执行脚本&lt;/p&gt;
&lt;h4 id=&quot;1-6-流程控制&quot;&gt;&lt;a href=&quot;#1-6-流程控制&quot; class=&quot;headerlink&quot; title=&quot;1.6 流程控制&quot;&gt;&lt;/a&gt;1.6 流程控制&lt;/h4&gt;&lt;p&gt;条件语句&lt;/p&gt;
&lt;p&gt;if :&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if condition&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;then	command1 	command2	...	commandNfi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if `ps -ef | grep ssh`;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;then &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	echo hello; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;if else-if else :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if condition1
then
    command1
elif condition2
    command2
else
    commandN
fi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;循环语句&lt;/p&gt;
&lt;p&gt;for :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;```for var in item1 item2 ... itemN; do command1; command2… done;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

while :

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;i=1;total=0;while [ $i -le 10 ]do    let total+=i    let i++    echo $total,$idone&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;i=1; total=0;while((i&amp;lt;=10))do    ((total+=i, i++))    echo $total,$idone&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



case语句: case语句可以用户处理自定义参数。

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;case $num in1) echo &amp;quot;January&amp;quot;;;     			#双分号结束2) echo &amp;quot;Feburary&amp;quot;;;5) echo &amp;quot;may&amp;quot;          				#每个case可以有多条命令          echo &amp;quot;sdfd&amp;quot;   echo &amp;quot;sdf&amp;quot;;;       				#但最后一条命令一定是双分号结束*) echo &amp;quot;not correct input&amp;quot;;;   	#*）是其他值、default的意思esac&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```#### 1.7 while read line&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

while read line; do something ; done
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;1-8-参数处理&quot;&gt;&lt;a href=&quot;#1-8-参数处理&quot; class=&quot;headerlink&quot; title=&quot;1.8    参数处理&quot;&gt;&lt;/a&gt;1.8    参数处理&lt;/h4&gt;&lt;p&gt;a)    “$*”将所有的参数解释成一个字符串，而”$@”是一个参数数组。&lt;/p&gt;
&lt;p&gt;b)    Shell内建函数getopts “:a:bc” opt&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主要变量：

$OPTIND    :    存储所处理的选项在参数列表中的位置

$OPTARG    ：    存储相应选项所带的参数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;while getopts &amp;quot;:a:b:cef&amp;quot; optdo    case $opt in        a)echo &amp;quot;the $OPTIND has arg:$OPTARG&amp;quot;;;#$OPTIND=3        b)echo &amp;quot;the b has arg:$OPTARG&amp;quot;;;        c | e | f)echo &amp;quot;the $opt has no arg&amp;quot;;;        \?)echo &amp;quot;the $opt is invalid param&amp;quot;;;    esacdone```c)	shift n   将位置命令左移n个#### 1.9	条件判断条件判断应该放进方括号里，且方括号两边都应该留有空格。 [  ]a)	字符串判断字符串比较时，最好用双中括号，因为有时候采用单中括号会产生错误，所以最好避开它们。[[ $str1 = $str2 ]]	=			当两个串有相同内容、长度时为真	!=		　　当串str1和str2不等时为真	-n			当串的长度大于0时为真(串非空)	-z			当串的长度为0时为真(空串)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b)	数值判断	-eq     两数相等为真 	-ne     两数不等为真 	-gt     int1大于int2为真 	-ge     int1大于等于int2为真 	-lt     int1小于int2为真 	-le     int1小于等于int2为真&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c)	文件判断	-e file         若文件存在，则为真 	-d file         若文件存在且是一个目录，则为真	-b file         若文件存在且是一个块特殊文件，则为真	-c file         若文件存在且是一个字符特殊文件，则为真	-f file         若文件存在且是一个规则文件，则为真	-g file         若文件存在且设置了SGID位的值，则为真	-h file         若文件存在且为一个符合链接，则为真	-k file         若文件存在且设置了&amp;quot;sticky&amp;quot;位的值	-p file         若文件存在且为一已命名管道，则为真	-r file         若文件存在且可读，则为真	-s file         若文件存在且其大小大于零，则为真	-u file         若文件存在且设置了SUID位，则为真	-w file         若文件存在且可写，则为真	-x file         若文件存在且可执行，则为真	-o file         若文件存在且被有效用户ID所拥有，则为真&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d)	逻辑判断	!      非	-a     与		&amp;amp;&amp;amp;	-o     或		||if [ $v –ne 0 –a $v –lt 2 ] 等价 if [ $v –ne 0 ] &amp;amp;&amp;amp; [ $v –lt 2 ]if [ $v –ne 0 –o $v –lt 2 ] 等价 if [ $v –ne 0 ] || [ $v –lt 2 ]条件判断部分可能会变得很长，一个优化的小技巧是利用&amp;amp;&amp;amp;和||运算符。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;if condition&lt;br&gt;then&lt;br&gt;    command1&lt;br&gt;else&lt;br&gt;    command2&lt;br&gt;fi&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[ condition ] &amp;amp;&amp;amp; command1 || command2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这样就用一行代替了上面的5行而实现的功能完全相同。

如果命令有多个，可以用{}括起来，当做一个命令块。

这样可以使判断语句变得非常简洁。

#### 1.10 &amp;amp;&amp;amp;、||
cmd1 &amp;amp;&amp;amp; cmd2

表示，当cmd1执行成功后，就执行cmd2，否则不执行。

cmd1 || cmd2

表示，当cmd1执行失败后，就执行cmd2，否则不执行。

### 2.变量
#### 2.1 系统变量
$n      该变量与脚本被激活时所带的参数相对应。n是正整数，与参数位置相对应($1,$2...) 

$?      前一个命令执行后的退出状态

$#      提供脚本的参数号

$*      所有这些参数都被双引号引住。若一个脚本接收两个参数，$*等于$1$2 

$0      正在被执行命令的名字。对于shell脚本而言，这是被激活命令的路径

$@      所有这些参数都分别被双引号引住。若一个脚本接收到两个参数，$@等价于$1$2

$$      当前shell的进程号。对于shell脚本，这是其正在执行时的进程ID

$!      前一个后台命令的进程号

#### 2.2    普通变量

1)    赋值：var=value

2)    #

获取字符串的长度。len=${#var}

3)    数值运算：let

let命令后面的变量不用带$，如：

nu=10;

let nu+=10;    #nu=20

但这个命令不能进行浮点数的运算。

4)    浮点数运算：bc

echo &amp;quot;4 * 0.6&amp;quot; | bc

bc是一个强大的计算器，还可以进项如下操作：

设定小数精度，`scale=2,eg:echo &amp;quot;scale=2;3 / 8&amp;quot; | bc`

\#.37  这是bc的特性，小于0的数，是不显示小数点前的0的。


进制转换。用ibase设定输入数字的进制，obase设定输出数字的进制。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;no=10&lt;br&gt;echo “obase=2;ibase=10;$no” | bc   #1010&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;计算平方以及平方根。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;echo “10^4” | bc        #1000    平方&lt;br&gt;echo “sqrt(100)” | bc     #10        平方根&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#### 2.3 IFS
全称是Internal Field Separtor，内部分隔符。

Shell 的环境变量分为 set, env 两种，其中 set 变量可以通过 export 工具导入到 env 变量中。其中，set 是显示设置shell变量，仅在本 shell 中有效；env 是显示设置用户环境变量 ，仅在当前会话中有效。换句话说，set 变量里包含了 env 变量，但 set 变量不一定都是 env 变量。这两种变量不同之处在于变量的作用域不同。显然，env 变量的作用域要大些，它可以在 subshell 中使用。

而 IFS 是一种 set 变量，当 shell 处理&amp;quot;命令替换&amp;quot;和&amp;quot;参数替换&amp;quot;时，shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。

&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;eg：$ cat test.txt123$ out=$(cat test.txt)$ echo $out1 2 3			#shell将(cat test.txt)的结果拆解，并用默认的分隔符（空格）重新组合，赋值给out，因此echo $out的结果不包含换行。```如果要保留cat test.txt中的换行符，一般情况下要做两步：1是，设定IFS为换行：IFS=&amp;apos;\n&amp;apos;2是，将$(cat test.txt)用双引号引起来，表示不用若指定IFS为换行符。#### 2.4 UID特殊的环境变量，如果UID=0，表示当前以root用户运行脚本。否则不是root### 3.自增Linux Shell中写循环时，常常要用到变量的自增，现在总结一下整型变量自增的方法。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

1)    i=`expr $i + 1`;
2)    let i+=1;
3)    ((i++));    #双括号结构
http://www.cnblogs.com/chengmo/archive/2010/10/19/1855577.html
4)    i=$[$i+1];
5)    i=$(( $i + 1 ))
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;4-双括号结构&quot;&gt;&lt;a href=&quot;#4-双括号结构&quot; class=&quot;headerlink&quot; title=&quot;4.双括号结构(())&quot;&gt;&lt;/a&gt;4.双括号结构(())&lt;/h3&gt;&lt;p&gt;双括号结构是对shell中算数及赋值运算的扩展。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;((表达式1,表达式2…))&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;p&gt;1)    在双括号结构中，所有表达式可以像c语言一样，如：a++,b–等。&lt;/p&gt;
&lt;p&gt;2)    在双括号结构中，所有变量可以不加入：“$”符号前缀。&lt;/p&gt;
&lt;p&gt;3)    双括号可以进行逻辑运算，四则运算.eg. echo $((a&amp;gt;1?2:3));注意四则运算中仍然不支持浮点数运算&lt;/p&gt;
&lt;p&gt;4)    支持多个表达式运算，各个表达式之间用“，”分开. eg:((a+1,b++,c++))&lt;/p&gt;
&lt;p&gt;5)    双括号结构 扩展了for，while,if条件测试运算&lt;/p&gt;
&lt;h3 id=&quot;5-数组&quot;&gt;&lt;a href=&quot;#5-数组&quot; class=&quot;headerlink&quot; title=&quot;5.数组&quot;&gt;&lt;/a&gt;5.数组&lt;/h3&gt;&lt;p&gt;1)    取数组长度 – ‘#’&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arr=(1 2 3 4 5)
len=${#arr[@]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)    打印特定索引的数组元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo ${arr[2]}        #2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3)    打印出数组中的所有值-‘*’、’@’&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo ${arr[*]}
echo ${arr[@]}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;6-关联数组&quot;&gt;&lt;a href=&quot;#6-关联数组&quot; class=&quot;headerlink&quot; title=&quot;6.关联数组&quot;&gt;&lt;/a&gt;6.关联数组&lt;/h3&gt;&lt;p&gt;在关联数组中，可以用任意的文本作为数组索引。先声明才能使用&lt;/p&gt;
&lt;p&gt;1)    声明一个关联数组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;declare –A ass_array
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)    赋值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a)    ass_array=([index1]=val1 [index2]=val2)
b)    ass_array[index1]=val1
ass_array[index2]=val2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3)    &lt;code&gt;echo ${ass_array[index1]}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4)    列出数组索引：&lt;br&gt;&lt;code&gt;echo ${!ass_array[@]}&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;7-临时文件或目录&quot;&gt;&lt;a href=&quot;#7-临时文件或目录&quot; class=&quot;headerlink&quot; title=&quot;7.临时文件或目录&quot;&gt;&lt;/a&gt;7.临时文件或目录&lt;/h3&gt;&lt;p&gt;在shell脚本中经常要保存临时的数据，如果使用认为创建临时文件用户保存临时数据，则有可能出现重名的情况，导致覆盖原来的数据。&lt;/p&gt;
&lt;p&gt;mktemp prefile.xxx    创建以prefile开头的随机文件文件，并返回文件名，指定前缀时必须包含至少3个xxx。&lt;/p&gt;
&lt;p&gt;主要参数：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-d	：	创建一个目录，dirname=`mktemp -d`-u	:	仅生成随机文件名，但不创建实际的文件或目录，tmpfile=`mktemp -u`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;———–&lt;br&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.keepmovingxin.com/2016/05/02/Learn-shell/&quot;&gt;http://blog.keepmovingxin.com/2016/05/02/Learn-shell/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Shell脚本&quot;&gt;&lt;a href=&quot;#1-Shell脚本&quot; class=&quot;headerlink&quot; title=&quot;1.Shell脚本&quot;&gt;&lt;/a&gt;1.Shell脚本&lt;/h3&gt;&lt;h4 id=&quot;1-1-格式&quot;&gt;&lt;a href=&quot;#1-1-格式&quot; class=&quot;headerlink&quot; title=&quot;1.1 格式&quot;&gt;&lt;/a&gt;1.1 格式&lt;/h4&gt;&lt;p&gt;首行        #!/bin/bash    指定解释器&lt;/p&gt;
&lt;h4 id=&quot;1-2-注释&quot;&gt;&lt;a href=&quot;#1-2-注释&quot; class=&quot;headerlink&quot; title=&quot;1.2 注释&quot;&gt;&lt;/a&gt;1.2 注释&lt;/h4&gt;&lt;p&gt;‘#’开头的行，’#!’是例外&lt;/p&gt;
&lt;p&gt;此外，# 是特殊字符，可以出现在一些参数代换结构和在数值常量表达式中，具有特殊含义，而不会开启一个注释。‘#’也不会开启一个注释。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="http://blog.keepmovingxin.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>利用pngquant压缩png图片</title>
    <link href="http://blog.keepmovingxin.com/2016/04/30/pngquant-compress-png/"/>
    <id>http://blog.keepmovingxin.com/2016/04/30/pngquant-compress-png/</id>
    <published>2016-04-30T13:11:28.000Z</published>
    <updated>2016-05-03T02:10:31.000Z</updated>
    
    <content type="html">&lt;p&gt;项目包体积越来越大，为了压缩包大小找到一个比较好用的png图片压缩工具，在这记录一下。&lt;/p&gt;
&lt;h3 id=&quot;安装并配置全局变量&quot;&gt;&lt;a href=&quot;#安装并配置全局变量&quot; class=&quot;headerlink&quot; title=&quot;安装并配置全局变量&quot;&gt;&lt;/a&gt;安装并配置全局变量&lt;/h3&gt;&lt;p&gt;安装：&lt;/p&gt;
&lt;p&gt;去官网下载压缩包 或者 源码: &lt;code&gt;git clone git://github.com/pornel/pngquant.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以使用HomeBrew安装：&lt;code&gt;brew install pngquant&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置全局变量(使用HomeBrew安装请忽略)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln –s /下载的位置/pngquant /usr/local/bin/pngquant&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;pngquant 可以愉快的玩耍啦！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;查看帮助信息：&quot;&gt;&lt;a href=&quot;#查看帮助信息：&quot; class=&quot;headerlink&quot; title=&quot;查看帮助信息：&quot;&gt;&lt;/a&gt;查看帮助信息：&lt;/h3&gt;&lt;p&gt;执行 pngquant -h 查看完整选项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--ext new.png
设置输出图片的后缀。默认是 -or8.png 或者 -fs8.png 。

--quality min-max
使 pngquant 使用最少的颜色达到或超出 max 品质要求。如果转换结果低于 min 品质，图像不会被保存 (如果是输出到标准输出, 24-bit 原图像会被输出) 并且 pngquant 会退出并返回 99。
min 和 max 范围在 0 (最差) 到 100 (最佳), 和 JPEG 相似。
pngquant --quality=65-80 image.png

--speed N, -sN
速度/质量 平衡 从 1 (强制) 到 10 (最快)。默认是 3。速度 10 相比减少图片 5% 质量, 但是 8 倍于默认的速度。

--iebug
在 IE6 下, 只显示完全不透明的像素。pngquant 会使半透明像素以不透明方式显示并且不生产新的像素。

--version
输出版本信息。

-
从标准输入读取图像并输出到标准输出。

--
不处理对象。允许使用文件名以 - 开头的文件。如果你在脚本中使用 pngquant , 建议在文件名前加上这个:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;pngquant $OPTIONS -- &amp;quot;$FILE&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用示例：&quot;&gt;&lt;a href=&quot;#使用示例：&quot; class=&quot;headerlink&quot; title=&quot;使用示例：&quot;&gt;&lt;/a&gt;使用示例：&lt;/h3&gt;&lt;p&gt;压缩Downloads目录下所有的png，并替换当前图片&lt;/p&gt;
&lt;p&gt;&lt;code&gt;find /Users/mac/Downloads/ -name &amp;quot;*.png&amp;quot; | while read line; do pngquant --ext .png --force $line; done&lt;/code&gt;———–&lt;br&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.keepmovingxin.com/2016/04/30/pngquant-compress-png/&quot;&gt;http://blog.keepmovingxin.com/2016/04/30/pngquant-compress-png/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;项目包体积越来越大，为了压缩包大小找到一个比较好用的png图片压缩工具，在这记录一下。&lt;/p&gt;
&lt;h3 id=&quot;安装并配置全局变量&quot;&gt;&lt;a href=&quot;#安装并配置全局变量&quot; class=&quot;headerlink&quot; title=&quot;安装并配置全局变量&quot;&gt;&lt;/a&gt;安装并配置全局变量&lt;/h3&gt;&lt;p&gt;安装：&lt;/p&gt;
&lt;p&gt;去官网下载压缩包 或者 源码: &lt;code&gt;git clone git://github.com/pornel/pngquant.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以使用HomeBrew安装：&lt;code&gt;brew install pngquant&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置全局变量(使用HomeBrew安装请忽略)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln –s /下载的位置/pngquant /usr/local/bin/pngquant&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;pngquant 可以愉快的玩耍啦！&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="pngquant" scheme="http://blog.keepmovingxin.com/tags/pngquant/"/>
    
  </entry>
  
  <entry>
    <title>vi/vim显示中文字符并且去掉^M的方法</title>
    <link href="http://blog.keepmovingxin.com/2016/04/29/vi-vim-delete-M/"/>
    <id>http://blog.keepmovingxin.com/2016/04/29/vi-vim-delete-M/</id>
    <published>2016-04-29T05:39:31.000Z</published>
    <updated>2016-04-29T09:09:57.000Z</updated>
    
    <content type="html">&lt;ul&gt;
&lt;li&gt;处理项目xml配置时vim打开经常会碰到中文显示不正常的现象，也就是传说中的乱码，搜索找到一个解决办法，记录一下，但是gbk编码的正常了，utf8的又不对了，于是稍微改了一点。&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;用户目录下创建-vimrc文件&quot;&gt;&lt;a href=&quot;#用户目录下创建-vimrc文件&quot; class=&quot;headerlink&quot; title=&quot;用户目录下创建.vimrc文件&quot;&gt;&lt;/a&gt;用户目录下创建.vimrc文件&lt;/h3&gt;&lt;p&gt;加入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set fileencodings=utf-8,gb2312,gbk,gb18030
set termencoding=utf-8
set fileformats=unix
set encoding=prc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fileencodings中utf-8要在前面&lt;/p&gt;
&lt;p&gt;这样就能正常显示中文了，配合pietty，可以完全正常显示、编辑中文了。&lt;/p&gt;
&lt;h3 id=&quot;几种去除-M的方法&quot;&gt;&lt;a href=&quot;#几种去除-M的方法&quot; class=&quot;headerlink&quot; title=&quot;几种去除^M的方法&quot;&gt;&lt;/a&gt;几种去除^M的方法&lt;/h3&gt;&lt;p&gt;1、&lt;code&gt;cat filename1 | tr -d &amp;quot;\r&amp;quot; &amp;gt; newfile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、 &lt;code&gt;sed -e &amp;quot;s/^V^M//&amp;quot; filename &amp;gt; outputfilename&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3、vi： 用vi打开文件&lt;/p&gt;
&lt;p&gt;(1) 按ESC键&lt;/p&gt;
&lt;p&gt;(2) 输入 :%s/^M//g&lt;/p&gt;
&lt;p&gt;确定 ^M是使用 “CTRL-V CTRL-M” 而不是字面上的 ^M。&lt;/p&gt;
&lt;p&gt;这个正则式将替换所有回车符前的 ^M为空($是为了保证^M出现在行尾)&lt;/p&gt;
&lt;p&gt;4、用 vim 输入 :&lt;code&gt;set notextmode&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可惜，经过上面的处理以后，^M是不存在了，但是换行不成功。所有的东西都在一行上面，看着很费劲。这说明处理的时候文件缺少”\n”，可以在替换的时候添加上即可：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat filename | tr &amp;quot;\r&amp;quot; &amp;quot;\n&amp;quot; &amp;gt; newfile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注: ^M 可以用Sublime Text编辑器查看&lt;/p&gt;
&lt;p&gt;一些linux版本有 dos2unix 程序，可以用来祛除^M&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;处理项目xml配置时vim打开经常会碰到中文显示不正常的现象，也就是传说中的乱码，搜索找到一个解决办法，记录一下，但是gbk编码的正常了，utf8的又不对了，于是稍微改了一点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Vim" scheme="http://blog.keepmovingxin.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令学习</title>
    <link href="http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/"/>
    <id>http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/</id>
    <published>2016-04-28T08:02:52.000Z</published>
    <updated>2016-05-18T06:02:40.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;同步时间&quot;&gt;&lt;a href=&quot;#同步时间&quot; class=&quot;headerlink&quot; title=&quot;同步时间&quot;&gt;&lt;/a&gt;同步时间&lt;/h3&gt;&lt;p&gt;以管理员身份执行如下命令，可以自动与网络时间同步：&lt;br&gt;time.nist.gov 是一个时间服务器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ rdate -s time.nist.gov&lt;/code&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;管道符：&quot;&gt;&lt;a href=&quot;#管道符：&quot; class=&quot;headerlink&quot; title=&quot;管道符： |&quot;&gt;&lt;/a&gt;管道符： |&lt;/h3&gt;&lt;p&gt;就是把前面的命令运行的要放入标准输出的结果丢给后面的命令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat 1.txt | cat&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;echo&quot;&gt;&lt;a href=&quot;#echo&quot; class=&quot;headerlink&quot; title=&quot;echo&quot;&gt;&lt;/a&gt;echo&lt;/h3&gt;&lt;p&gt;-n    打印语句后不会换行。&lt;/p&gt;
&lt;p&gt;-e 开启转义，即可以打印后面的 \t,\r 等转义字符&lt;/p&gt;
&lt;p&gt;可以打印彩色文本。&lt;/p&gt;
&lt;h3 id=&quot;printf&quot;&gt;&lt;a href=&quot;#printf&quot; class=&quot;headerlink&quot; title=&quot;printf&quot;&gt;&lt;/a&gt;printf&lt;/h3&gt;&lt;p&gt;用于格式化输出，使用的参数和C语言中的printf函数一样&lt;/p&gt;
&lt;p&gt;eg：printf “%-5s %-10s %-4.2f\n” 1 James 80.9968&lt;/p&gt;
&lt;p&gt;-：表示左对齐，默认为右对齐&lt;/p&gt;
&lt;p&gt;s：表示打印的是字符串&lt;/p&gt;
&lt;p&gt;f：表示打印一个浮点数，其中4表示宽度，.2表示保留2位小数&lt;/p&gt;
&lt;p&gt;printf默认不带换行，需要手动添加&lt;/p&gt;
&lt;h3 id=&quot;cat&quot;&gt;&lt;a href=&quot;#cat&quot; class=&quot;headerlink&quot; title=&quot;cat&quot;&gt;&lt;/a&gt;cat&lt;/h3&gt;&lt;p&gt;查看文件&lt;/p&gt;
&lt;p&gt;-n：为每行前面加上行号。-n会为空白行也加上行号，-b选项则会跳过空白行。&lt;/p&gt;
&lt;p&gt;-s：压缩相邻的空白行，即连续的空白行将压缩为一行。&lt;/p&gt;
&lt;p&gt;-T：用^I符号表示制表符\t&lt;/p&gt;
&lt;h3 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h3&gt;&lt;p&gt;由一般字符和特殊字符（meta字符）组成&lt;/p&gt;
&lt;p&gt;meta元字符&lt;/p&gt;
&lt;p&gt;\ 通常用于打开或关闭后续字符的特殊含义，如(…)与{…}&lt;/p&gt;
&lt;p&gt;. 匹配任何单个字符（除NULL）&lt;/p&gt;
&lt;p&gt;* 匹配前面的子表达式任意次，例：a* 匹配任意多个a&lt;/p&gt;
&lt;p&gt;? 匹配前面的子表达式零次或一次匹配前面的子表达式一次或多次。&lt;/p&gt;
&lt;p&gt;+ 匹配前面的子表达式一次或多次&lt;/p&gt;
&lt;p&gt;^ 匹配输入字符串的开始位置&lt;/p&gt;
&lt;p&gt;$ 匹配输入字符串的结束位置&lt;/p&gt;
&lt;p&gt;[] 匹配方括号内的任一字符，其中可用连字符（-）指的连续字符的范围；^符号若出现在方括号的第一个位置，则表示匹配不在列表中的任一字符&lt;/p&gt;
&lt;p&gt;(x|y) 匹配x或y，比如：(g|f)ood，匹配good或food&lt;/p&gt;
&lt;h3 id=&quot;文件通配符&quot;&gt;&lt;a href=&quot;#文件通配符&quot; class=&quot;headerlink&quot; title=&quot;文件通配符&quot;&gt;&lt;/a&gt;文件通配符&lt;/h3&gt;&lt;p&gt;* 匹配文件名中的任何字符串，包括空字符串。&lt;/p&gt;
&lt;p&gt;? 匹配文件名中的任何单个字符。&lt;/p&gt;
&lt;p&gt;[…] 匹配[ ]中所包含的任何字符。可以用 – 连接，表示范围&lt;/p&gt;
&lt;p&gt;[!…] 匹配[ ]中非 感叹号！之后的字符。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;5* 5开头的所有字符串&lt;/p&gt;
&lt;p&gt;*5 5结尾的所有字符串&lt;/p&gt;
&lt;p&gt;*5? 以5为倒数第二个字符的字符串&lt;/p&gt;
&lt;p&gt;[0－9] 所有以数字的字符&lt;/p&gt;
&lt;p&gt;[1,2] 1或者2&lt;/p&gt;
&lt;p&gt;[!0-9] 不是数字的字符&lt;/p&gt;
&lt;h3 id=&quot;grep&quot;&gt;&lt;a href=&quot;#grep&quot; class=&quot;headerlink&quot; title=&quot;grep&quot;&gt;&lt;/a&gt;grep&lt;/h3&gt;&lt;p&gt;grep [options] [表达式]&lt;/p&gt;
&lt;p&gt;1)    [options]列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-c    ：只输出匹配行的统计数

-n    ：显示匹配行及行号

-A2    ：列出匹配行及下面2行

-B2    ：列出匹配行及上面2行

-C2    ：列出匹配行及上下2行

-I    ：不区分大小写(只适用于单字符)

-h    ：查询多文件时不显示文件名

-H    ：查询多文件时显示文件名（默认）

-l    ：查询多文件时只输出包含匹配字符的文件名

-o    : 每行只输出匹配部分

-s    ：不显示不存在或无匹配文本的错误信息

-v    ：显示不包含匹配文本的所有行

-r    ：递归匹配目录下所有文件及目录

-E    : 扩展grep，增加了额外的正则表达式元字符集

-e    ：指定多个匹配样式，样式间“或”的关系

-f pattern_file    ：    样式文件pattern_file中逐行存放要匹配的样式，可匹配多个样式，样式之间是“或”的关系

--color    ：    为匹配项显示不同颜色
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2)    grep –E “pattern1|pattern2” files ：显示匹配 pattern1 或 pattern2 的行&lt;/p&gt;
&lt;p&gt;3)    grep –e pattern1 –e pattern2 files : 匹配pattern1或pattern2&lt;/p&gt;
&lt;p&gt;4)    grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行&lt;/p&gt;
&lt;p&gt;5)    egrep “t_hero|t_item”   匹配t_hero或者t_item的项&lt;/p&gt;
&lt;p&gt;6)    grep “t_hero|t_item”    可以实现与上面同样的功能&lt;/p&gt;
&lt;h3 id=&quot;sed&quot;&gt;&lt;a href=&quot;#sed&quot; class=&quot;headerlink&quot; title=&quot;sed&quot;&gt;&lt;/a&gt;sed&lt;/h3&gt;&lt;p&gt;sed [options] ‘command’ file(s) 或sed [options] -f scriptfile file(s)&lt;/p&gt;
&lt;p&gt;一次处理一行内容 不改变文件内容&lt;/p&gt;
&lt;p&gt;[options]列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-n    :    取消默认的输出,使用安静(silent)模式。

-r    :    使用正则表达式，及表达式中不需要进行转义

-f filename :    指定sed脚本的文件名filename

-e &amp;apos;&amp;apos; :    允许多重编辑·  

-i    :    将替换结果应用于源文件
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1)    替换字符串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sed &amp;#39;s/pattern/string/&amp;#39; file&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat file | sed &amp;#39;s/pattern/string/&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2)    替换文件中所有匹配内容，使用参数g&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sed &amp;#39;s/pattern/string/g&amp;#39; file&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但如果你想从第N处匹配开始替换，可以使用参数/Ng&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ echo thisthisthisthis | sed &amp;#39;s/this/THIS/2g&amp;#39;
thisTHISTHISTHIS&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3)    sed的定界符’/‘.当匹配模式中含有’/‘字符时，我们需要用’\’对定界符’/‘进行转义&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ echo a/b | sed &amp;#39;s/a\/b/a*b/&amp;#39;
a*b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为了避免转义字符造成的理解困难，我们可以使用其它定界符，比如|,:,@,#,$,%,+等等&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ echo a/b | sed &amp;#39;s:a/b:a*b:&amp;#39;
a*b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4)    移除匹配样式行  &lt;code&gt;sed &amp;#39;/pattern/d&amp;#39; file&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ sed -r &amp;#39;/^ *$/d&amp;#39; args.txt        #移除空白行，含有一个或多个空格的行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5)    组合多个表达式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ echo abd | sed &amp;apos;s/a/A/&amp;apos; | sed &amp;apos;s/d/D/&amp;apos;  #用管道组合$ echo abd | sed &amp;apos;s/a/A/;s/d/D/&amp;apos;           #用分号组合$ echo abd | sed -e &amp;apos;s/a/A/&amp;apos; -e &amp;apos;s/d/D/&amp;apos;  #用-e选项组合&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;6)    已匹配字符串标记（&amp;amp;）&lt;/p&gt;
&lt;p&gt;&amp;amp;代表匹配给定样式的字符串，常用于对给定样式增加[]，{}等不需要改变样式的情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;this is an example&amp;quot; | sed &amp;apos;s/\w\+/[&amp;amp;]/g&amp;apos;   #\w\+ 匹配每个单词
[this] [is] [an] [example]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7)    子串匹配标记（\1）&lt;/p&gt;
&lt;p&gt;有时我们希望对匹配给定的样式标记出一些子串来，方便后续引用&lt;/p&gt;
&lt;p&gt;(pattern) 用于匹配子串pattern&lt;/p&gt;
&lt;p&gt;\1 用于引用第一个匹配到的子串，\n 对应第n个匹配到的子串。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo 123 asd | sed &amp;apos;s/\([0-9]\+\) \([a-z]\+\)/\2+\1/&amp;apos; 
asd+123
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中\1对应数字123，\2对应字母asd&lt;/p&gt;
&lt;p&gt;对于子串的引用，在样式里一定要用()括起来，如果加上-r选项，则不需要转义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo 123 asd | sed -r &amp;apos;s/([0-9]+) ([a-z]+)/\2+\1/&amp;apos;
asd+123
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8)    引用&lt;/p&gt;
&lt;p&gt;在脚本中有用的一点，用双引号引用的sed表达式，会对表达式求值来进行扩展，如使用前面定义的变量等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ text=hello
$ echo hello world | sed &amp;quot;s/$text/HELLO/&amp;quot;
HELLO world
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;tail&quot;&gt;&lt;a href=&quot;#tail&quot; class=&quot;headerlink&quot; title=&quot;tail&quot;&gt;&lt;/a&gt;tail&lt;/h3&gt;&lt;p&gt;用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件&lt;/p&gt;
&lt;p&gt;主要参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-f ：    循环读取   #可以用在监控线上有没有报错信息

-q ：    不显示处理信息

-v ：    显示详细的处理信息

-c&amp;lt;数目&amp;gt; ：    显示的字节数

-n&amp;lt;行数&amp;gt; ：    显示行数

--pid=PID ：    与-f合用,表示在进程ID,PID死掉之后结束. 

-q, --quiet, --silent ：    从不输出给出文件名的首部
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;find&quot;&gt;&lt;a href=&quot;#find&quot; class=&quot;headerlink&quot; title=&quot;find&quot;&gt;&lt;/a&gt;find&lt;/h3&gt;&lt;p&gt;&lt;code&gt;find dir [option] &amp;#39;command&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;code&gt;dir&lt;/code&gt;: 目录名，用空格隔开多个目录&lt;br&gt;1) [option]列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-name wildcard 文件名，wildcard表示通配符，并非正则式
    find dir1 dir2 -name &amp;apos;*.c&amp;apos; –print  在目录dir1和dir2中查找文件，并打印路径
    如果在-name后面紧跟一个-prune，则表示此目录应被修剪
    find . \( -name &amp;quot;.svn&amp;quot; -prune \) -o –print 表示对于查找的目录，要么修剪掉（.svn），要么打印出来（其他）。
-iname 忽略名字大小写
-path 指定目录，如果在-path前面加上 ！ ，则表示忽略此目录，目录名可以使用通配符匹配。
-type 文件类型
    f:普通文件 d:目录 l:符号连接文件 c:字符设备文件 b:块设备文件 p:管道文件
-size ±nc 查找大于（+）或小于（-）n字节的文件，注意c（charter）
-mtime ±ndays 文件最近修改时间
-user,-nouser 文件所有者
-group,-nogroup 指定文件用户组
多条件的与（-a）/或（-o）/非（！）
    find . \( -name &amp;quot;*.txt&amp;quot; –o –name &amp;quot;*.sh&amp;quot; \) –print
    括号两边应该有空格
-maxdepth n 指定最大目录深度，n=1表示最大为当前目录
-mindepth n 指定最小目录深度，n=2表示不打印当前目录下的文件
  -maxdepth和-mindepth应作为find的第三个参数出现，以提高效率
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2) ‘command’命令列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-print  打印路径名
-delete 对找到的文件进行删除 
-exec   对查找到的目标执行某一命令。
    find ${workdir} -name &amp;quot;$filename&amp;quot; -exec  |grep $uid
    -exec 参数后面跟的是bash命令，但只能跟一个命令，如果想执行多个命令，那么可以将多个命令放进一个shell脚本，然后执行这个脚本。
    bash命令的终止，使用 &amp;apos;;&amp;apos; (分号）来判定，在后面必须有一个 &amp;apos;;&amp;apos;在分号前应该加上转义字符&amp;apos;\&amp;apos;
    &amp;apos;{}&amp;apos;，使用{}来表示文件名，也就是find前面处理过程中过滤出来的文件，用于bash命令进行处理
-ok     与-exec类似，只是对查找到符合条件的目标执行一个命令前需要经过确认
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;cut&quot;&gt;&lt;a href=&quot;#cut&quot; class=&quot;headerlink&quot; title=&quot;cut&quot;&gt;&lt;/a&gt;cut&lt;/h3&gt;&lt;p&gt;&lt;code&gt;cut&lt;/code&gt; 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出，必须指定 &lt;code&gt;-b&lt;/code&gt;、&lt;code&gt;-c&lt;/code&gt; 或&lt;code&gt;-f&lt;/code&gt; 标志之一。&lt;br&gt;主要参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-b: 以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。
-c: 以字符为单位进行分割。（单个字母等）
    cut –c2-5 file    ，表示将文件file每行的第2-5个字符作为一列显示出来。
-d: 自定义分隔符，默认为制表符。
-f: 与-d一起使用，指定显示哪个区域。
    例子：cat file.txt | cut -d&amp;apos;]&amp;apos; -f7；
        cat file.txt | cut -d&amp;apos;]&amp;apos; –f4,7；//打印4和7列
        cat file.txt | cut -d&amp;apos;]&amp;apos; –f4-7；//打印4到7列
-n: 取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的&amp;lt;br /&amp;gt;范围之内，该字符将被写出；否则，该字符将被排除。
--complement: 与-f一起使用，指定显示哪个区域的补集。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;sort-排序&quot;&gt;&lt;a href=&quot;#sort-排序&quot; class=&quot;headerlink&quot; title=&quot;sort  排序&quot;&gt;&lt;/a&gt;sort  排序&lt;/h3&gt;&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按&lt;code&gt;ASCII&lt;/code&gt;码值进行比较，最后将他们按升序输出。&lt;br&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-u: 去除重复行
-r: sort默认的排序方式是升序，如果想改成降序，用此参数
-o file: 把排序结果输出到文件file，file可以是原文件
-n: 以数值排序
-t: 指定间隔符
-k: 指定域排序，常与-t连用。sort –t &amp;apos;:&amp;apos; –k 2
    在指定域的时候还可细分，比如指定第二个域的第3个字符开始比较，用-k 2.3;
    比如指定第二个域的第3个字符到第二个域的第5个字符进行排序，用-k 2.3,2.5
    比如只指定第二个域的第3个字符进行排序，用-k 2.3,2.3
-b: 忽略每一行前面的所有空白部分，从第一个可见字符开始比较
-f: 忽略大小写进行排序
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;uniq-去重&quot;&gt;&lt;a href=&quot;#uniq-去重&quot; class=&quot;headerlink&quot; title=&quot;uniq 去重&quot;&gt;&lt;/a&gt;uniq 去重&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-c : 统计重复的行数
-u : 只显示不重复的那些行
-d : 只显示重复的那些行
-s n : 指定跳过前n个字符
-w n : 指定用于比较的最大字符数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;wc-统计&quot;&gt;&lt;a href=&quot;#wc-统计&quot; class=&quot;headerlink&quot; title=&quot;wc 统计&quot;&gt;&lt;/a&gt;wc 统计&lt;/h3&gt;&lt;p&gt;使用wc的各种选项来统计行数、单词数和字符数。&lt;br&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-l ：行数
-w ：单词数
-c ：字符数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;seq&quot;&gt;&lt;a href=&quot;#seq&quot; class=&quot;headerlink&quot; title=&quot;seq&quot;&gt;&lt;/a&gt;seq&lt;/h3&gt;&lt;p&gt;&lt;code&gt;seq A B&lt;/code&gt;: 用于产生从某个数到另外一个数之间的所有整数&lt;br&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-f：指定格式。默认是&amp;quot;%g&amp;quot;，表示按宽度为1输出。可以在g的前面加入一些字符，表示不同的含义，如：
   %2g：表示按宽度为2右对齐。
   %02g：表示按宽度为2右对齐，不足的部分用0补足。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可用于构造日志文件名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i in `seq -f &amp;quot;log.20160407&amp;quot;%02g 5 12`; do echo $i; done
   str%03g：表示按宽度为3右对齐，补足的位数用0补，并在前面加上str子串。
    %-3g：表示按宽度为3左对齐。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;mkdir-创建目录&quot;&gt;&lt;a href=&quot;#mkdir-创建目录&quot; class=&quot;headerlink&quot; title=&quot;mkdir 创建目录&quot;&gt;&lt;/a&gt;mkdir 创建目录&lt;/h3&gt;&lt;p&gt;常用参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-p: 可以是一个路径名称。此时若路径中的某些目录尚不存在，加上此选项后,系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录;
-m &amp;lt;777&amp;gt;: 模式，设定权限&amp;lt;模式&amp;gt;
-v: 在创建目录的同时输出信息。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;date&quot;&gt;&lt;a href=&quot;#date&quot; class=&quot;headerlink&quot; title=&quot;date&quot;&gt;&lt;/a&gt;date&lt;/h3&gt;&lt;p&gt;1) 显示时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date [OPTION]... [+FORMAT]
date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;  #显示当前的年月日时分秒
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2) 设置时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date -s //设置当前时间，只有root权限才能设置，其他只能查看。
date -s 20080523 //设置成20080523，这样会把具体时间设置成空00:00:00
date -s 15:20:30 //设置时间
date +%s //当前时间时间戳
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3) 转换时间&lt;br&gt;把linux下的时间戳转换成现实中的年月日时分秒&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date –d @timestamp
eg:$date -d @1433087999
 2015年 05月 31日 星期日 23:59:59 CST
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;md5sum&quot;&gt;&lt;a href=&quot;#md5sum&quot; class=&quot;headerlink&quot; title=&quot;md5sum&quot;&gt;&lt;/a&gt;md5sum&lt;/h3&gt;&lt;p&gt;MD5全称是报文摘要算法（Message-Digest Algorithm 5），此算法对任意长度的信息逐位进行计算，产生一个二进制长度为128位（十六进制长度32位）的“指纹”（或称“报文摘要”），即使两个文件只相差一个字符，产生的校验和也完全不同。&lt;br&gt;1) 使用md5sum来产生指纹（报文摘要）命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;md5sum file &amp;gt; file.md5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若不指定文件名，则从标准输入读取，也可输出到标准输出设备，因此可与管道符“|”连用。&lt;br&gt; 可以使用文件通配符，将多个文件的md5值输出到同一个文件。&lt;br&gt;文件file.md5的内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c0e207c045c344ebf363c3e9a6de1076  file
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 第一列是md5校验和，第二列是对应文件名。&lt;br&gt;2) 使用md5报文摘要验证文件。&lt;br&gt;将生成的file.md5文件放在对应file文件的同一目录下。使用如下命令验证：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;md5sum -c file.md5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若验证成功，输出“file: 确定”；验证失败则输出“file: 失败”，并打印警告信息：“md5sum: 警告：1/1 生成的校验和不匹配”。&lt;/p&gt;
&lt;h3 id=&quot;ln-链接&quot;&gt;&lt;a href=&quot;#ln-链接&quot; class=&quot;headerlink&quot; title=&quot;ln 链接&quot;&gt;&lt;/a&gt;ln 链接&lt;/h3&gt;&lt;p&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-f : 链结时先将与 dist 同档名的档案删除
-d : 允许系统管理者硬链结自己的目录
-i : 在删除与 dist 同档名的档案时先进行询问
-n : 在进行软连结时，将 dist 视为一般的档案
-s : 进行软链结(symbolic link)
     ln –s target new
     为target文件建立一个软链接new指向target
-v : 在连结之前显示其档名
-b : 将在链结时会被覆写或删除的档案进行备份
-S SUFFIX : 将备份的档案都加上 SUFFIX 的字尾
-V METHOD : 指定备份的方式
--help : 显示辅助说明
--version : 显示版本
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;split-大文件切割&quot;&gt;&lt;a href=&quot;#split-大文件切割&quot; class=&quot;headerlink&quot; title=&quot;split 大文件切割&quot;&gt;&lt;/a&gt;split 大文件切割&lt;/h3&gt;&lt;p&gt; &lt;code&gt;split -b 500m file newfile_prefix&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-l：行数，指定每多少行切成一个小文件。
-b：指定每多少字就要切成一个小文件。支持单位:m,k
-C：与-b参数类似，但切割时尽量维持每行的完整性。
-d：指定切割后的文件名以数字作为后缀
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;合并： &lt;code&gt;cat newfile_prefix* &amp;gt; newfile&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;alias-别名&quot;&gt;&lt;a href=&quot;#alias-别名&quot; class=&quot;headerlink&quot; title=&quot;alias 别名&quot;&gt;&lt;/a&gt;alias 别名&lt;/h3&gt;&lt;p&gt;&lt;code&gt;alias myssh=’sh filename.sh’&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;chmod-权限&quot;&gt;&lt;a href=&quot;#chmod-权限&quot; class=&quot;headerlink&quot; title=&quot;chmod 权限&quot;&gt;&lt;/a&gt;chmod 权限&lt;/h3&gt;&lt;p&gt;使用chmod命令设置文件权限。&lt;br&gt;&lt;code&gt;chmod a+x file&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;u ： 指定用户权限
g ： 指定用户组权限
o ： 指定其他用户权限
a ： 指定所有类别
+ ： 增加权限
- ： 删除权限
r ： 可读
w ： 可写
x ： 可执行，对目录文件来说表示可访问目录中的文件和子目录
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;vim-文本编辑工具&quot;&gt;&lt;a href=&quot;#vim-文本编辑工具&quot; class=&quot;headerlink&quot; title=&quot;vim 文本编辑工具&quot;&gt;&lt;/a&gt;vim 文本编辑工具&lt;/h3&gt;&lt;p&gt;&lt;code&gt;vimdiff&lt;/code&gt; 文本差异对比&lt;br&gt;&lt;code&gt;vimdiff  FILE_LEFT  FILE_RIGHT&lt;/code&gt;&lt;br&gt;常用命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ctrl-w K 把当前窗口移到最上边
Ctrl-w H 把当前窗口移到最左边
Ctrl-w J 把当前窗口移到最下边
Ctrl-w L 把当前窗口移到最右边
Ctrl-w,w  在两个文件之间来回跳转
]c   跳转到下一差异点
[c   跳转到上一差异点，可在前面加上数字，表示跳转多少个差异
dp(diff put) 把一个差异点中当前文件的内容复制到另一个文件中
do(diff get) 另一个文件的内容复制到当前行中
:diffupdate 手工来刷新比较结果
zo(folding open) 展开被折叠的相同的文本行
zc(folding close) 重新折叠
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;paste&quot;&gt;&lt;a href=&quot;#paste&quot; class=&quot;headerlink&quot; title=&quot;paste&quot;&gt;&lt;/a&gt;paste&lt;/h3&gt;&lt;p&gt;用paste命令实现按列拼接。&lt;br&gt;&lt;code&gt;$ paste file1 file2 file3...&lt;/code&gt;&lt;br&gt;参数：&lt;br&gt;&lt;code&gt;-d：指定定界符&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;列出目录&quot;&gt;&lt;a href=&quot;#列出目录&quot; class=&quot;headerlink&quot; title=&quot;列出目录&quot;&gt;&lt;/a&gt;列出目录&lt;/h3&gt;&lt;p&gt;以下是几种方法列出当前路径下的目录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls –d */
ls –F | grep &amp;quot;/$&amp;quot;
ls –l | grep &amp;quot;^d&amp;quot;
find . –type d –maxdepth 1 –print
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;jps&quot;&gt;&lt;a href=&quot;#jps&quot; class=&quot;headerlink&quot; title=&quot;jps&quot;&gt;&lt;/a&gt;jps&lt;/h3&gt;&lt;p&gt;显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。&lt;br&gt;主要参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数
-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null
-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名
-v 输出传递给JVM的参数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;未完待续…&quot;&gt;&lt;a href=&quot;#未完待续…&quot; class=&quot;headerlink&quot; title=&quot;未完待续…&quot;&gt;&lt;/a&gt;未完待续…&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/&quot;&gt;http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;同步时间&quot;&gt;&lt;a href=&quot;#同步时间&quot; class=&quot;headerlink&quot; title=&quot;同步时间&quot;&gt;&lt;/a&gt;同步时间&lt;/h3&gt;&lt;p&gt;以管理员身份执行如下命令，可以自动与网络时间同步：&lt;br&gt;time.nist.gov 是一个时间服务器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ rdate -s time.nist.gov&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://blog.keepmovingxin.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x使用CCGLProgram和Shader文件实现精灵置灰</title>
    <link href="http://blog.keepmovingxin.com/2016/04/27/cocos2d-x-GraySprite/"/>
    <id>http://blog.keepmovingxin.com/2016/04/27/cocos2d-x-GraySprite/</id>
    <published>2016-04-27T09:47:46.000Z</published>
    <updated>2016-05-12T13:08:30.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;1-实现方法：CCGraySprite-继承自-CCSprite-覆盖initWithTexture和draw方法实现置灰。&quot;&gt;&lt;a href=&quot;#1-实现方法：CCGraySprite-继承自-CCSprite-覆盖initWithTexture和draw方法实现置灰。&quot; class=&quot;headerlink&quot; title=&quot;1. 实现方法：CCGraySprite 继承自 CCSprite 覆盖initWithTexture和draw方法实现置灰。&quot;&gt;&lt;/a&gt;1. 实现方法：&lt;code&gt;CCGraySprite&lt;/code&gt; 继承自 &lt;code&gt;CCSprite&lt;/code&gt; 覆盖&lt;code&gt;initWithTexture&lt;/code&gt;和&lt;code&gt;draw&lt;/code&gt;方法实现置灰。&lt;/h4&gt;&lt;h5 id=&quot;方法和属性声明：&quot;&gt;&lt;a href=&quot;#方法和属性声明：&quot; class=&quot;headerlink&quot; title=&quot;方法和属性声明：&quot;&gt;&lt;/a&gt;方法和属性声明：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class CCGraySprite : public CCSprite&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CCGraySprite();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    virtual ~CCGraySprite();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* create(const char* pszFileName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool initWithTexture(CCTexture2D* pTexture, const CCRect&amp;amp; tRect);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* createWithSprite(CCSprite *pSprite);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* createWithNodeAndItChild(CCNode *pNode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void setGray(bool isGray);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    virtual void draw();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool m_isGray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CCGLProgram* pProgram;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m_isGray&lt;/code&gt; 是否置灰&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pProgram&lt;/code&gt; 保存置灰的GL程序&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;2-shader字符串&quot;&gt;&lt;a href=&quot;#2-shader字符串&quot; class=&quot;headerlink&quot; title=&quot;2. shader字符串:&quot;&gt;&lt;/a&gt;2. shader字符串:&lt;/h4&gt;&lt;p&gt;可以像官方那样写在一个.h文件中&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GLchar* pszFragSource = (GLchar*)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;#ifdef GL_ES \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        precision mediump float; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #endif \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uniform sampler2D u_texture; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        varying vec2 v_texCoord; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        varying vec4 v_fragmentColor; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        void main(void) \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Convert to greyscale using NTSC weightings \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vec4 col = texture2D(u_texture, v_texCoord); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        float grey = dot(col.rgb, vec3(0.299, 0.587, 0.114)); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        gl_FragColor = vec4(grey, grey, grey, col.a); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;3-核心代码：&quot;&gt;&lt;a href=&quot;#3-核心代码：&quot; class=&quot;headerlink&quot; title=&quot;3. 核心代码：&quot;&gt;&lt;/a&gt;3. 核心代码：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;覆盖父类的&lt;code&gt;initWithTexture&lt;/code&gt;和&lt;code&gt;draw&lt;/code&gt;方法，根据&lt;code&gt;m_isGray&lt;/code&gt;调用对应GL程序进行渲染绘制精灵&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void CCGraySprite::setGray(bool isGray) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m_isGray = isGray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (isGray == true) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;setShaderProgram(pProgram);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;setShaderProgram(CCShaderCache::sharedShaderCache()-&amp;gt;programForKey(kCCShader_PositionTextureColor));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool CCGraySprite::initWithTexture(CCTexture2D* pTexture, const CCRect&amp;amp; tRect )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m_isGray = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CC_BREAK_IF(!CCSprite::initWithTexture(pTexture, tRect));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        GLchar* pszFragSource = (GLchar*)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;#ifdef GL_ES \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        precision mediump float; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #endif \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uniform sampler2D u_texture; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        varying vec2 v_texCoord; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        varying vec4 v_fragmentColor; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        void main(void) \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123; \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Convert to greyscale using NTSC weightings \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vec4 col = texture2D(u_texture, v_texCoord); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        float grey = dot(col.rgb, vec3(0.299, 0.587, 0.114)); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        gl_FragColor = vec4(grey, grey, grey, col.a); \n \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pProgram = new CCGLProgram();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pProgram-&amp;gt;initWithVertexShaderByteArray(ccPositionTextureColor_vert, pszFragSource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;setShaderProgram(pProgram);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHECK_GL_ERROR_DEBUG();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;addAttribute(kCCAttributeNamePosition, kCCVertexAttrib_Position);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;addAttribute(kCCAttributeNameColor, kCCVertexAttrib_Color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;addAttribute(kCCAttributeNameTexCoord, kCCVertexAttrib_TexCoords);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHECK_GL_ERROR_DEBUG();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;link();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHECK_GL_ERROR_DEBUG();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this-&amp;gt;getShaderProgram()-&amp;gt;updateUniforms();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CHECK_GL_ERROR_DEBUG();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; while (0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CCGraySprite::draw()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (this-&amp;gt;getTexture() == NULL) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(m_isGray == false)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CCSprite::draw();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ccGLEnableVertexAttribs(kCCVertexAttribFlag_PosColorTex );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ccGLBlendFunc( m_sBlendFunc.src, m_sBlendFunc.dst );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this-&amp;gt;getShaderProgram()-&amp;gt;use();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this-&amp;gt;getShaderProgram()-&amp;gt;setUniformsForBuiltins();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ccGLBindTexture2D( this-&amp;gt;getTexture()-&amp;gt;getName() );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#define kQuadSize sizeof(m_sQuad.bl)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long offset = (long)&amp;amp;m_sQuad;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // vertex&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int diff = offsetof( ccV3F_C4B_T2F, vertices);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    glVertexAttribPointer(kCCVertexAttrib_Position, 3, GL_FLOAT, GL_FALSE, kQuadSize, (void*) (offset + diff));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // texCoods&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    diff = offsetof( ccV3F_C4B_T2F, texCoords);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, kQuadSize, (void*)(offset + diff));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // color&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    diff = offsetof( ccV3F_C4B_T2F, colors);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_UNSIGNED_BYTE, GL_TRUE, kQuadSize, (void*)(offset + diff));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CC_INCREMENT_GL_DRAWS(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;4-lua使用示例&quot;&gt;&lt;a href=&quot;#4-lua使用示例&quot; class=&quot;headerlink&quot; title=&quot;4. lua使用示例&quot;&gt;&lt;/a&gt;4. lua使用示例&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;需手写.pkg文件，使用tolua++工具导出Lua binding文件，在AppDelegate::applicationDidFinishLaunching()注册后，方可在lua层使用&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local nameBgSp = CCGraySprite:create(&amp;quot;images/namebg.png&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local normalSp = CCSprite:create(&amp;quot;images/namebg.png&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local graySp = CCGraySprite:createWithNodeAndItChild(normalSp)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;local frameSp = CCGraySprite:create(&amp;quot;images/frame.png&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frameSp:setGray(isGray)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;———–&lt;br&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.keepmovingxin.com/2016/04/27/cocos2d-x-GraySprite/&quot;&gt;http://blog.keepmovingxin.com/2016/04/27/cocos2d-x-GraySprite/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-实现方法：CCGraySprite-继承自-CCSprite-覆盖initWithTexture和draw方法实现置灰。&quot;&gt;&lt;a href=&quot;#1-实现方法：CCGraySprite-继承自-CCSprite-覆盖initWithTexture和draw方法实现置灰。&quot; class=&quot;headerlink&quot; title=&quot;1. 实现方法：CCGraySprite 继承自 CCSprite 覆盖initWithTexture和draw方法实现置灰。&quot;&gt;&lt;/a&gt;1. 实现方法：&lt;code&gt;CCGraySprite&lt;/code&gt; 继承自 &lt;code&gt;CCSprite&lt;/code&gt; 覆盖&lt;code&gt;initWithTexture&lt;/code&gt;和&lt;code&gt;draw&lt;/code&gt;方法实现置灰。&lt;/h4&gt;&lt;h5 id=&quot;方法和属性声明：&quot;&gt;&lt;a href=&quot;#方法和属性声明：&quot; class=&quot;headerlink&quot; title=&quot;方法和属性声明：&quot;&gt;&lt;/a&gt;方法和属性声明：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class CCGraySprite : public CCSprite&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CCGraySprite();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    virtual ~CCGraySprite();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* create(const char* pszFileName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool initWithTexture(CCTexture2D* pTexture, const CCRect&amp;amp; tRect);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* createWithSprite(CCSprite *pSprite);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static CCGraySprite* createWithNodeAndItChild(CCNode *pNode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void setGray(bool isGray);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    virtual void draw();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool m_isGray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CCGLProgram* pProgram;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m_isGray&lt;/code&gt; 是否置灰&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pProgram&lt;/code&gt; 保存置灰的GL程序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="游戏开发" scheme="http://blog.keepmovingxin.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Cocos2d-x" scheme="http://blog.keepmovingxin.com/tags/Cocos2d-x/"/>
    
  </entry>
  
  <entry>
    <title>Git Config命令查看配置文件</title>
    <link href="http://blog.keepmovingxin.com/2016/04/27/Git-Config/"/>
    <id>http://blog.keepmovingxin.com/2016/04/27/Git-Config/</id>
    <published>2016-04-27T08:31:28.000Z</published>
    <updated>2016-04-29T03:15:37.000Z</updated>
    
    <content type="html">&lt;p&gt;git config命令的基本使用&lt;/p&gt;
&lt;h3 id=&quot;配置文件如何生效&quot;&gt;&lt;a href=&quot;#配置文件如何生效&quot; class=&quot;headerlink&quot; title=&quot;配置文件如何生效&quot;&gt;&lt;/a&gt;配置文件如何生效&lt;/h3&gt;&lt;p&gt;对于 git 来说，配置文件的权重是仓库&amp;gt;全局&amp;gt;系统。Git 会使用这一系列的配置文件来存储你定义的偏好，它首先会查找 /etc/gitconfig 文件（系统级），该文件含有对系统上所有用户及他们所拥有的仓库都生效的配置值。接下来 Git 会查找每个用户的 ~/.gitconfig 文件（全局级）。最后 Git 会查找由用户定义的各个库中Git目录下的配置文件 .git/config（仓库级），该文件中的值只对当前所属仓库有效。以上阐述的三 层配置从一般到特殊层层推进，如果定义的值有冲突，以后面层中定义的为准，例如：.git/config 和 /etc/gitconfig 的较量中， .git/config 取得了胜利。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;使用-git-config-命令查看配置文件&quot;&gt;&lt;a href=&quot;#使用-git-config-命令查看配置文件&quot; class=&quot;headerlink&quot; title=&quot;使用 git config 命令查看配置文件&quot;&gt;&lt;/a&gt;使用 git config 命令查看配置文件&lt;/h3&gt;&lt;p&gt;命令参数–list, 简写 -l&lt;/p&gt;
&lt;p&gt;格式：&lt;code&gt;git config [–local|–global|–system] -l&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;查看仓库级的 config，命令：git config –local -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看全局级的 config，命令：git config –global -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看系统级的 config，命令：git config –system -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看当前生效的配置，  命令：git config -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;使用-git-config-命令编辑配置文件&quot;&gt;&lt;a href=&quot;#使用-git-config-命令编辑配置文件&quot; class=&quot;headerlink&quot; title=&quot;使用 git config 命令编辑配置文件&quot;&gt;&lt;/a&gt;使用 git config 命令编辑配置文件&lt;/h3&gt;&lt;p&gt;命令参数 –edit, 简写 -e&lt;/p&gt;
&lt;p&gt;格式：&lt;code&gt;git config [–local|–global|–system] -e&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;查看仓库级的config，命令：git config –local -e，与–list参数不同的是，git config -e默认是编辑仓库级的配置文件。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看全局级的config，命令：git config –global -e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看系统级的config，命令：git config –system -e&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行这个命令的时候，git 会用配置文件中设定的编辑器打开配置文件。&lt;/p&gt;
&lt;h3 id=&quot;增加一个配置项&quot;&gt;&lt;a href=&quot;#增加一个配置项&quot; class=&quot;headerlink&quot; title=&quot;增加一个配置项&quot;&gt;&lt;/a&gt;增加一个配置项&lt;/h3&gt;&lt;p&gt;参数 –add&lt;/p&gt;
&lt;p&gt;格式: &lt;code&gt;git config [–local|–global|–system] –add section.key value&lt;/code&gt; (默认是添加在 local 配置中)&lt;/p&gt;
&lt;p&gt;注意 add 后面的 section,key,value 一项都不能少，否则添加失败。比如我们执行：&lt;code&gt;git config –add man.name jim&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取一个配置项&quot;&gt;&lt;a href=&quot;#获取一个配置项&quot; class=&quot;headerlink&quot; title=&quot;获取一个配置项&quot;&gt;&lt;/a&gt;获取一个配置项&lt;/h3&gt;&lt;p&gt;有时候，我们并不需要查看所有配置的值，而是查看某个配置项的值，怎么做呢？&lt;/p&gt;
&lt;p&gt;命令参数 –get&lt;/p&gt;
&lt;p&gt;格式：&lt;code&gt;git config [–local|–global|–system] –get section.key&lt;/code&gt; (默认是获取 local 配置中内容) 我们先往 global 配置中写入一个 man .name=jim 的配置项，再使用 &lt;code&gt;git config –get man.name&lt;/code&gt; 看看得到的是什么&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;版权声明&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt; by &lt;a href=&quot;http://blog.keepmovingxin.com/about&quot;&gt;KP_小新&lt;/a&gt; 采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;创作共用保留署名-非商业-禁止演绎4.0国际许可证&lt;/a&gt;&lt;br&gt;Copyright © 2016 &lt;a href=&quot;http://blog.keepmovingxin.com&quot;&gt;KeepMoving&lt;/a&gt;. All rights reserved.&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.keepmovingxin.com/2016/04/27/Git-Config/&quot;&gt;http://blog.keepmovingxin.com/2016/04/27/Git-Config/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;git config命令的基本使用&lt;/p&gt;
&lt;h3 id=&quot;配置文件如何生效&quot;&gt;&lt;a href=&quot;#配置文件如何生效&quot; class=&quot;headerlink&quot; title=&quot;配置文件如何生效&quot;&gt;&lt;/a&gt;配置文件如何生效&lt;/h3&gt;&lt;p&gt;对于 git 来说，配置文件的权重是仓库&amp;gt;全局&amp;gt;系统。Git 会使用这一系列的配置文件来存储你定义的偏好，它首先会查找 /etc/gitconfig 文件（系统级），该文件含有对系统上所有用户及他们所拥有的仓库都生效的配置值。接下来 Git 会查找每个用户的 ~/.gitconfig 文件（全局级）。最后 Git 会查找由用户定义的各个库中Git目录下的配置文件 .git/config（仓库级），该文件中的值只对当前所属仓库有效。以上阐述的三 层配置从一般到特殊层层推进，如果定义的值有冲突，以后面层中定义的为准，例如：.git/config 和 /etc/gitconfig 的较量中， .git/config 取得了胜利。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.keepmovingxin.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://blog.keepmovingxin.com/tags/Git/"/>
    
  </entry>
  
</feed>
