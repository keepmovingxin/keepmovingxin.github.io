{"year":"2016","month":"5","permalink":"http:/blog.keepmovingxin.com/archives/2016/5","_total":6,"_totalPage":1,"_page":1,"posts":[{"tags":[{"name":"Lua","permalink":"http://blog.keepmovingxin.com/tags/Lua/","url":"/async/tags/Lua.json","count":2}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":4}],"url":"/async/posts/2016/05/25/Lua-metable.json","date":1464161405000,"path":{"year":2016,"month":5,"day":25,"name":"Lua-metable"},"title":"了解Lua metatable 元表","permalink":"http://blog.keepmovingxin.com/2016/05/25/Lua-metable/","content":"<p>参考lua手册，<code>metatable</code>是被译作元表，Lua 中的每个值都可以用一个 <code>metatable</code>。这个 <code>metatable</code> 就是一个原始的 Lua table，它用来定义原始值在特定操作下的行为。</p>\n<h3 id=\"metatable\"><a href=\"#metatable\" class=\"headerlink\" title=\"metatable\"></a><code>metatable</code></h3><p>一个 <code>metatable</code> 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为，metatable 中还可以定义一个函数，让 <code>userdata</code> 作垃圾收集时调用它。对于这些操作，Lua 都将其关联上一个被称作事件的指定健。当 Lua 需要对一个值发起这些操作中的一个时，它会去检查值中 metatable 中是否有对应事件。如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。</p>"},{"tags":[{"name":"Git","permalink":"http://blog.keepmovingxin.com/tags/Git/","url":"/async/tags/Git.json","count":2}],"categories":[{"name":"工具","permalink":"http://blog.keepmovingxin.com/categories/工具/","url":"/async/categories/工具.json","count":7}],"url":"/async/posts/2016/05/20/Git-Workflow.json","date":1463755288000,"path":{"year":2016,"month":5,"day":20,"name":"Git-Workflow"},"title":"Git 常用命令用法：程序员的场景","permalink":"http://blog.keepmovingxin.com/2016/05/20/Git-Workflow/","content":"<p>Git 相比 Subversion，无论概念上还是使用上，复杂度其实是高出一个等级的。为什么这么说？分别看下 <code>git help -a</code> 和 <code>svn help</code> 命令清单的对比，单按这个来看，就如果要掌握所有命令的用法，Git 的学习曲线绝对是比 Subversion 高的。尽管如此，但还是有越来越多项目开始用 Git 来做源码管理了。</p>\n<p>实际中，我们用到的的 Git 命令还是很有限的，可能也就 <code>git help</code> 中那些而已。下面就类似 <a href=\"http://blog.keepmovingxin.com/2016/05/20/SVN-Workflow/\">SVN命令用法：程序员的场景</a> 一样，结合实际场景说下 Git 的常用命令用法。<br>"},{"tags":[{"name":"SVN","permalink":"http://blog.keepmovingxin.com/tags/SVN/","url":"/async/tags/SVN.json","count":1}],"categories":[{"name":"工具","permalink":"http://blog.keepmovingxin.com/categories/工具/","url":"/async/categories/工具.json","count":7}],"url":"/async/posts/2016/05/20/SVN-Workflow.json","date":1463754719000,"path":{"year":2016,"month":5,"day":20,"name":"SVN-Workflow"},"title":"SVN命令用法：程序员的场景","permalink":"http://blog.keepmovingxin.com/2016/05/20/SVN-Workflow/","content":"<p>SVN有不少命令，其实常用的也就那么几个，可以结合下实际的使用场景，来说明下SVN的命令用法。<br>当然可能对很多人来说，最实用的熟悉方式，就是直接运行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn help (?, h)</span><br></pre></td></tr></table></figure></p>\n<p>就入门了，但为了更好的记忆，有个实际场景也是个不错的选择。<br>注解：括号中的是该命令的缩写或别名，有的可以少打几个字母，后面也有类似描述。<br>"},{"tags":[{"name":"Cocos2d-x","permalink":"http://blog.keepmovingxin.com/tags/Cocos2d-x/","url":"/async/tags/Cocos2d-x.json","count":3},{"name":"Lua","permalink":"http://blog.keepmovingxin.com/tags/Lua/","url":"/async/tags/Lua.json","count":2},{"name":"tolua","permalink":"http://blog.keepmovingxin.com/tags/tolua/","url":"/async/tags/tolua.json","count":1}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":4}],"url":"/async/posts/2016/05/14/Cocos2dx-tolua++.json","date":1463234968000,"path":{"year":2016,"month":5,"day":14,"name":"Cocos2dx-tolua++"},"title":"(译)tolua参考手册--accessing C/C++ code from Lua","permalink":"http://blog.keepmovingxin.com/2016/05/14/Cocos2dx-tolua++/","content":"<p>项目使用Cocos2dx+lua框架做的，用到luabinding实现C++代码绑定到lua层使用，所以学习一下tolua++工具的原理和使用，在这做个记录。</p>\n<p>tolua++是tolua的扩展版本，是一款能够集成C/C++与lua代码的工具。在面向C++方面，tolua++包含了一些新的特性比如：</p>\n<ul>\n<li>支持<code>std::string</code>作为基本类型（这个可以由一个命令行选项关闭）</li>\n<li>支持类模板</li>\n</ul>\n<p><a href=\"http://www.tecgraf.puc-rio.br/~celes/tolua/\">tolua</a>这款工具，极大的简化了C/C++代码与lua代码的集成。基于一个干净的头文件（或者从实际头文件中提取），tolua会自动生成从lua访问C/C++功能的绑定代码。使用Lua API和标记方法设施，tolua解析C/C++常数，外部变量、函数、类和方法绑定到Lua。</p>\n<p><a href=\"http://webserver2.tecgraf.puc-rio.br/~celes/tolua/\">官网</a><br><a href=\"http://webserver2.tecgraf.puc-rio.br/~celes/tolua/tolua-3.2.html\">官网文档</a></p>"},{"tags":[{"name":"Cocos2d-x","permalink":"http://blog.keepmovingxin.com/tags/Cocos2d-x/","url":"/async/tags/Cocos2d-x.json","count":3}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":4}],"url":"/async/posts/2016/05/09/Cocos2dx-CCRenderTexture.json","date":1462804288000,"path":{"year":2016,"month":5,"day":9,"name":"Cocos2dx-CCRenderTexture"},"title":"Cocos2d-x中动态纹理CCRenderTexture的使用","permalink":"http://blog.keepmovingxin.com/2016/05/09/Cocos2dx-CCRenderTexture/","content":"<p>记录一下Cocos2d-x中动态纹理<code>CCRenderTexture</code>的各种应用，实现截屏、阴影等等<br>使用<code>CCRenderTexture</code>需要做以下5步:</p>\n<ol>\n<li>创建一个新的<code>CCRenderTexture</code>. 这里，你可以指定将要创建的纹理的宽度和高度。</li>\n<li>调用 <code>CCRenderTexture:begin</code>. 这个方法会启动OpenGL，并且接下来，任何绘图的命令都会渲染到<code>CCRenderTexture</code>里面去，而不是画到屏幕上。</li>\n<li>绘制纹理. 你可以使用原始的<code>OpenGL</code>调用来绘图，或者你也可以使用cocos2d对象里面已经定义好的<code>visit</code>方法。（这个visit方法就会调用一些opengl命令来绘制cocos2d对象）</li>\n<li>调用 <code>CCRenderTexture:end</code>. 这个方法会渲染纹理，并且会关闭渲染至<code>CCRenderTexture</code>的通道。</li>\n<li>从生成的纹理中创建一个<code>sprite</code>. 你现在可以用<code>CCRenderTexture</code>的<code>sprite.texture</code>属性来轻松创建新的精灵了。</li>\n</ol>"},{"tags":[{"name":"shell","permalink":"http://blog.keepmovingxin.com/tags/shell/","url":"/async/tags/shell.json","count":1}],"categories":[{"name":"工具","permalink":"http://blog.keepmovingxin.com/categories/工具/","url":"/async/categories/工具.json","count":7}],"url":"/async/posts/2016/05/02/Learn-shell.json","date":1462179052000,"path":{"year":2016,"month":5,"day":2,"name":"Learn-shell"},"title":"shell学习笔记","permalink":"http://blog.keepmovingxin.com/2016/05/02/Learn-shell/","content":"<h3 id=\"1-Shell脚本\"><a href=\"#1-Shell脚本\" class=\"headerlink\" title=\"1.Shell脚本\"></a>1.Shell脚本</h3><h4 id=\"1-1-格式\"><a href=\"#1-1-格式\" class=\"headerlink\" title=\"1.1 格式\"></a>1.1 格式</h4><p>首行        #!/bin/bash    指定解释器</p>\n<h4 id=\"1-2-注释\"><a href=\"#1-2-注释\" class=\"headerlink\" title=\"1.2 注释\"></a>1.2 注释</h4><p>‘#’开头的行，’#!’是例外</p>\n<p>此外，# 是特殊字符，可以出现在一些参数代换结构和在数值常量表达式中，具有特殊含义，而不会开启一个注释。‘#’也不会开启一个注释。</p>"}]}