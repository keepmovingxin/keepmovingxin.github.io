{"tags":[{"name":"Linux","permalink":"http://blog.keepmovingxin.com/tags/Linux/","url":"/async/tags/Linux.json","count":1}],"categories":[{"name":"工具","permalink":"http://blog.keepmovingxin.com/categories/工具/","url":"/async/categories/工具.json","count":5}],"url":"/async/posts/2016/04/28/Linux-Commond.json","date":1461830572000,"path":{"year":2016,"month":4,"day":28,"name":"Linux-Commond"},"title":"Linux常用命令学习","permalink":"http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/","content":"<h3 id=\"同步时间\"><a href=\"#同步时间\" class=\"headerlink\" title=\"同步时间\"></a>同步时间</h3><p>以管理员身份执行如下命令，可以自动与网络时间同步：<br>time.nist.gov 是一个时间服务器</p>\n<p><code>$ rdate -s time.nist.gov</code></p>\n<a id=\"more\"></a>\n<h3 id=\"管道符：\"><a href=\"#管道符：\" class=\"headerlink\" title=\"管道符： |\"></a>管道符： |</h3><p>就是把前面的命令运行的要放入标准输出的结果丢给后面的命令</p>\n<p><code>cat 1.txt | cat</code></p>\n<h3 id=\"echo\"><a href=\"#echo\" class=\"headerlink\" title=\"echo\"></a>echo</h3><p>-n    打印语句后不会换行。</p>\n<p>-e 开启转义，即可以打印后面的 \\t,\\r 等转义字符</p>\n<p>可以打印彩色文本。</p>\n<h3 id=\"printf\"><a href=\"#printf\" class=\"headerlink\" title=\"printf\"></a>printf</h3><p>用于格式化输出，使用的参数和C语言中的printf函数一样</p>\n<p>eg：printf “%-5s %-10s %-4.2f\\n” 1 James 80.9968</p>\n<p>-：表示左对齐，默认为右对齐</p>\n<p>s：表示打印的是字符串</p>\n<p>f：表示打印一个浮点数，其中4表示宽度，.2表示保留2位小数</p>\n<p>printf默认不带换行，需要手动添加</p>\n<h3 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h3><p>查看文件</p>\n<p>-n：为每行前面加上行号。-n会为空白行也加上行号，-b选项则会跳过空白行。</p>\n<p>-s：压缩相邻的空白行，即连续的空白行将压缩为一行。</p>\n<p>-T：用^I符号表示制表符\\t</p>\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><p>由一般字符和特殊字符（meta字符）组成</p>\n<p>meta元字符</p>\n<p>\\ 通常用于打开或关闭后续字符的特殊含义，如(…)与{…}</p>\n<p>. 匹配任何单个字符（除NULL）</p>\n<p>* 匹配前面的子表达式任意次，例：a* 匹配任意多个a</p>\n<p>? 匹配前面的子表达式零次或一次匹配前面的子表达式一次或多次。</p>\n<p>+ 匹配前面的子表达式一次或多次</p>\n<p>^ 匹配输入字符串的开始位置</p>\n<p>$ 匹配输入字符串的结束位置</p>\n<p>[] 匹配方括号内的任一字符，其中可用连字符（-）指的连续字符的范围；^符号若出现在方括号的第一个位置，则表示匹配不在列表中的任一字符</p>\n<p>(x|y) 匹配x或y，比如：(g|f)ood，匹配good或food</p>\n<h3 id=\"文件通配符\"><a href=\"#文件通配符\" class=\"headerlink\" title=\"文件通配符\"></a>文件通配符</h3><p>* 匹配文件名中的任何字符串，包括空字符串。</p>\n<p>? 匹配文件名中的任何单个字符。</p>\n<p>[…] 匹配[ ]中所包含的任何字符。可以用 – 连接，表示范围</p>\n<p>[!…] 匹配[ ]中非 感叹号！之后的字符。</p>\n<p>如：</p>\n<p>5* 5开头的所有字符串</p>\n<p>*5 5结尾的所有字符串</p>\n<p>*5? 以5为倒数第二个字符的字符串</p>\n<p>[0－9] 所有以数字的字符</p>\n<p>[1,2] 1或者2</p>\n<p>[!0-9] 不是数字的字符</p>\n<h3 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h3><p>grep [options] [表达式]</p>\n<p>1)    [options]列表：</p>\n<pre><code>-c    ：只输出匹配行的统计数\n\n-n    ：显示匹配行及行号\n\n-A2    ：列出匹配行及下面2行\n\n-B2    ：列出匹配行及上面2行\n\n-C2    ：列出匹配行及上下2行\n\n-I    ：不区分大小写(只适用于单字符)\n\n-h    ：查询多文件时不显示文件名\n\n-H    ：查询多文件时显示文件名（默认）\n\n-l    ：查询多文件时只输出包含匹配字符的文件名\n\n-o    : 每行只输出匹配部分\n\n-s    ：不显示不存在或无匹配文本的错误信息\n\n-v    ：显示不包含匹配文本的所有行\n\n-r    ：递归匹配目录下所有文件及目录\n\n-E    : 扩展grep，增加了额外的正则表达式元字符集\n\n-e    ：指定多个匹配样式，样式间“或”的关系\n\n-f pattern_file    ：    样式文件pattern_file中逐行存放要匹配的样式，可匹配多个样式，样式之间是“或”的关系\n\n--color    ：    为匹配项显示不同颜色\n</code></pre><p>2)    grep –E “pattern1|pattern2” files ：显示匹配 pattern1 或 pattern2 的行</p>\n<p>3)    grep –e pattern1 –e pattern2 files : 匹配pattern1或pattern2</p>\n<p>4)    grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行</p>\n<p>5)    egrep “t_hero|t_item”   匹配t_hero或者t_item的项</p>\n<p>6)    grep “t_hero|t_item”    可以实现与上面同样的功能</p>\n<h3 id=\"sed\"><a href=\"#sed\" class=\"headerlink\" title=\"sed\"></a>sed</h3><p>sed [options] ‘command’ file(s) 或sed [options] -f scriptfile file(s)</p>\n<p>一次处理一行内容 不改变文件内容</p>\n<p>[options]列表：</p>\n<pre><code>-n    :    取消默认的输出,使用安静(silent)模式。\n\n-r    :    使用正则表达式，及表达式中不需要进行转义\n\n-f filename :    指定sed脚本的文件名filename\n\n-e &apos;&apos; :    允许多重编辑·  \n\n-i    :    将替换结果应用于源文件\n</code></pre><p>1)    替换字符串</p>\n<p><code>sed &#39;s/pattern/string/&#39; file</code></p>\n<p>或者</p>\n<p><code>cat file | sed &#39;s/pattern/string/&#39;</code></p>\n<p>2)    替换文件中所有匹配内容，使用参数g</p>\n<p><code>sed &#39;s/pattern/string/g&#39; file</code></p>\n<p>但如果你想从第N处匹配开始替换，可以使用参数/Ng</p>\n<p><code>$ echo thisthisthisthis | sed &#39;s/this/THIS/2g&#39;\nthisTHISTHISTHIS</code></p>\n<p>3)    sed的定界符’/‘.当匹配模式中含有’/‘字符时，我们需要用’\\’对定界符’/‘进行转义</p>\n<p><code>$ echo a/b | sed &#39;s/a\\/b/a*b/&#39;\na*b</code></p>\n<p>为了避免转义字符造成的理解困难，我们可以使用其它定界符，比如|,:,@,#,$,%,+等等</p>\n<p><code>$ echo a/b | sed &#39;s:a/b:a*b:&#39;\na*b</code></p>\n<p>4)    移除匹配样式行  <code>sed &#39;/pattern/d&#39; file</code></p>\n<p><code>$ sed -r &#39;/^ *$/d&#39; args.txt        #移除空白行，含有一个或多个空格的行</code></p>\n<p>5)    组合多个表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo abd | sed &apos;s/a/A/&apos; | sed &apos;s/d/D/&apos;  #用管道组合\r$ echo abd | sed &apos;s/a/A/;s/d/D/&apos;           #用分号组合\r$ echo abd | sed -e &apos;s/a/A/&apos; -e &apos;s/d/D/&apos;  #用-e选项组合</span><br></pre></td></tr></table></figure>\n<p>6)    已匹配字符串标记（&amp;）</p>\n<p>&amp;代表匹配给定样式的字符串，常用于对给定样式增加[]，{}等不需要改变样式的情况</p>\n<pre><code>$ echo &quot;this is an example&quot; | sed &apos;s/\\w\\+/[&amp;]/g&apos;   #\\w\\+ 匹配每个单词\n[this] [is] [an] [example]\n</code></pre><p>7)    子串匹配标记（\\1）</p>\n<p>有时我们希望对匹配给定的样式标记出一些子串来，方便后续引用</p>\n<p>(pattern) 用于匹配子串pattern</p>\n<p>\\1 用于引用第一个匹配到的子串，\\n 对应第n个匹配到的子串。</p>\n<pre><code>$ echo 123 asd | sed &apos;s/\\([0-9]\\+\\) \\([a-z]\\+\\)/\\2+\\1/&apos; \nasd+123\n</code></pre><p>其中\\1对应数字123，\\2对应字母asd</p>\n<p>对于子串的引用，在样式里一定要用()括起来，如果加上-r选项，则不需要转义：</p>\n<pre><code>$ echo 123 asd | sed -r &apos;s/([0-9]+) ([a-z]+)/\\2+\\1/&apos;\nasd+123\n</code></pre><p>8)    引用</p>\n<p>在脚本中有用的一点，用双引号引用的sed表达式，会对表达式求值来进行扩展，如使用前面定义的变量等</p>\n<pre><code>$ text=hello\n$ echo hello world | sed &quot;s/$text/HELLO/&quot;\nHELLO world\n</code></pre><h3 id=\"tail\"><a href=\"#tail\" class=\"headerlink\" title=\"tail\"></a>tail</h3><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件</p>\n<p>主要参数</p>\n<pre><code>-f ：    循环读取   #可以用在监控线上有没有报错信息\n\n-q ：    不显示处理信息\n\n-v ：    显示详细的处理信息\n\n-c&lt;数目&gt; ：    显示的字节数\n\n-n&lt;行数&gt; ：    显示行数\n\n--pid=PID ：    与-f合用,表示在进程ID,PID死掉之后结束. \n\n-q, --quiet, --silent ：    从不输出给出文件名的首部\n</code></pre><h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p><code>find dir [option] &#39;command&#39;</code><br><code>dir</code>: 目录名，用空格隔开多个目录<br>1) [option]列表：</p>\n<pre><code>-name wildcard 文件名，wildcard表示通配符，并非正则式\n    find dir1 dir2 -name &apos;*.c&apos; –print  在目录dir1和dir2中查找文件，并打印路径\n    如果在-name后面紧跟一个-prune，则表示此目录应被修剪\n    find . \\( -name &quot;.svn&quot; -prune \\) -o –print 表示对于查找的目录，要么修剪掉（.svn），要么打印出来（其他）。\n-iname 忽略名字大小写\n-path 指定目录，如果在-path前面加上 ！ ，则表示忽略此目录，目录名可以使用通配符匹配。\n-type 文件类型\n    f:普通文件 d:目录 l:符号连接文件 c:字符设备文件 b:块设备文件 p:管道文件\n-size ±nc 查找大于（+）或小于（-）n字节的文件，注意c（charter）\n-mtime ±ndays 文件最近修改时间\n-user,-nouser 文件所有者\n-group,-nogroup 指定文件用户组\n多条件的与（-a）/或（-o）/非（！）\n    find . \\( -name &quot;*.txt&quot; –o –name &quot;*.sh&quot; \\) –print\n    括号两边应该有空格\n-maxdepth n 指定最大目录深度，n=1表示最大为当前目录\n-mindepth n 指定最小目录深度，n=2表示不打印当前目录下的文件\n  -maxdepth和-mindepth应作为find的第三个参数出现，以提高效率\n</code></pre><p>2) ‘command’命令列表：</p>\n<pre><code>-print  打印路径名\n-delete 对找到的文件进行删除 \n-exec   对查找到的目标执行某一命令。\n    find ${workdir} -name &quot;$filename&quot; -exec  |grep $uid\n    -exec 参数后面跟的是bash命令，但只能跟一个命令，如果想执行多个命令，那么可以将多个命令放进一个shell脚本，然后执行这个脚本。\n    bash命令的终止，使用 &apos;;&apos; (分号）来判定，在后面必须有一个 &apos;;&apos;在分号前应该加上转义字符&apos;\\&apos;\n    &apos;{}&apos;，使用{}来表示文件名，也就是find前面处理过程中过滤出来的文件，用于bash命令进行处理\n-ok     与-exec类似，只是对查找到符合条件的目标执行一个命令前需要经过确认\n</code></pre><h3 id=\"cut\"><a href=\"#cut\" class=\"headerlink\" title=\"cut\"></a>cut</h3><p><code>cut</code> 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出，必须指定 <code>-b</code>、<code>-c</code> 或<code>-f</code> 标志之一。<br>主要参数</p>\n<pre><code>-b: 以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。\n-c: 以字符为单位进行分割。（单个字母等）\n    cut –c2-5 file    ，表示将文件file每行的第2-5个字符作为一列显示出来。\n-d: 自定义分隔符，默认为制表符。\n-f: 与-d一起使用，指定显示哪个区域。\n    例子：cat file.txt | cut -d&apos;]&apos; -f7；\n        cat file.txt | cut -d&apos;]&apos; –f4,7；//打印4和7列\n        cat file.txt | cut -d&apos;]&apos; –f4-7；//打印4到7列\n-n: 取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的&lt;br /&gt;范围之内，该字符将被写出；否则，该字符将被排除。\n--complement: 与-f一起使用，指定显示哪个区域的补集。\n</code></pre><h3 id=\"sort-排序\"><a href=\"#sort-排序\" class=\"headerlink\" title=\"sort  排序\"></a>sort  排序</h3><p><code>sort</code>将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按<code>ASCII</code>码值进行比较，最后将他们按升序输出。<br>主要参数：</p>\n<pre><code>-u: 去除重复行\n-r: sort默认的排序方式是升序，如果想改成降序，用此参数\n-o file: 把排序结果输出到文件file，file可以是原文件\n-n: 以数值排序\n-t: 指定间隔符\n-k: 指定域排序，常与-t连用。sort –t &apos;:&apos; –k 2\n    在指定域的时候还可细分，比如指定第二个域的第3个字符开始比较，用-k 2.3;\n    比如指定第二个域的第3个字符到第二个域的第5个字符进行排序，用-k 2.3,2.5\n    比如只指定第二个域的第3个字符进行排序，用-k 2.3,2.3\n-b: 忽略每一行前面的所有空白部分，从第一个可见字符开始比较\n-f: 忽略大小写进行排序\n</code></pre><h3 id=\"未完待续…\"><a href=\"#未完待续…\" class=\"headerlink\" title=\"未完待续…\"></a>未完待续…</h3><hr>\n<p><strong>版权声明</strong><br>Copyright © 2016 <a href=\"http://blog.keepmovingxin.com/\">KeepMoving</a>. All rights reserved.<br>原文链接：<a href=\"http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/\">http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/</a></p>\n"}