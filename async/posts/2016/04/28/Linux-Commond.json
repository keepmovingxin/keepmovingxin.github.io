{"tags":[{"name":"Linux","permalink":"http://blog.keepmovingxin.com/tags/Linux/","url":"/async/tags/Linux.json","count":1}],"categories":[{"name":"工具","permalink":"http://blog.keepmovingxin.com/categories/工具/","url":"/async/categories/工具.json","count":7}],"url":"/async/posts/2016/04/28/Linux-Commond.json","date":1461830572000,"path":{"year":2016,"month":4,"day":28,"name":"Linux-Commond"},"title":"Linux常用命令学习","permalink":"http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/","content":"<h3 id=\"同步时间\"><a href=\"#同步时间\" class=\"headerlink\" title=\"同步时间\"></a>同步时间</h3><p>以管理员身份执行如下命令，可以自动与网络时间同步：<br>time.nist.gov 是一个时间服务器</p>\n<p><code>$ rdate -s time.nist.gov</code></p>\n<a id=\"more\"></a>\n<h3 id=\"管道符：\"><a href=\"#管道符：\" class=\"headerlink\" title=\"管道符： |\"></a>管道符： |</h3><p>就是把前面的命令运行的要放入标准输出的结果丢给后面的命令</p>\n<p><code>cat 1.txt | cat</code></p>\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><p>由一般字符和特殊字符（meta字符）组成<br>meta元字符</p>\n<pre><code>\\ 通常用于打开或关闭后续字符的特殊含义，如\\(...\\)与\\{...\\}\n. 匹配任何单个字符（除NULL）\n\\* 匹配前面的子表达式任意次，例：a* 匹配任意多个a\n? 匹配前面的子表达式零次或一次匹配前面的子表达式一次或多次。\n\\+ 匹配前面的子表达式一次或多次\n^ 匹配输入字符串的开始位置\n$ 匹配输入字符串的结束位置\n[] 匹配方括号内的任一字符，其中可用连字符（-）指的连续字符的范围；^符号若出现在方括号的第一个位置，则表示匹配不在列表中的任一字符\n(x|y) 匹配x或y，比如：(g|f)ood，匹配good或food\n</code></pre><h3 id=\"文件通配符\"><a href=\"#文件通配符\" class=\"headerlink\" title=\"文件通配符\"></a>文件通配符</h3><pre><code>\\* 匹配文件名中的任何字符串，包括空字符串。\n? 匹配文件名中的任何单个字符。\n[...] 匹配[ ]中所包含的任何字符。可以用 – 连接，表示范围\n[!...] 匹配[ ]中非 感叹号！之后的字符。\n</code></pre><p>如：</p>\n<pre><code>5* 5开头的所有字符串\n*5 5结尾的所有字符串\n*5? 以5为倒数第二个字符的字符串\n[0－9] 所有以数字的字符\n[1,2] 1或者2\n[!0-9] 不是数字的字符\n</code></pre><h3 id=\"echo-打印\"><a href=\"#echo-打印\" class=\"headerlink\" title=\"echo 打印\"></a>echo 打印</h3><pre><code>-n    打印语句后不会换行。\n-e 开启转义，即可以打印后面的 \\t,\\r 等转义字符\n可以打印彩色文本。\n</code></pre><h3 id=\"printf-格式化输出\"><a href=\"#printf-格式化输出\" class=\"headerlink\" title=\"printf 格式化输出\"></a>printf 格式化输出</h3><p>用于格式化输出，使用的参数和C语言中的printf函数一样<br>eg：printf “%-5s %-10s %-4.2f\\n” 1 James 80.9968</p>\n<pre><code>-：表示左对齐，默认为右对齐\ns：表示打印的是字符串\nf：表示打印一个浮点数，其中4表示宽度，.2表示保留2位小数\n</code></pre><p>printf默认不带换行，需要手动添加</p>\n<h3 id=\"cat-查看文件\"><a href=\"#cat-查看文件\" class=\"headerlink\" title=\"cat 查看文件\"></a>cat 查看文件</h3><pre><code>-n：为每行前面加上行号。-n会为空白行也加上行号，-b选项则会跳过空白行。\n-s：压缩相邻的空白行，即连续的空白行将压缩为一行。\n-T：用^I符号表示制表符\\t\n</code></pre><h3 id=\"grep-匹配\"><a href=\"#grep-匹配\" class=\"headerlink\" title=\"grep 匹配\"></a>grep 匹配</h3><p>grep [options] [表达式]<br>1)    [options]列表：</p>\n<pre><code>-c    ：只输出匹配行的统计数\n-n    ：显示匹配行及行号\n-A2    ：列出匹配行及下面2行\n-B2    ：列出匹配行及上面2行\n-C2    ：列出匹配行及上下2行\n-I    ：不区分大小写(只适用于单字符)\n-h    ：查询多文件时不显示文件名\n-H    ：查询多文件时显示文件名（默认）\n-l    ：查询多文件时只输出包含匹配字符的文件名\n-o    : 每行只输出匹配部分\n-s    ：不显示不存在或无匹配文本的错误信息\n-v    ：显示不包含匹配文本的所有行\n-r    ：递归匹配目录下所有文件及目录\n-E    : 扩展grep，增加了额外的正则表达式元字符集\n-e    ：指定多个匹配样式，样式间“或”的关系\n-f pattern_file    ：    样式文件pattern_file中逐行存放要匹配的样式，可匹配多个样式，样式之间是“或”的关系\n--color    ：    为匹配项显示不同颜色\n</code></pre><p>2)    <code>grep –E &quot;pattern1|pattern2&quot; files</code> ：显示匹配 pattern1 或 pattern2 的行<br>3)    <code>grep –e pattern1 –e pattern2 files</code> : 匹配pattern1或pattern2<br>4)    <code>grep pattern1 files | grep pattern2</code> ：显示既匹配 pattern1 又匹配 pattern2 的行<br>5)    <code>egrep &quot;t_hero|t_item&quot;</code>   匹配t_hero或者t_item的项<br>6)    <code>grep &quot;t_hero\\|t_item&quot;</code>    可以实现与上面同样的功能</p>\n<h3 id=\"sed-处理内容\"><a href=\"#sed-处理内容\" class=\"headerlink\" title=\"sed 处理内容\"></a>sed 处理内容</h3><p><code>sed [options] &#39;command&#39; file(s) 或sed [options] -f scriptfile file(s)</code></p>\n<p>一次处理一行内容 不改变文件内容<br>[options]列表：</p>\n<pre><code>-n    :    取消默认的输出,使用安静(silent)模式。\n-r    :    使用正则表达式，及表达式中不需要进行转义\n-f filename :    指定sed脚本的文件名filename\n-e &apos;&apos; :    允许多重编辑·  \n-i    :    将替换结果应用于源文件\n</code></pre><p>1)    替换字符串<br><code>sed &#39;s/pattern/string/&#39; file</code><br>或者<br><code>cat file | sed &#39;s/pattern/string/&#39;</code></p>\n<p>2)    替换文件中所有匹配内容，使用参数g<br><code>sed &#39;s/pattern/string/g&#39; file</code><br>但如果你想从第N处匹配开始替换，可以使用参数/Ng<br><code>$ echo thisthisthisthis | sed &#39;s/this/THIS/2g&#39;\nthisTHISTHISTHIS</code></p>\n<p>3)    sed的定界符’/‘.当匹配模式中含有’/‘字符时，我们需要用’\\’对定界符’/‘进行转义<br><code>$ echo a/b | sed &#39;s/a\\/b/a*b/&#39;\na*b</code><br>为了避免转义字符造成的理解困难，我们可以使用其它定界符，比如|,:,@,#,$,%,+等等<br><code>$ echo a/b | sed &#39;s:a/b:a*b:&#39;\na*b</code></p>\n<p>4)    移除匹配样式行  <code>sed &#39;/pattern/d&#39; file</code><br><code>$ sed -r &#39;/^ *$/d&#39; args.txt        #移除空白行，含有一个或多个空格的行</code></p>\n<p>5)    组合多个表达式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo abd | sed &apos;s/a/A/&apos; | sed &apos;s/d/D/&apos;  #用管道组合\r$ echo abd | sed &apos;s/a/A/;s/d/D/&apos;           #用分号组合\r$ echo abd | sed -e &apos;s/a/A/&apos; -e &apos;s/d/D/&apos;  #用-e选项组合</span><br></pre></td></tr></table></figure></p>\n<p>6)    已匹配字符串标记（&amp;）<br>&amp;代表匹配给定样式的字符串，常用于对给定样式增加[]，{}等不需要改变样式的情况</p>\n<pre><code>$ echo &quot;this is an example&quot; | sed &apos;s/\\w\\+/[&amp;]/g&apos;   #\\w\\+ 匹配每个单词\n[this] [is] [an] [example]\n</code></pre><p>7)    子串匹配标记（\\1）<br>有时我们希望对匹配给定的样式标记出一些子串来，方便后续引用<br>(pattern) 用于匹配子串pattern<br>\\1 用于引用第一个匹配到的子串，\\n 对应第n个匹配到的子串。</p>\n<pre><code>$ echo 123 asd | sed &apos;s/\\([0-9]\\+\\) \\([a-z]\\+\\)/\\2+\\1/&apos; \nasd+123\n</code></pre><p>其中\\1对应数字123，\\2对应字母asd<br>对于子串的引用，在样式里一定要用()括起来，如果加上-r选项，则不需要转义：</p>\n<pre><code>$ echo 123 asd | sed -r &apos;s/([0-9]+) ([a-z]+)/\\2+\\1/&apos;\nasd+123\n</code></pre><p>8)    引用<br>在脚本中有用的一点，用双引号引用的sed表达式，会对表达式求值来进行扩展，如使用前面定义的变量等</p>\n<pre><code>$ text=hello\n$ echo hello world | sed &quot;s/$text/HELLO/&quot;\nHELLO world\n</code></pre><h3 id=\"tail-查看文件\"><a href=\"#tail-查看文件\" class=\"headerlink\" title=\"tail 查看文件\"></a>tail 查看文件</h3><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件<br>主要参数</p>\n<pre><code>-f ：    循环读取   #可以用在监控线上有没有报错信息\n-q ：    不显示处理信息\n-v ：    显示详细的处理信息\n-c&lt;数目&gt; ：    显示的字节数\n-n&lt;行数&gt; ：    显示行数\n--pid=PID ：    与-f合用,表示在进程ID,PID死掉之后结束. \n-q, --quiet, --silent ：    从不输出给出文件名的首部\n</code></pre><h3 id=\"find-查找\"><a href=\"#find-查找\" class=\"headerlink\" title=\"find 查找\"></a>find 查找</h3><p><code>find dir [option] &#39;command&#39;</code><br><code>dir</code>: 目录名，用空格隔开多个目录<br>1) [option]列表：</p>\n<pre><code>-name wildcard 文件名，wildcard表示通配符，并非正则式\n    find dir1 dir2 -name &apos;*.c&apos; –print  在目录dir1和dir2中查找文件，并打印路径\n    如果在-name后面紧跟一个-prune，则表示此目录应被修剪\n    find . \\( -name &quot;.svn&quot; -prune \\) -o –print 表示对于查找的目录，要么修剪掉（.svn），要么打印出来（其他）。\n-iname 忽略名字大小写\n-path 指定目录，如果在-path前面加上 ！ ，则表示忽略此目录，目录名可以使用通配符匹配。\n-type 文件类型\n    f:普通文件 d:目录 l:符号连接文件 c:字符设备文件 b:块设备文件 p:管道文件\n-size ±nc 查找大于（+）或小于（-）n字节的文件，注意c（charter）\n-mtime ±ndays 文件最近修改时间\n-user,-nouser 文件所有者\n-group,-nogroup 指定文件用户组\n多条件的与（-a）/或（-o）/非（！）\n    find . \\( -name &quot;*.txt&quot; –o –name &quot;*.sh&quot; \\) –print\n    括号两边应该有空格\n-maxdepth n 指定最大目录深度，n=1表示最大为当前目录\n-mindepth n 指定最小目录深度，n=2表示不打印当前目录下的文件\n  -maxdepth和-mindepth应作为find的第三个参数出现，以提高效率\n</code></pre><p>2) ‘command’命令列表：</p>\n<pre><code>-print  打印路径名\n-delete 对找到的文件进行删除 \n-exec   对查找到的目标执行某一命令。\n    find ${workdir} -name &quot;$filename&quot; -exec  |grep $uid\n    -exec 参数后面跟的是bash命令，但只能跟一个命令，如果想执行多个命令，那么可以将多个命令放进一个shell脚本，然后执行这个脚本。\n    bash命令的终止，使用 &apos;;&apos; (分号）来判定，在后面必须有一个 &apos;;&apos;在分号前应该加上转义字符&apos;\\&apos;\n    &apos;{}&apos;，使用{}来表示文件名，也就是find前面处理过程中过滤出来的文件，用于bash命令进行处理\n-ok     与-exec类似，只是对查找到符合条件的目标执行一个命令前需要经过确认\n</code></pre><h3 id=\"cut-剪切\"><a href=\"#cut-剪切\" class=\"headerlink\" title=\"cut 剪切\"></a>cut 剪切</h3><p><code>cut</code> 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出，必须指定 <code>-b</code>、<code>-c</code> 或<code>-f</code> 标志之一。<br>主要参数</p>\n<pre><code>-b: 以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。\n-c: 以字符为单位进行分割。（单个字母等）\n    cut –c2-5 file    ，表示将文件file每行的第2-5个字符作为一列显示出来。\n-d: 自定义分隔符，默认为制表符。\n-f: 与-d一起使用，指定显示哪个区域。\n    例子：cat file.txt | cut -d&apos;]&apos; -f7；\n        cat file.txt | cut -d&apos;]&apos; –f4,7；//打印4和7列\n        cat file.txt | cut -d&apos;]&apos; –f4-7；//打印4到7列\n-n: 取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的&lt;br /&gt;范围之内，该字符将被写出；否则，该字符将被排除。\n--complement: 与-f一起使用，指定显示哪个区域的补集。\n</code></pre><h3 id=\"sort-排序\"><a href=\"#sort-排序\" class=\"headerlink\" title=\"sort 排序\"></a>sort 排序</h3><p><code>sort</code>将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按<code>ASCII</code>码值进行比较，最后将他们按升序输出。<br>主要参数：</p>\n<pre><code>-u: 去除重复行\n-r: sort默认的排序方式是升序，如果想改成降序，用此参数\n-o file: 把排序结果输出到文件file，file可以是原文件\n-n: 以数值排序\n-t: 指定间隔符\n-k: 指定域排序，常与-t连用。sort –t &apos;:&apos; –k 2\n    在指定域的时候还可细分，比如指定第二个域的第3个字符开始比较，用-k 2.3;\n    比如指定第二个域的第3个字符到第二个域的第5个字符进行排序，用-k 2.3,2.5\n    比如只指定第二个域的第3个字符进行排序，用-k 2.3,2.3\n-b: 忽略每一行前面的所有空白部分，从第一个可见字符开始比较\n-f: 忽略大小写进行排序\n</code></pre><h3 id=\"uniq-去重\"><a href=\"#uniq-去重\" class=\"headerlink\" title=\"uniq 去重\"></a>uniq 去重</h3><pre><code>-c : 统计重复的行数\n-u : 只显示不重复的那些行\n-d : 只显示重复的那些行\n-s n : 指定跳过前n个字符\n-w n : 指定用于比较的最大字符数\n</code></pre><h3 id=\"wc-统计\"><a href=\"#wc-统计\" class=\"headerlink\" title=\"wc 统计\"></a>wc 统计</h3><p>使用wc的各种选项来统计行数、单词数和字符数。<br>主要参数：</p>\n<pre><code>-l ：行数\n-w ：单词数\n-c ：字符数\n</code></pre><h3 id=\"seq-产生整数\"><a href=\"#seq-产生整数\" class=\"headerlink\" title=\"seq 产生整数\"></a>seq 产生整数</h3><p><code>seq A B</code>: 用于产生从某个数到另外一个数之间的所有整数<br>主要参数：</p>\n<pre><code>-f：指定格式。默认是&quot;%g&quot;，表示按宽度为1输出。可以在g的前面加入一些字符，表示不同的含义，如：\n   %2g：表示按宽度为2右对齐。\n   %02g：表示按宽度为2右对齐，不足的部分用0补足。\n</code></pre><p>可用于构造日志文件名</p>\n<pre><code>for i in `seq -f &quot;log.20160407&quot;%02g 5 12`; do echo $i; done\n   str%03g：表示按宽度为3右对齐，补足的位数用0补，并在前面加上str子串。\n    %-3g：表示按宽度为3左对齐。\n</code></pre><h3 id=\"mkdir-创建目录\"><a href=\"#mkdir-创建目录\" class=\"headerlink\" title=\"mkdir 创建目录\"></a>mkdir 创建目录</h3><p>常用参数：</p>\n<pre><code>-p: 可以是一个路径名称。此时若路径中的某些目录尚不存在，加上此选项后,系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录;\n-m &lt;777&gt;: 模式，设定权限&lt;模式&gt;\n-v: 在创建目录的同时输出信息。\n</code></pre><h3 id=\"date-时间\"><a href=\"#date-时间\" class=\"headerlink\" title=\"date 时间\"></a>date 时间</h3><p>1) 显示时间</p>\n<pre><code>date [OPTION]... [+FORMAT]\ndate &quot;+%Y-%m-%d %H:%M:%S&quot;  #显示当前的年月日时分秒\n</code></pre><p>2) 设置时间</p>\n<pre><code>date -s //设置当前时间，只有root权限才能设置，其他只能查看。\ndate -s 20080523 //设置成20080523，这样会把具体时间设置成空00:00:00\ndate -s 15:20:30 //设置时间\ndate +%s //当前时间时间戳\n</code></pre><p>3) 转换时间<br>把linux下的时间戳转换成现实中的年月日时分秒</p>\n<pre><code>date –d @timestamp\neg:$date -d @1433087999\n 2015年 05月 31日 星期日 23:59:59 CST\n</code></pre><h3 id=\"md5sum-MD5\"><a href=\"#md5sum-MD5\" class=\"headerlink\" title=\"md5sum MD5\"></a>md5sum MD5</h3><p>MD5全称是报文摘要算法（Message-Digest Algorithm 5），此算法对任意长度的信息逐位进行计算，产生一个二进制长度为128位（十六进制长度32位）的“指纹”（或称“报文摘要”），即使两个文件只相差一个字符，产生的校验和也完全不同。<br>1) 使用md5sum来产生指纹（报文摘要）命令如下：<br>     <code>md5sum file &gt; file.md5</code><br>若不指定文件名，则从标准输入读取，也可输出到标准输出设备，因此可与管道符“|”连用。<br> 可以使用文件通配符，将多个文件的md5值输出到同一个文件。<br>文件file.md5的内容如下：<br>      <code>c0e207c045c344ebf363c3e9a6de1076  file</code><br> 第一列是md5校验和，第二列是对应文件名。<br>2) 使用md5报文摘要验证文件。<br>将生成的file.md5文件放在对应file文件的同一目录下。使用如下命令验证：<br>     <code>md5sum -c file.md5</code><br>若验证成功，输出“file: 确定”；验证失败则输出“file: 失败”，并打印警告信息：“md5sum: 警告：1/1 生成的校验和不匹配”。</p>\n<h3 id=\"ln-链接\"><a href=\"#ln-链接\" class=\"headerlink\" title=\"ln 链接\"></a>ln 链接</h3><p>主要参数：</p>\n<pre><code>-f : 链结时先将与 dist 同档名的档案删除\n-d : 允许系统管理者硬链结自己的目录\n-i : 在删除与 dist 同档名的档案时先进行询问\n-n : 在进行软连结时，将 dist 视为一般的档案\n-s : 进行软链结(symbolic link)\n     ln –s target new\n     为target文件建立一个软链接new指向target\n-v : 在连结之前显示其档名\n-b : 将在链结时会被覆写或删除的档案进行备份\n-S SUFFIX : 将备份的档案都加上 SUFFIX 的字尾\n-V METHOD : 指定备份的方式\n--help : 显示辅助说明\n--version : 显示版本\n</code></pre><h3 id=\"split-大文件切割\"><a href=\"#split-大文件切割\" class=\"headerlink\" title=\"split 大文件切割\"></a>split 大文件切割</h3><p> <code>split -b 500m file newfile_prefix</code></p>\n<pre><code>-l：行数，指定每多少行切成一个小文件。\n-b：指定每多少字就要切成一个小文件。支持单位:m,k\n-C：与-b参数类似，但切割时尽量维持每行的完整性。\n-d：指定切割后的文件名以数字作为后缀\n</code></pre><p>合并： <code>cat newfile_prefix* &gt; newfile</code></p>\n<h3 id=\"alias-别名\"><a href=\"#alias-别名\" class=\"headerlink\" title=\"alias 别名\"></a>alias 别名</h3><p><code>alias myssh=’sh filename.sh’</code></p>\n<h3 id=\"chmod-权限\"><a href=\"#chmod-权限\" class=\"headerlink\" title=\"chmod 权限\"></a>chmod 权限</h3><p>使用chmod命令设置文件权限。<br><code>chmod a+x file</code></p>\n<pre><code>u ： 指定用户权限\ng ： 指定用户组权限\no ： 指定其他用户权限\na ： 指定所有类别\n+ ： 增加权限\n- ： 删除权限\nr ： 可读\nw ： 可写\nx ： 可执行，对目录文件来说表示可访问目录中的文件和子目录\n</code></pre><h3 id=\"vim-文本编辑工具\"><a href=\"#vim-文本编辑工具\" class=\"headerlink\" title=\"vim 文本编辑工具\"></a>vim 文本编辑工具</h3><p><code>vimdiff</code> 文本差异对比<br><code>vimdiff  FILE_LEFT  FILE_RIGHT</code><br>常用命令：</p>\n<pre><code>Ctrl-w K 把当前窗口移到最上边\nCtrl-w H 把当前窗口移到最左边\nCtrl-w J 把当前窗口移到最下边\nCtrl-w L 把当前窗口移到最右边\nCtrl-w,w  在两个文件之间来回跳转\n]c   跳转到下一差异点\n[c   跳转到上一差异点，可在前面加上数字，表示跳转多少个差异\ndp(diff put) 把一个差异点中当前文件的内容复制到另一个文件中\ndo(diff get) 另一个文件的内容复制到当前行中\n:diffupdate 手工来刷新比较结果\nzo(folding open) 展开被折叠的相同的文本行\nzc(folding close) 重新折叠\n</code></pre><h3 id=\"paste-拼接\"><a href=\"#paste-拼接\" class=\"headerlink\" title=\"paste 拼接\"></a>paste 拼接</h3><p>用paste命令实现按列拼接。<br><code>$ paste file1 file2 file3...</code><br>参数：<br><code>-d：指定定界符</code></p>\n<h3 id=\"ls-列出目录\"><a href=\"#ls-列出目录\" class=\"headerlink\" title=\"ls 列出目录\"></a>ls 列出目录</h3><p>以下是几种方法列出当前路径下的目录。</p>\n<pre><code>ls –d */\nls –F | grep &quot;/$&quot;\nls –l | grep &quot;^d&quot;\nfind . –type d –maxdepth 1 –print\n</code></pre><h3 id=\"jps-显示java进程\"><a href=\"#jps-显示java进程\" class=\"headerlink\" title=\"jps 显示java进程\"></a>jps 显示java进程</h3><p>显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。<br>主要参数：</p>\n<pre><code>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数\n-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null\n-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名\n-v 输出传递给JVM的参数\n</code></pre><h3 id=\"xargs-参数传递\"><a href=\"#xargs-参数传递\" class=\"headerlink\" title=\"xargs 参数传递\"></a>xargs 参数传递</h3><p><code>xargs [-0opt] [-E eofstr] [-I replstr [-R replacements]] [-J replstr] [-L number] [-n number [-x]] [-P maxprocs] [-s size] [utility [argument ...]]</code><br>给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。<br>最经典应用模式：  <code>somecommand | xargs -item  command</code><br>不带<code>command</code>，默认的使用<code>echo</code>输出</p>\n<p>用途：<br>1.构造参数列表并运行命令，即将接收的参数传递给后面的<code>command</code>命令执行<br>2.将多行输入转换为单行（特殊功效）</p>\n<p>优点：<br>1.将输入参数整理后，去除<code>&lt;newline&gt;</code>换行符，以一个列表形式处理<br>2.避免参数过长引发的问题，使用<code>xargs -n</code> 参数适当控制，对于经常产生大量输出的命令如<code>find</code>、<code>locate</code>和<code>grep</code>来说非常有用</p>\n<p><code>-item</code> 代表选项:</p>\n<pre><code>-0      当sdtin含有特殊字元时候，将其当成一般字符，想/&apos;空格等\n-a file 从文件中读入作为sdtin\n-e flag 注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。\n-E EOF  指定输入结束符\n-n num  后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。\n-p      操作具有可交互性，每次执行comand都交互式提示用户选择，当每次执行一个argument的时候询问一次用户\n-t      表示先打印命令，然后再执行。\n-i      或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给{}，可以用{}代替。\n-r      no-run-if-empty 如果没有要处理的参数传递给xargs，xargs 默认是带 空参数运行一次，如果你希望无参数时，停止 xargs，直接退出，使用 -r 选项即可，其可以防止xargs 后面命令带空参数运行报错。\n-s      num xargs后面那个命令的最大命令行字符数(含空格) \n-L      从标准输入一次读取num行送给Command命令 ，-l和-L功能一样\n-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符\n-x      exit的意思，如果有任何 Command 行大于 -s Size 标志指定的字节数，停止运行 xargs 命令，-L -I -n 默认打开-x参数，主要是配合-s使用\n-P      修改最大的进程数，默认是1，为0时候为as many as it can.\n</code></pre><h3 id=\"未完待续…\"><a href=\"#未完待续…\" class=\"headerlink\" title=\"未完待续…\"></a>未完待续…</h3><hr>\n<p>扫描二维码或在微信中搜索 KeepMovingXin<br><img src=\"/images/qrcode.jpg\" alt=\"欢迎关注微信公众号！\"></p>\n<hr>\n<p><strong>版权声明</strong><br><a href=\"http://blog.keepmovingxin.com\">KeepMoving</a> by <a href=\"http://blog.keepmovingxin.com/about\">KP_小新</a> 采用 <a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\" target=\"_blank\" rel=\"external\">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a><br>Copyright © 2016 <a href=\"http://blog.keepmovingxin.com\">KeepMoving</a>. All rights reserved.<br>原文链接：<a href=\"http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/\">http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/</a></p>\n"}