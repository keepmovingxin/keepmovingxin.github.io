{"tags":[{"name":"Linux","permalink":"http://blog.keepmovingxin.com/tags/Linux/","url":"/async/tags/Linux.json","count":1}],"categories":[{"name":"工具/效率","permalink":"http://blog.keepmovingxin.com/categories/工具-效率/","url":"/async/categories/工具/效率.json","count":8}],"url":"/async/posts/2016/04/28/Linux-Commond.json","date":1461830572000,"path":{"year":2016,"month":4,"day":28,"name":"Linux-Commond"},"title":"Linux常用命令学习","permalink":"http://blog.keepmovingxin.com/2016/04/28/Linux-Commond/","content":"<h3 id=\"同步时间\"><a href=\"#同步时间\" class=\"headerlink\" title=\"同步时间\"></a>同步时间</h3><p>以管理员身份执行如下命令，可以自动与网络时间同步：<br>time.nist.gov 是一个时间服务器<br><code>$ rdate -s time.nist.gov</code></p>\n<a id=\"more\"></a>\n<h3 id=\"管道符：\"><a href=\"#管道符：\" class=\"headerlink\" title=\"管道符： |\"></a>管道符： |</h3><p>就是把前面的命令运行的要放入标准输出的结果丢给后面的命令<br><code>cat 1.txt | cat</code></p>\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><p>由一般字符和特殊字符（meta字符）组成<br>meta元字符</p>\n<pre><code>\\ 通常用于打开或关闭后续字符的特殊含义，如\\(...\\)与\\{...\\}\n. 匹配任何单个字符（除NULL）\n\\* 匹配前面的子表达式任意次，例：a* 匹配任意多个a\n? 匹配前面的子表达式零次或一次匹配前面的子表达式一次或多次。\n\\+ 匹配前面的子表达式一次或多次\n^ 匹配输入字符串的开始位置\n$ 匹配输入字符串的结束位置\n[] 匹配方括号内的任一字符，其中可用连字符（-）指的连续字符的范围；^符号若出现在方括号的第一个位置，则表示匹配不在列表中的任一字符\n(x|y) 匹配x或y，比如：(g|f)ood，匹配good或food\n</code></pre><h3 id=\"文件通配符\"><a href=\"#文件通配符\" class=\"headerlink\" title=\"文件通配符\"></a>文件通配符</h3><pre><code>\\* 匹配文件名中的任何字符串，包括空字符串。\n? 匹配文件名中的任何单个字符。\n[...] 匹配[ ]中所包含的任何字符。可以用 – 连接，表示范围\n[!...] 匹配[ ]中非 感叹号！之后的字符。\n</code></pre><p>如：</p>\n<pre><code>5* 5开头的所有字符串\n*5 5结尾的所有字符串\n*5? 以5为倒数第二个字符的字符串\n[0－9] 所有以数字的字符\n[1,2] 1或者2\n[!0-9] 不是数字的字符\n</code></pre><h3 id=\"echo-打印\"><a href=\"#echo-打印\" class=\"headerlink\" title=\"echo 打印\"></a>echo 打印</h3><pre><code>-n    打印语句后不会换行。\n-e 开启转义，即可以打印后面的 \\t,\\r 等转义字符\n可以打印彩色文本。\n</code></pre><h3 id=\"printf-格式化输出\"><a href=\"#printf-格式化输出\" class=\"headerlink\" title=\"printf 格式化输出\"></a>printf 格式化输出</h3><p>用于格式化输出，使用的参数和C语言中的printf函数一样<br>eg：printf “%-5s %-10s %-4.2f\\n” 1 James 80.9968</p>\n<pre><code>-：表示左对齐，默认为右对齐\ns：表示打印的是字符串\nf：表示打印一个浮点数，其中4表示宽度，.2表示保留2位小数\n</code></pre><p>printf默认不带换行，需要手动添加</p>\n<h3 id=\"cat-查看文件\"><a href=\"#cat-查看文件\" class=\"headerlink\" title=\"cat 查看文件\"></a>cat 查看文件</h3><pre><code>-n：为每行前面加上行号。-n会为空白行也加上行号，-b选项则会跳过空白行。\n-s：压缩相邻的空白行，即连续的空白行将压缩为一行。\n-T：用^I符号表示制表符\\t\n</code></pre><h3 id=\"grep-匹配\"><a href=\"#grep-匹配\" class=\"headerlink\" title=\"grep 匹配\"></a>grep 匹配</h3><p>grep [options] [表达式]<br>1)    [options]列表：</p>\n<pre><code>-c    ：只输出匹配行的统计数\n-n    ：显示匹配行及行号\n-A2    ：列出匹配行及下面2行\n-B2    ：列出匹配行及上面2行\n-C2    ：列出匹配行及上下2行\n-I    ：不区分大小写(只适用于单字符)\n-h    ：查询多文件时不显示文件名\n-H    ：查询多文件时显示文件名（默认）\n-l    ：查询多文件时只输出包含匹配字符的文件名\n-o    : 每行只输出匹配部分\n-s    ：不显示不存在或无匹配文本的错误信息\n-v    ：显示不包含匹配文本的所有行\n-r    ：递归匹配目录下所有文件及目录\n-E    : 扩展grep，增加了额外的正则表达式元字符集\n-e    ：指定多个匹配样式，样式间“或”的关系\n-f pattern_file    ：    样式文件pattern_file中逐行存放要匹配的样式，可匹配多个样式，样式之间是“或”的关系\n--color    ：    为匹配项显示不同颜色\n</code></pre><p>2)    <code>grep –E &quot;pattern1|pattern2&quot; files</code> ：显示匹配 pattern1 或 pattern2 的行<br>3)    <code>grep –e pattern1 –e pattern2 files</code> : 匹配pattern1或pattern2<br>4)    <code>grep pattern1 files | grep pattern2</code> ：显示既匹配 pattern1 又匹配 pattern2 的行<br>5)    <code>egrep &quot;t_hero|t_item&quot;</code>   匹配t_hero或者t_item的项<br>6)    <code>grep &quot;t_hero\\|t_item&quot;</code>    可以实现与上面同样的功能</p>\n<h3 id=\"sed-处理内容\"><a href=\"#sed-处理内容\" class=\"headerlink\" title=\"sed 处理内容\"></a>sed 处理内容</h3><p><code>sed [options] &#39;command&#39; file(s) 或sed [options] -f scriptfile file(s)</code><br>一次处理一行内容 不改变文件内容<br>[options]列表：</p>\n<pre><code>-n    :    取消默认的输出,使用安静(silent)模式。\n-r    :    使用正则表达式，及表达式中不需要进行转义\n-f filename :    指定sed脚本的文件名filename\n-e &apos;&apos; :    允许多重编辑·  \n-i    :    将替换结果应用于源文件\n</code></pre><p>1)    替换字符串<br><code>sed &#39;s/pattern/string/&#39; file</code><br>或者<br><code>cat file | sed &#39;s/pattern/string/&#39;</code><br>2)    替换文件中所有匹配内容，使用参数g<br><code>sed &#39;s/pattern/string/g&#39; file</code><br>但如果你想从第N处匹配开始替换，可以使用参数/Ng<br><code>$ echo thisthisthisthis | sed &#39;s/this/THIS/2g&#39;\nthisTHISTHISTHIS</code><br>3)    sed的定界符’/‘.当匹配模式中含有’/‘字符时，我们需要用’\\’对定界符’/‘进行转义<br><code>$ echo a/b | sed &#39;s/a\\/b/a*b/&#39;\na*b</code><br>为了避免转义字符造成的理解困难，我们可以使用其它定界符，比如|,:,@,#,$,%,+等等<br><code>$ echo a/b | sed &#39;s:a/b:a*b:&#39;\na*b</code><br>4)    移除匹配样式行  <code>sed &#39;/pattern/d&#39; file</code><br><code>$ sed -r &#39;/^ *$/d&#39; args.txt        #移除空白行，含有一个或多个空格的行</code><br>5)    组合多个表达式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo abd | sed &apos;s/a/A/&apos; | sed &apos;s/d/D/&apos;  #用管道组合\r$ echo abd | sed &apos;s/a/A/;s/d/D/&apos;           #用分号组合\r$ echo abd | sed -e &apos;s/a/A/&apos; -e &apos;s/d/D/&apos;  #用-e选项组合\r```\r6)\t已匹配字符串标记（&amp;）\r&amp;代表匹配给定样式的字符串，常用于对给定样式增加[]，&#123;&#125;等不需要改变样式的情况\r```\r$ echo &quot;this is an example&quot; | sed &apos;s/\\w\\+/[&amp;]/g&apos;   #\\w\\+ 匹配每个单词\r[this] [is] [an] [example]</span><br><span class=\"line\">```\r7)\t子串匹配标记（\\1）\r有时我们希望对匹配给定的样式标记出一些子串来，方便后续引用\r\\(pattern\\) 用于匹配子串pattern\r\\1 用于引用第一个匹配到的子串，\\n 对应第n个匹配到的子串。\r```\r$ echo 123 asd | sed &apos;s/\\([0-9]\\+\\) \\([a-z]\\+\\)/\\2+\\1/&apos; \rasd+123</span><br><span class=\"line\">```\r其中\\1对应数字123，\\2对应字母asd\r对于子串的引用，在样式里一定要用\\(\\)括起来，如果加上-r选项，则不需要转义：\r```\r$ echo 123 asd | sed -r &apos;s/([0-9]+) ([a-z]+)/\\2+\\1/&apos;\rasd+123\r```\r8)\t引用\r在脚本中有用的一点，用双引号引用的sed表达式，会对表达式求值来进行扩展，如使用前面定义的变量等\r```\r$ text=hello\r$ echo hello world | sed &quot;s/$text/HELLO/&quot;\rHELLO world</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"tail-查看文件\"><a href=\"#tail-查看文件\" class=\"headerlink\" title=\"tail 查看文件\"></a>tail 查看文件</h3><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件<br>主要参数</p>\n<pre><code>-f ：    循环读取   #可以用在监控线上有没有报错信息\n-q ：    不显示处理信息\n-v ：    显示详细的处理信息\n-c&lt;数目&gt; ：    显示的字节数\n-n&lt;行数&gt; ：    显示行数\n--pid=PID ：    与-f合用,表示在进程ID,PID死掉之后结束. \n-q, --quiet, --silent ：    从不输出给出文件名的首部\n</code></pre><h3 id=\"find-查找\"><a href=\"#find-查找\" class=\"headerlink\" title=\"find 查找\"></a>find 查找</h3><p><code>find dir [option] &#39;command&#39;</code><br><code>dir</code>: 目录名，用空格隔开多个目录<br>1) [option]列表：</p>\n<pre><code>-name wildcard 文件名，wildcard表示通配符，并非正则式\n    find dir1 dir2 -name &apos;*.c&apos; –print  在目录dir1和dir2中查找文件，并打印路径\n    如果在-name后面紧跟一个-prune，则表示此目录应被修剪\n    find . \\( -name &quot;.svn&quot; -prune \\) -o –print 表示对于查找的目录，要么修剪掉（.svn），要么打印出来（其他）。\n-iname 忽略名字大小写\n-path 指定目录，如果在-path前面加上 ！ ，则表示忽略此目录，目录名可以使用通配符匹配。\n-type 文件类型\n    f:普通文件 d:目录 l:符号连接文件 c:字符设备文件 b:块设备文件 p:管道文件\n-size ±nc 查找大于（+）或小于（-）n字节的文件，注意c（charter）\n-mtime ±ndays 文件最近修改时间\n-user,-nouser 文件所有者\n-group,-nogroup 指定文件用户组\n多条件的与（-a）/或（-o）/非（！）\n    find . \\( -name &quot;*.txt&quot; –o –name &quot;*.sh&quot; \\) –print\n    括号两边应该有空格\n-maxdepth n 指定最大目录深度，n=1表示最大为当前目录\n-mindepth n 指定最小目录深度，n=2表示不打印当前目录下的文件\n  -maxdepth和-mindepth应作为find的第三个参数出现，以提高效率\n</code></pre><p>2) ‘command’命令列表：</p>\n<pre><code>-print  打印路径名\n-delete 对找到的文件进行删除 \n-exec   对查找到的目标执行某一命令。\n    find ${workdir} -name &quot;$filename&quot; -exec  |grep $uid\n    -exec 参数后面跟的是bash命令，但只能跟一个命令，如果想执行多个命令，那么可以将多个命令放进一个shell脚本，然后执行这个脚本。\n    bash命令的终止，使用 &apos;;&apos; (分号）来判定，在后面必须有一个 &apos;;&apos;在分号前应该加上转义字符&apos;\\&apos;\n    &apos;{}&apos;，使用{}来表示文件名，也就是find前面处理过程中过滤出来的文件，用于bash命令进行处理\n-ok     与-exec类似，只是对查找到符合条件的目标执行一个命令前需要经过确认\n</code></pre><h3 id=\"cut-剪切\"><a href=\"#cut-剪切\" class=\"headerlink\" title=\"cut 剪切\"></a>cut 剪切</h3><p><code>cut</code> 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出，必须指定 <code>-b</code>、<code>-c</code> 或<code>-f</code> 标志之一。<br>主要参数</p>\n<pre><code>-b: 以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。\n-c: 以字符为单位进行分割。（单个字母等）\n    cut –c2-5 file    ，表示将文件file每行的第2-5个字符作为一列显示出来。\n-d: 自定义分隔符，默认为制表符。\n-f: 与-d一起使用，指定显示哪个区域。\n    例子：cat file.txt | cut -d&apos;]&apos; -f7；\n        cat file.txt | cut -d&apos;]&apos; –f4,7；//打印4和7列\n        cat file.txt | cut -d&apos;]&apos; –f4-7；//打印4到7列\n-n: 取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的&lt;br /&gt;范围之内，该字符将被写出；否则，该字符将被排除。\n--complement: 与-f一起使用，指定显示哪个区域的补集。\n</code></pre><h3 id=\"sort-排序\"><a href=\"#sort-排序\" class=\"headerlink\" title=\"sort 排序\"></a>sort 排序</h3><p><code>sort</code>将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按<code>ASCII</code>码值进行比较，最后将他们按升序输出。<br>主要参数：</p>\n<pre><code>-u: 去除重复行\n-r: sort默认的排序方式是升序，如果想改成降序，用此参数\n-o file: 把排序结果输出到文件file，file可以是原文件\n-n: 以数值排序\n-t: 指定间隔符\n-k: 指定域排序，常与-t连用。sort –t &apos;:&apos; –k 2\n    在指定域的时候还可细分，比如指定第二个域的第3个字符开始比较，用-k 2.3;\n    比如指定第二个域的第3个字符到第二个域的第5个字符进行排序，用-k 2.3,2.5\n    比如只指定第二个域的第3个字符进行排序，用-k 2.3,2.3\n-b: 忽略每一行前面的所有空白部分，从第一个可见字符开始比较\n-f: 忽略大小写进行排序\n</code></pre><h3 id=\"uniq-去重\"><a href=\"#uniq-去重\" class=\"headerlink\" title=\"uniq 去重\"></a>uniq 去重</h3><pre><code>-c : 统计重复的行数\n-u : 只显示不重复的那些行\n-d : 只显示重复的那些行\n-s n : 指定跳过前n个字符\n-w n : 指定用于比较的最大字符数\n</code></pre><h3 id=\"wc-统计\"><a href=\"#wc-统计\" class=\"headerlink\" title=\"wc 统计\"></a>wc 统计</h3><p>使用wc的各种选项来统计行数、单词数和字符数。<br>主要参数：</p>\n<pre><code>-l ：行数\n-w ：单词数\n-c ：字符数\n</code></pre><h3 id=\"seq-产生整数\"><a href=\"#seq-产生整数\" class=\"headerlink\" title=\"seq 产生整数\"></a>seq 产生整数</h3><p><code>seq A B</code>: 用于产生从某个数到另外一个数之间的所有整数<br>主要参数：</p>\n<pre><code>-f：指定格式。默认是&quot;%g&quot;，表示按宽度为1输出。可以在g的前面加入一些字符，表示不同的含义，如：\n   %2g：表示按宽度为2右对齐。\n   %02g：表示按宽度为2右对齐，不足的部分用0补足。\n</code></pre><p>可用于构造日志文件名</p>\n<pre><code>for i in `seq -f &quot;log.20160407&quot;%02g 5 12`; do echo $i; done\n   str%03g：表示按宽度为3右对齐，补足的位数用0补，并在前面加上str子串。\n    %-3g：表示按宽度为3左对齐。\n</code></pre><h3 id=\"mkdir-创建目录\"><a href=\"#mkdir-创建目录\" class=\"headerlink\" title=\"mkdir 创建目录\"></a>mkdir 创建目录</h3><p>常用参数：</p>\n<pre><code>-p: 可以是一个路径名称。此时若路径中的某些目录尚不存在，加上此选项后,系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录;\n-m &lt;777&gt;: 模式，设定权限&lt;模式&gt;\n-v: 在创建目录的同时输出信息。\n</code></pre><h3 id=\"date-时间\"><a href=\"#date-时间\" class=\"headerlink\" title=\"date 时间\"></a>date 时间</h3><p>1) 显示时间</p>\n<pre><code>date [OPTION]... [+FORMAT]\ndate &quot;+%Y-%m-%d %H:%M:%S&quot;  #显示当前的年月日时分秒\n</code></pre><p>2) 设置时间</p>\n<pre><code>date -s //设置当前时间，只有root权限才能设置，其他只能查看。\ndate -s 20080523 //设置成20080523，这样会把具体时间设置成空00:00:00\ndate -s 15:20:30 //设置时间\ndate +%s //当前时间时间戳\n</code></pre><p>3) 转换时间<br>把linux下的时间戳转换成现实中的年月日时分秒</p>\n<pre><code>date –d @timestamp\neg:$date -d @1433087999\n 2015年 05月 31日 星期日 23:59:59 CST\n</code></pre><h3 id=\"md5sum-MD5\"><a href=\"#md5sum-MD5\" class=\"headerlink\" title=\"md5sum MD5\"></a>md5sum MD5</h3><p>MD5全称是报文摘要算法（Message-Digest Algorithm 5），此算法对任意长度的信息逐位进行计算，产生一个二进制长度为128位（十六进制长度32位）的“指纹”（或称“报文摘要”），即使两个文件只相差一个字符，产生的校验和也完全不同。<br>1) 使用md5sum来产生指纹（报文摘要）命令如下：<br>     <code>md5sum file &gt; file.md5</code><br>若不指定文件名，则从标准输入读取，也可输出到标准输出设备，因此可与管道符“|”连用。<br> 可以使用文件通配符，将多个文件的md5值输出到同一个文件。<br>文件file.md5的内容如下：<br>      <code>c0e207c045c344ebf363c3e9a6de1076  file</code><br> 第一列是md5校验和，第二列是对应文件名。<br>2) 使用md5报文摘要验证文件。<br>将生成的file.md5文件放在对应file文件的同一目录下。使用如下命令验证：<br>     <code>md5sum -c file.md5</code><br>若验证成功，输出“file: 确定”；验证失败则输出“file: 失败”，并打印警告信息：“md5sum: 警告：1/1 生成的校验和不匹配”。</p>\n<h3 id=\"ln-链接\"><a href=\"#ln-链接\" class=\"headerlink\" title=\"ln 链接\"></a>ln 链接</h3><p>主要参数：</p>\n<pre><code>-f : 链结时先将与 dist 同档名的档案删除\n-d : 允许系统管理者硬链结自己的目录\n-i : 在删除与 dist 同档名的档案时先进行询问\n-n : 在进行软连结时，将 dist 视为一般的档案\n-s : 进行软链结(symbolic link)\n     ln –s target new\n     为target文件建立一个软链接new指向target\n-v : 在连结之前显示其档名\n-b : 将在链结时会被覆写或删除的档案进行备份\n-S SUFFIX : 将备份的档案都加上 SUFFIX 的字尾\n-V METHOD : 指定备份的方式\n--help : 显示辅助说明\n--version : 显示版本\n</code></pre><h3 id=\"split-大文件切割\"><a href=\"#split-大文件切割\" class=\"headerlink\" title=\"split 大文件切割\"></a>split 大文件切割</h3><p> <code>split -b 500m file newfile_prefix</code></p>\n<pre><code>-l：行数，指定每多少行切成一个小文件。\n-b：指定每多少字就要切成一个小文件。支持单位:m,k\n-C：与-b参数类似，但切割时尽量维持每行的完整性。\n-d：指定切割后的文件名以数字作为后缀\n</code></pre><p>合并： <code>cat newfile_prefix* &gt; newfile</code></p>\n<h3 id=\"alias-别名\"><a href=\"#alias-别名\" class=\"headerlink\" title=\"alias 别名\"></a>alias 别名</h3><p><code>alias myssh=’sh filename.sh’</code></p>\n<h3 id=\"chmod-权限\"><a href=\"#chmod-权限\" class=\"headerlink\" title=\"chmod 权限\"></a>chmod 权限</h3><p>使用chmod命令设置文件权限。<br><code>chmod a+x file</code></p>\n<pre><code>u ： 指定用户权限\ng ： 指定用户组权限\no ： 指定其他用户权限\na ： 指定所有类别\n+ ： 增加权限\n- ： 删除权限\nr ： 可读\nw ： 可写\nx ： 可执行，对目录文件来说表示可访问目录中的文件和子目录\n</code></pre><h3 id=\"vim-文本编辑工具\"><a href=\"#vim-文本编辑工具\" class=\"headerlink\" title=\"vim 文本编辑工具\"></a>vim 文本编辑工具</h3><p><code>vimdiff</code> 文本差异对比<br><code>vimdiff  FILE_LEFT  FILE_RIGHT</code><br>常用命令：</p>\n<pre><code>Ctrl-w K 把当前窗口移到最上边\nCtrl-w H 把当前窗口移到最左边\nCtrl-w J 把当前窗口移到最下边\nCtrl-w L 把当前窗口移到最右边\nCtrl-w,w  在两个文件之间来回跳转\n]c   跳转到下一差异点\n[c   跳转到上一差异点，可在前面加上数字，表示跳转多少个差异\ndp(diff put) 把一个差异点中当前文件的内容复制到另一个文件中\ndo(diff get) 另一个文件的内容复制到当前行中\n:diffupdate 手工来刷新比较结果\nzo(folding open) 展开被折叠的相同的文本行\nzc(folding close) 重新折叠\n</code></pre><h3 id=\"paste-拼接\"><a href=\"#paste-拼接\" class=\"headerlink\" title=\"paste 拼接\"></a>paste 拼接</h3><p>用paste命令实现按列拼接。<br><code>$ paste file1 file2 file3...</code><br>参数：<br><code>-d：指定定界符</code></p>\n<h3 id=\"ls-列出目录\"><a href=\"#ls-列出目录\" class=\"headerlink\" title=\"ls 列出目录\"></a>ls 列出目录</h3><p>以下是几种方法列出当前路径下的目录。</p>\n<pre><code>ls –d */\nls –F | grep &quot;/$&quot;\nls –l | grep &quot;^d&quot;\nfind . –type d –maxdepth 1 –print\n</code></pre><h3 id=\"jps-显示java进程\"><a href=\"#jps-显示java进程\" class=\"headerlink\" title=\"jps 显示java进程\"></a>jps 显示java进程</h3><p>显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。<br>主要参数：</p>\n<pre><code>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数\n-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null\n-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名\n-v 输出传递给JVM的参数\n</code></pre><h3 id=\"xargs-参数传递\"><a href=\"#xargs-参数传递\" class=\"headerlink\" title=\"xargs 参数传递\"></a>xargs 参数传递</h3><p><code>xargs [-0opt] [-E eofstr] [-I replstr [-R replacements]] [-J replstr] [-L number] [-n number [-x]] [-P maxprocs] [-s size] [utility [argument ...]]</code><br>给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。<br>最经典应用模式：  <code>somecommand | xargs -item  command</code><br>不带<code>command</code>，默认的使用<code>echo</code>输出</p>\n<p>用途：<br>1.构造参数列表并运行命令，即将接收的参数传递给后面的<code>command</code>命令执行<br>2.将多行输入转换为单行（特殊功效）</p>\n<p>优点：<br>1.将输入参数整理后，去除<code>&lt;newline&gt;</code>换行符，以一个列表形式处理<br>2.避免参数过长引发的问题，使用<code>xargs -n</code> 参数适当控制，对于经常产生大量输出的命令如<code>find</code>、<code>locate</code>和<code>grep</code>来说非常有用</p>\n<p><code>-item</code> 代表选项:</p>\n<pre><code>-0      当sdtin含有特殊字元时候，将其当成一般字符，想/&apos;空格等\n-a file 从文件中读入作为sdtin\n-e flag 注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。\n-E EOF  指定输入结束符\n-n num  后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。\n-p      操作具有可交互性，每次执行comand都交互式提示用户选择，当每次执行一个argument的时候询问一次用户\n-t      表示先打印命令，然后再执行。\n-i      或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给{}，可以用{}代替。\n-r      no-run-if-empty 如果没有要处理的参数传递给xargs，xargs 默认是带 空参数运行一次，如果你希望无参数时，停止 xargs，直接退出，使用 -r 选项即可，其可以防止xargs 后面命令带空参数运行报错。\n-s      num xargs后面那个命令的最大命令行字符数(含空格) \n-L      从标准输入一次读取num行送给Command命令 ，-l和-L功能一样\n-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符\n-x      exit的意思，如果有任何 Command 行大于 -s Size 标志指定的字节数，停止运行 xargs 命令，-L -I -n 默认打开-x参数，主要是配合-s使用\n-P      修改最大的进程数，默认是1，为0时候为as many as it can.\n</code></pre><h3 id=\"which-查看可执行文件的位置\"><a href=\"#which-查看可执行文件的位置\" class=\"headerlink\" title=\"which 查看可执行文件的位置\"></a>which 查看可执行文件的位置</h3><p><strong>功能说明</strong>：查找可执行文件。<br><strong>语　　法</strong>：which [文件…]<br><strong>补充说明</strong>：which指令会在环境变量$PATH设置的目录里查找符合条件的文件。<br><strong>参　　数</strong>：</p>\n<pre><code>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。\n-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。\n-w 　指定输出时栏位的宽度。\n-V 　显示版本信息\n</code></pre><h3 id=\"whereis-查看文件的位置\"><a href=\"#whereis-查看文件的位置\" class=\"headerlink\" title=\"whereis 查看文件的位置\"></a>whereis 查看文件的位置</h3><p><strong>功能说明</strong>：查找文件。<br><strong>语　　法</strong>：whereis [-bfmsu][-B &lt;目录&gt;…][-M &lt;目录&gt;…][-S &lt;目录&gt;…][文件…]<br><strong>补充说明</strong>：whereis指令会在特定目录中查找符合条件的文件。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。<br><strong>参　　数</strong>：</p>\n<pre><code>-b 　只查找二进制文件。\n-B&lt;目录&gt; 　只在设置的目录下查找二进制文件。\n-f 　不显示文件名前的路径名称。\n-m 　只查找说明文件。\n-M&lt;目录&gt; 　只在设置的目录下查找说明文件。\n-s 　只查找原始代码文件。\n-S&lt;目录&gt; 　只在设置的目录下查找原始代码文件。\n-u 　查找不包含指定类型的文件。\n</code></pre><h3 id=\"zip-压缩\"><a href=\"#zip-压缩\" class=\"headerlink\" title=\"zip 压缩\"></a>zip 压缩</h3><p><strong>功能说明</strong>：文件压缩(打包)。<br><strong>语　　法</strong>：<br><code>zip -q -r -e -m -o [yourName].zip someThing</code><br><strong>参　　数</strong>：</p>\n<pre><code>-q 表示不显示压缩进度状态\n-r 表示子目录子文件全部压缩为zip  //这部比较重要，不然的话只有something这个文件夹被压缩，里面的没有被压缩进去\n-e 表示你的压缩文件需要加密，终端会提示你输入密码的\n// 还有种加密方法，这种是直接在命令行里做的，比如zip -r -P Password01! modudu.zip SomeDir, 就直接用Password01!来加密modudu.zip了。\n-m 表示压缩完删除原文件\n-o 表示设置所有被压缩文件的最后修改时间为当前压缩时间\n</code></pre><p>当跨目录的时候是这么操作的<br><code>zip -q -r -e -m -o &#39;\\user\\someone\\someDir\\someFile.zip&#39; &#39;\\users\\someDir&#39;</code></p>\n<h3 id=\"scp-远程拷贝\"><a href=\"#scp-远程拷贝\" class=\"headerlink\" title=\"scp 远程拷贝\"></a>scp 远程拷贝</h3><p><strong>功能说明</strong>：scp是secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。<br><strong>语　　法</strong>：scp [参数] [原路径] [目标路径]<br><strong>参　　数</strong>：</p>\n<pre><code>-1  强制scp命令使用协议ssh1  \n-2  强制scp命令使用协议ssh2  \n-4  强制scp命令只使用IPv4寻址  \n-6  强制scp命令只使用IPv6寻址  \n-B  使用批处理模式（传输过程中不询问传输口令或短语）  \n-C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）  \n-p 保留原文件的修改时间，访问时间和访问权限。  \n-q  不显示传输进度条。  \n-r  递归复制整个目录。  \n-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。   \n-c cipher  以cipher将数据传输进行加密，这个选项将直接传递给ssh。   \n-F ssh_config  指定一个替代的ssh配置文件，此参数直接传递给ssh。  \n-i identity_file  从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。    \n-l limit  限定用户所能使用的带宽，以Kbit/s为单位。     \n-o ssh_option  如果习惯于使用ssh_config(5)中的参数传递方式，   \n-P port  注意是大写的P, port是指定数据传输用到的端口号   \n-S program  指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。\n</code></pre><p><strong>实　　例</strong>：</p>\n<ol>\n<li>从本地服务器复制到远程服务器： </li>\n</ol>\n<p>(1) 复制文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp local_file remote_username@remote_ip:remote_folder  </span><br><span class=\"line\">或者  </span><br><span class=\"line\">scp local_file remote_username@remote_ip:remote_file  </span><br><span class=\"line\">或者  </span><br><span class=\"line\">scp local_file remote_ip:remote_folder  </span><br><span class=\"line\">或者  </span><br><span class=\"line\">scp local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure></p>\n<p>第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名<br>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名</p>\n<p>(2) 复制目录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r local_folder remote_username@remote_ip:remote_folder  </span><br><span class=\"line\">或者  </span><br><span class=\"line\">scp -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure></p>\n<p>第1个指定了用户名，命令执行后需要输入用户密码；<br>第2个没有指定用户名，命令执行后需要输入用户名和密码；</p>\n<ol>\n<li>从远程服务器复制到本地服务器：</li>\n</ol>\n<p>(1) 从远处复制文件到本地目录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/</span><br></pre></td></tr></table></figure></p>\n<p>说明：<br>从192.168.120.204机器上的/opt/soft/的目录中下载nginx-0.5.38.tar.gz 文件到本地/opt/soft/目录中</p>\n<p>(2) 从远处复制到本地<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp -r root@192.168.120.204:/opt/soft/mongodb /opt/soft/</span><br></pre></td></tr></table></figure></p>\n<p>说明：<br>从192.168.120.204机器上的/opt/soft/中下载mongodb 目录到本地的/opt/soft/目录来。</p>\n<p>(3) 上传本地文件到远程机器指定目录</p>\n<pre><code>scp /opt/soft/nginx-0.5.38.tar.gz root@192.168.120.204:/opt/soft/scptest\n</code></pre><p>说明：<br>上传本地目录 /opt/soft/mongodb到远程机器192.168.120.204上/opt/soft/scptest的目录中去</p>\n<h3 id=\"未完待续…\"><a href=\"#未完待续…\" class=\"headerlink\" title=\"未完待续…\"></a>未完待续…</h3><hr>\n<p><strong>版权声明</strong><br><a href=\"http://blog.keepmovingxin.com\">KeepMoving</a> by <a href=\"http://blog.keepmovingxin.com/about\">KP_小新</a> 采用 <a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\" target=\"_blank\" rel=\"external\">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a></p>\n<h2 id=\"Copyright-©-2018-KeepMoving-All-rights-reserved\"><a href=\"#Copyright-©-2018-KeepMoving-All-rights-reserved\" class=\"headerlink\" title=\"Copyright © 2018 KeepMoving. All rights reserved.\"></a>Copyright © 2018 <a href=\"http://blog.keepmovingxin.com\">KeepMoving</a>. All rights reserved.</h2><p>扫描二维码或在微信中搜索 KeepMovingXin<br><img src=\"/images/qrcode.jpg\" alt=\"欢迎关注微信公众号！\"></p>\n"}