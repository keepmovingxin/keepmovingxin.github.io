{"tags":[{"name":"Lua","permalink":"http://blog.keepmovingxin.com/tags/Lua/","url":"/async/tags/Lua.json","count":9},{"name":"Lua数据结构","permalink":"http://blog.keepmovingxin.com/tags/Lua数据结构/","url":"/async/tags/Lua数据结构.json","count":6}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":11}],"url":"/async/posts/2016/06/10/Lua-lua_State.json","date":1465563796000,"path":{"year":2016,"month":6,"day":10,"name":"Lua-lua_State"},"title":"Lua数据结构 — lua_State（六）","permalink":"http://blog.keepmovingxin.com/2016/06/10/Lua-lua_State/","content":"<p>前面各种Lua的数据类型基本都说得差不多了，剩下最后一个数据类型：<strong>lua_State</strong>，我们可以认为是<strong>”脚本上下文”</strong>，主要是包括当前脚本环境的运行状态信息，还会有gc相关的信息。</p>\n<a id=\"more\"></a>\n<p>Lua这门语言考虑了多线程的情况，在脚本空间中能够开多个线程相关脚本上下文，而大家会共用一个全局脚本状态数据，如下：</p>\n<p><img src=\"/images/luaState/lua-state-01.png\" alt=\"\"></p>\n<p>全局数据global_state的数据结构如下：</p>\n<p><img src=\"/images/luaState/lua-state-02.png\" alt=\"\"></p>\n<p>global_state主要是用于GC的数据链表，下面简要说明几个:</p>\n<ol>\n<li>stringtable strt：这个是在TString那章说到的全局字符串哈希表</li>\n<li>TValue lregistry：对应LUAREGISTRYINDEX的全局table.</li>\n<li>TString *tmname[TM_N]：元方法的名称字符串。</li>\n<li>Table *mt[NUM_TAGS]：基本类型的元表，这是Lua5.0的特性。</li>\n</ol>\n<p>mt成员在作者介绍文章中说到:</p>\n<p><img src=\"/images/luaState/lua-state-03.png\" alt=\"\"></p>\n<p>在上面代码中，我们看到a支持一个tostring的方法，a是数值类型，我们可以为数值类型添加任意的方法。Lua文章中说到一个用途，就是对于unicode和gbk的字符串的len方法能自己实现。</p>\n<p>其它成员就不一一介绍了，下面来介绍与线程相关的脚本上下文lua_State：</p>\n<p><img src=\"/images/luaState/lua-state-04.png\" alt=\"\"></p>\n<p>我们看到，luaState也带有CommonHeader头，在第一章中也提到了GCObject中有luaState th这个成员，由此可见lua_State也会是被回收的对象之一。</p>\n<p>考虑回一个线程中的脚本上下文，我们再来逐个分析每个成员：</p>\n<ul>\n<li>lu_byte status：线程脚本的状态，线程可选状态如下：</li>\n</ul>\n<p><img src=\"/images/luaState/lua-state-05.png\" alt=\"\"></p>\n<ul>\n<li>StkId top：指向当前线程栈的栈顶指针，typedef TValue *StkId</li>\n<li><p>StkId base：指向当前函数运行的相对基位置，具体可参考第四章的闭包</p>\n</li>\n<li><p>globalState *lG：指向全局状态的指针</p>\n</li>\n<li>CallInfo *ci：当前线程运行的函数调用信息</li>\n<li>const Instruction *savedpc：函数调用前，记录上一个函数的pc位置</li>\n<li>StkId stack_last：栈的实际最后一个位置（栈的长度是动态增长的）</li>\n<li>StkId stack：栈底</li>\n<li>CallInfo *end_ci：指向函数调用栈的栈顶</li>\n<li>CallInfo *base_ci：指向函数调用栈的栈底</li>\n<li>int stacksize：栈的大小</li>\n<li>int size_ci：函数调用栈的大小</li>\n<li>unsigned short nCcalls：当前C函数的调用的深度</li>\n<li>unsigned short baseCcalls：用于记录每个线程状态的C函数调用深度的辅助成员</li>\n<li>lu_byte hookmask：支持哪些hook能力，有下列可选的</li>\n</ul>\n<p><img src=\"/images/luaState/lua-state-06.png\" alt=\"\"></p>\n<ul>\n<li>lu_byte allowhook：是否允许hook</li>\n<li>int basehookcount：用户设置的执行指令数(LUA_MASKCOUNT下有效)</li>\n<li>int hookcount：运行时，跑了多少条指令（LUA_MASKCOUNT下有效）</li>\n<li>lua_Hook：用户注册的hook回调函数</li>\n<li>TValue l_gt：当前线程的全局的环境表</li>\n<li>TValue env：当前运行的环境表</li>\n<li>GCObject *openupval、gclist：用于gc，详细将会在GC一章细说</li>\n<li>struct lua_longjmp *errorJmp：发生错误的长跳转位置，用于记录当函数发生错误时跳转出去的位置。</li>\n</ul>\n<p><img src=\"/images/luaState/lua-state-07.png\" alt=\"\"></p>\n<p>本系列总结：</p>\n<p>整个系列文章回答了我们对Lua中最基本的一个问题：“一个Lua变量究竟是什么？”。由此我们深入并引申出各种知识，在脚本中我们觉得弱类型变量用起来很痛快，而其实它的内部实现其实是如此的复杂。</p>\n<p>对于实现一门脚本语言，必须实现的是解释器、虚拟机、上下文数据3大部分：</p>\n<p><img src=\"/images/luaState/lua-state-08.png\" alt=\"\"></p>\n<p>上下文数据这一层是脚本最基础，最底层的东西，它决定了这门脚本究竟能做什么。抛开解释器和虚拟机，我们依然可以单纯地通过C接口，在C++这一层就能操作脚本的上下文数据。</p>\n<p>有空再研究一下Lua的GC，解释器等等。</p>\n<p><strong>Lua数据结构</strong>系列转自阿里云博客，作者是<strong>罗日健</strong>。<br>原文链接：<a href=\"http://blog.aliyun.com/795\" target=\"_blank\" rel=\"external\">http://blog.aliyun.com/795</a></p>\n"}