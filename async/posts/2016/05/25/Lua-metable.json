{"tags":[{"name":"Lua","permalink":"http://blog.keepmovingxin.com/tags/Lua/","url":"/async/tags/Lua.json","count":4}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":6}],"url":"/async/posts/2016/05/25/Lua-metable.json","date":1464161405000,"path":{"year":2016,"month":5,"day":25,"name":"Lua-metable"},"title":"了解Lua metatable 元表","permalink":"http://blog.keepmovingxin.com/2016/05/25/Lua-metable/","content":"<p>参考lua手册，<code>metatable</code>是被译作元表，Lua 中的每个值都可以用一个 <code>metatable</code>。这个 <code>metatable</code> 就是一个原始的 Lua table，它用来定义原始值在特定操作下的行为。</p>\n<h3 id=\"metatable\"><a href=\"#metatable\" class=\"headerlink\" title=\"metatable\"></a><code>metatable</code></h3><p>一个 <code>metatable</code> 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为，metatable 中还可以定义一个函数，让 <code>userdata</code> 作垃圾收集时调用它。对于这些操作，Lua 都将其关联上一个被称作事件的指定健。当 Lua 需要对一个值发起这些操作中的一个时，它会去检查值中 metatable 中是否有对应事件。如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。</p>\n<a id=\"more\"></a>\n<h3 id=\"函数（元方法）\"><a href=\"#函数（元方法）\" class=\"headerlink\" title=\"函数（元方法）\"></a>函数（元方法）</h3><p>metatable通过其包含的函数来给所挂接的table定义一些特殊的操作，包括:</p>\n<ul>\n<li><code>__add</code>: 定义所挂接table的加法操作</li>\n<li><code>__mul</code>: 定义乘法操作</li>\n<li><code>__div</code>: 定义除法操作</li>\n<li><code>__sub</code>: 定义减法操作</li>\n<li><code>__unm</code>: 定义负操作, 即: -table的含义</li>\n<li><code>__tostring</code>: 定义当table作为tostring()函式之参数被呼叫时的行为(例如: <code>print(table)</code>时将呼叫<code>tostring(table)</code>作为输出结果)</li>\n<li><code>__concat</code>: 定义连接操作(“..”运算符)</li>\n<li><code>__index</code>: 定义当table中不存在的key值被试图获取时的行为</li>\n<li><code>__newindex</code>: 定义在table中产生新key值时的行为</li>\n</ul>\n<h4 id=\"index-metamethod\"><a href=\"#index-metamethod\" class=\"headerlink\" title=\"__index metamethod\"></a><code>__index</code> metamethod</h4><ol>\n<li><p>在我们访问 table 的不存在的域时，Lua 会尝试调用 <code>__index</code> metamethod。<code>__index</code> metamethod 接受两个参数 table 和 key，代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local mt = &#123;&#125;</span><br><span class=\"line\">mt.__index = function(table, key)</span><br><span class=\"line\">    print(&apos;table -- &apos; .. tostring(table))</span><br><span class=\"line\">    print(&apos;key -- &apos; .. key)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">local t = &#123;&#125;</span><br><span class=\"line\">setmetatable(t, mt)</span><br><span class=\"line\">local v = t.a</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>__index</code> 域也可以是一个 table，那么 Lua 会尝试在 <code>__index</code> table 中访问对应的域，代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local mt = &#123;&#125;</span><br><span class=\"line\">mt.__index = &#123;</span><br><span class=\"line\">    a = &apos;Hello World&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">local t = &#123;&#125;</span><br><span class=\"line\">setmetatable(t, mt)</span><br><span class=\"line\">print(t.a) --&gt; Hello World</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我们通过 <code>__index</code> 可以容易的实现单继承（类似于 JavaScrpit 通过 prototype 实现单继承），如果 <code>__index</code> 是一个函数，则可以实现更加复杂的功能：多重继承、caching 等。我们可以通过 <code>rawget(t, i)</code> 来访问 <code>table t</code> 的域 <code>i</code>，而不会访问 <code>__index</code> metamethod，注意的是，不要太指望通过 <code>rawget</code> 来提高对 <code>table</code> 的访问速度（Lua 中函数的调用开销远远大于对表的访问的开销）</p>\n<h4 id=\"newindex-metamethod\"><a href=\"#newindex-metamethod\" class=\"headerlink\" title=\"__newindex metamethod\"></a><code>__newindex</code> metamethod</h4><p>如果对 table 的一个不存在的域赋值时，Lua 将检查 <code>__newindex</code> metamethod：</p>\n<ol>\n<li>如果 <code>__newindex</code> 为函数，Lua 将调用函数而不是进行赋值</li>\n<li>如果 <code>__newindex</code> 为一个 table，Lua 将对此 table 进行赋值<br>如果 <code>__newindex</code> 为一个函数，它可以接受三个参数 table key value。如果希望忽略 <code>__newindex</code> 方法对 table 的域进行赋值，可以调用 <code>rawset(t, k, v)</code></li>\n</ol>\n<p>结合 <code>__index</code> 和 <code>__newindex</code> 可以实现很多功能，例如：</p>\n<ol>\n<li>OOP</li>\n<li>Read-only table</li>\n<li>Tables with default values</li>\n</ol>\n<p>Read-only table 代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function readOnly(t)</span><br><span class=\"line\">    local proxy = &#123;&#125;</span><br><span class=\"line\">    local mt = &#123;</span><br><span class=\"line\">        __index = t,</span><br><span class=\"line\">        __newindex = function(t, k, v)</span><br><span class=\"line\">            error(&apos;attempt to update a read-only table&apos;, 2)</span><br><span class=\"line\">        end</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setmetatable(proxy, mt)</span><br><span class=\"line\">    return proxy</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">days = readOnly&#123;&apos;Sun&apos;, &apos;Mon&apos;, &apos;Tues&apos;, &apos;Wed&apos;, &apos;Thur&apos;, &apos;Fri&apos;, &apos;Sat&apos;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">print(days[1])</span><br><span class=\"line\">days[2] = &apos;Noday&apos; --&gt; stdin:1: attempt to update a read-only table</span><br></pre></td></tr></table></figure></p>\n<p>有时候，我们需要为 table 设定一个唯一的 key，那么可以使用这样的技巧，代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local key = &#123;&#125; -- unique key</span><br><span class=\"line\">local t = &#123;&#125;</span><br><span class=\"line\">t[key] = value</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>扫描二维码或在微信中搜索 KeepMovingXin<br><img src=\"/images/qrcode.jpg\" alt=\"欢迎关注微信公众号！\"></p>\n"}