{"tags":[{"name":"shell","permalink":"http://blog.keepmovingxin.com/tags/shell/","url":"/async/tags/shell.json","count":1}],"categories":[{"name":"工具/效率","permalink":"http://blog.keepmovingxin.com/categories/工具-效率/","url":"/async/categories/工具/效率.json","count":7}],"url":"/async/posts/2016/05/02/Learn-shell.json","date":1462179052000,"path":{"year":2016,"month":5,"day":2,"name":"Learn-shell"},"title":"shell学习笔记","permalink":"http://blog.keepmovingxin.com/2016/05/02/Learn-shell/","content":"<h3 id=\"Shell脚本\"><a href=\"#Shell脚本\" class=\"headerlink\" title=\"Shell脚本\"></a>Shell脚本</h3><h4 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h4><p>首行        <code>#!/bin/bash 指定解释器</code></p>\n<h4 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h4><p><code>&#39;#&#39;</code>开头的行，<code>&#39;#!&#39;</code>是例外<br>此外，<code>#</code> 是特殊字符，可以出现在一些参数代换结构和在数值常量表达式中，具有特殊含义，而不会开启一个注释。<code>‘\\#’</code>也不会开启一个注释。</p>\n<a id=\"more\"></a>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><pre><code>function funname(){…}\n</code></pre><p>或者</p>\n<pre><code>funname()\n{\n    statements;\n}\n</code></pre><p>只需要使用函数名就可以调用某个函数：<code>funname</code><br>参数可以传递给函数，使用方法就好像函数是个新脚本一样：<br><code>funname arg1 arg2...;    #传递参数</code><br>在函数中使用传入的参数：<code>$1</code> 第一个参数；<code>$@</code> 所有参数。<br>其中：<code>&quot;$@&quot;</code>被扩展成<code>&quot;$1&quot;&quot;$2&quot;&quot;$3&quot;</code>；<br><code>&quot;$*&quot;</code>被扩展成<code>&quot;$1c$2c$3&quot;</code>，即一个字符串。c为IFS的第一个字符。<br>有时我们需要知道命令或者函数的执行状态，用$?可以查看前一个命令的返回值，如果命令成功退出，那么退出状态为0，否则非0。</p>\n<h4 id=\"正文部分\"><a href=\"#正文部分\" class=\"headerlink\" title=\"正文部分\"></a>正文部分</h4><p>流程控制+命令</p>\n<h4 id=\"执行：修改权限\"><a href=\"#执行：修改权限\" class=\"headerlink\" title=\"执行：修改权限\"></a>执行：修改权限</h4><p>转为可执行程序</p>\n<pre><code>chmod +x ./test.sh  #使脚本具有执行权限\n./test.sh  #执行脚本\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\r#### 流程控制\r条件语句</span><br><span class=\"line\"></span><br><span class=\"line\">if :</span><br></pre></td></tr></table></figure>\n\nif condition\nthen\n    command1 \n    command2\n    ...\n    commandN\nfi\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">if `ps -ef | grep ssh`;  </span><br><span class=\"line\">then </span><br><span class=\"line\">\techo hello; </span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n\n\nif else-if else :\n</code></pre><p>if condition1<br>then<br>    command1<br>elif condition2<br>    command2<br>else<br>    commandN<br>fi</p>\n<pre><code>\n循环语句\nfor :\n</code></pre><p>for var in item1 item2 … itemN<br>do<br>    command1<br>    command2<br>    …<br>    commandN<br>done<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\r```\rfor var in item1 item2 ... itemN; do command1; command2… done;</span><br></pre></td></tr></table></figure></p>\n<p>while :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i=1;total=0;\rwhile [ $i -le 10 ]\rdo\r    let total+=i\r    let i++\r    echo $total,$i\rdone</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i=1; total=0;\rwhile((i&lt;=10))\rdo\r    ((total+=i, i++))\r    echo $total,$i\rdone</span><br><span class=\"line\">```\r\rcase语句: case语句可以用户处理自定义参数。</span><br></pre></td></tr></table></figure>\n<p>case $num in<br>1) echo “January”;;                 #双分号结束<br>2) echo “Feburary”;;<br>5) echo “may”                          #每个case可以有多条命令<br>   echo “sdfd”<br>   echo “sdf”;;                       #但最后一条命令一定是双分号结束<br><em>) echo “not correct input”;;       #</em>）是其他值、default的意思<br>esac</p>\n<pre><code>\n\n#### while read line\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while read line; do something ; done\r```\r\r#### 参数处理\ra)\t`&quot;$*&quot;`将所有的参数解释成一个字符串，而`&quot;$@&quot;`是一个参数数组。\rb)\tShell内建函数`getopts “:a:bc” opt`\r主要变量：</span><br><span class=\"line\">```\r$OPTIND\t: 存储所处理的选项在参数列表中的位置\r$OPTARG\t: 存储相应选项所带的参数</span><br><span class=\"line\">```\r\r例子：</span><br></pre></td></tr></table></figure>\n\nwhile getopts &quot;:a:b:cef&quot; opt\ndo\n    case $opt in\n        a)echo &quot;the $OPTIND has arg:$OPTARG&quot;;;#$OPTIND=3\n        b)echo &quot;the b has arg:$OPTARG&quot;;;\n        c | e | f)echo &quot;the $opt has no arg&quot;;;\n        \\?)echo &quot;the $opt is invalid param&quot;;;\n    esac\ndone\n</code></pre><p>c)    <code>shift n</code>  将位置命令左移n个</p>\n<h4 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h4><p>条件判断应该放进方括号里，且方括号两边都应该留有空格。 <code>[  ]</code><br>a)    字符串判断<br>字符串比较时，最好用双中括号，因为有时候采用单中括号会产生错误，所以最好避开它们。<code>[[ $str1 = $str2 ]]</code></p>\n<pre><code>=    当两个串有相同内容、长度时为真\n!=    当串str1和str2不等时为真\n-n    当串的长度大于0时为真(串非空)\n-z    当串的长度为0时为真(空串)\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\rb)\t数值判断\r```\r-eq     两数相等为真 \r-ne     两数不等为真 \r-gt     int1大于int2为真 \r-ge     int1大于等于int2为真 \r-lt     int1小于int2为真 \r-le     int1小于等于int2为真</span><br></pre></td></tr></table></figure>\n\n\nc)    文件判断\n</code></pre><p>-e file         若文件存在，则为真<br>-d file         若文件存在且是一个目录，则为真<br>-b file         若文件存在且是一个块特殊文件，则为真<br>-c file         若文件存在且是一个字符特殊文件，则为真<br>-f file         若文件存在且是一个规则文件，则为真<br>-g file         若文件存在且设置了SGID位的值，则为真<br>-h file         若文件存在且为一个符合链接，则为真<br>-k file         若文件存在且设置了”sticky”位的值<br>-p file         若文件存在且为一已命名管道，则为真<br>-r file         若文件存在且可读，则为真<br>-s file         若文件存在且其大小大于零，则为真<br>-u file         若文件存在且设置了SUID位，则为真<br>-w file         若文件存在且可写，则为真<br>-x file         若文件存在且可执行，则为真<br>-o file         若文件存在且被有效用户ID所拥有，则为真<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\rd)\t逻辑判断\r`! `  非\r`-a`  与 `&amp;&amp;`\r`-o`  或\t `||`\r`if [ $v –ne 0 –a $v –lt 2 ]` 等价 `if [ $v –ne 0 ] &amp;&amp; [ $v –lt 2 ]`\r`if [ $v –ne 0 –o $v –lt 2 ]` 等价 `if [ $v –ne 0 ] || [ $v –lt 2 ]`\r\r条件判断部分可能会变得很长，一个优化的小技巧是利用`&amp;&amp;`和`||`运算符。</span><br></pre></td></tr></table></figure></p>\n<p>if condition<br>then<br>    command1<br>else<br>    command2<br>fi</p>\n<pre><code>\n</code></pre><p>[ condition ] &amp;&amp; command1 || command2</p>\n<pre><code>这样就用一行代替了上面的5行而实现的功能完全相同。\n如果命令有多个，可以用{}括起来，当做一个命令块。\n这样可以使判断语句变得非常简洁。\n\n#### &amp;&amp;、||\n`cmd1 &amp;&amp; cmd2`\n表示，当cmd1执行成功后，就执行cmd2，否则不执行。\n`cmd1 || cmd2`\n表示，当cmd1执行失败后，就执行cmd2，否则不执行。\n\n### 变量\n#### 系统变量\n$n 该变量与脚本被激活时所带的参数相对应。n是正整数，与参数位置相对应($1,$2...) \n$? 前一个命令执行后的退出状态\n$# 提供脚本的参数号\n$* 所有这些参数都被双引号引住。若一个脚本接收两个参数，$*等于$1$2 \n$0 正在被执行命令的名字。对于shell脚本而言，这是被激活命令的路径\n$@ 所有这些参数都分别被双引号引住。若一个脚本接收到两个参数，$@等价于$1$2\n$$ 当前shell的进程号。对于shell脚本，这是其正在执行时的进程ID\n$! 前一个后台命令的进程号\n\n#### 普通变量\n1)    赋值：`var=value`\n2)    #\n获取字符串的长度。`len=${#var}`\n3)    数值运算：let\nlet命令后面的变量不用带$，如：\n`nu=10;`\n`let nu+=10;    #nu=20`\n但这个命令不能进行浮点数的运算。\n4)    浮点数运算：bc\n`echo &quot;4 * 0.6&quot; | bc`\nbc是一个强大的计算器，还可以进项如下操作：\n设定小数精度，`scale=2,eg:echo &quot;scale=2;3 / 8&quot; | bc`\n\\#.37  这是bc的特性，小于0的数，是不显示小数点前的0的。\n进制转换。用ibase设定输入数字的进制，obase设定输出数字的进制。\n</code></pre><p>no=10<br>echo “obase=2;ibase=10;$no” | bc   #1010</p>\n<pre><code>计算平方以及平方根。\n</code></pre><p>echo “10^4” | bc        #1000    平方<br>echo “sqrt(100)” | bc     #10        平方根</p>\n<pre><code>\n#### IFS\n全称是Internal Field Separtor，内部分隔符。\nShell 的环境变量分为 set, env 两种，其中 set 变量可以通过 export 工具导入到 env 变量中。其中，set 是显示设置shell变量，仅在本 shell 中有效；env 是显示设置用户环境变量 ，仅在当前会话中有效。换句话说，set 变量里包含了 env 变量，但 set 变量不一定都是 env 变量。这两种变量不同之处在于变量的作用域不同。显然，env 变量的作用域要大些，它可以在 subshell 中使用。\n而 IFS 是一种 set 变量，当 shell 处理&quot;命令替换&quot;和&quot;参数替换&quot;时，shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg：\r$ cat test.txt\r1\r2\r3\r$ out=$(cat test.txt)\r$ echo $out\r1 2 3\t\t\t#shell将(cat test.txt)的结果拆解，并用默认的分隔符（空格）重新组合，赋值给out，因此echo $out的结果不包含换行。\r```\r如果要保留`cat test.txt`中的换行符，一般情况下要做两步：\r1是，设定IFS为换行：`IFS=&apos;\\n&apos;`\r2是，将`$(cat test.txt)`用双引号引起来，表示不用\r若指定IFS为换行符。\r\r#### UID\r特殊的环境变量，如果UID=0，表示当前以root用户运行脚本。否则不是root\r\r### 自增\rLinux Shell中写循环时，常常要用到变量的自增，现在总结一下整型变量自增的方法。</span><br></pre></td></tr></table></figure>\n\n1)    i=`expr $i + 1`;\n2)    let i+=1;\n3)    ((i++));    #双括号结构\n4)    i=$[$i+1];\n5)    i=$(( $i + 1 ))\n</code></pre><h3 id=\"双括号结构\"><a href=\"#双括号结构\" class=\"headerlink\" title=\"双括号结构(())\"></a>双括号结构(())</h3><p>双括号结构是对shell中算数及赋值运算的扩展。<br>语法：<br>((表达式1,表达式2…))</p>\n<p>特点：<br>1)    在双括号结构中，所有表达式可以像c语言一样，如：<code>a++</code>,<code>b--</code>等。<br>2)    在双括号结构中，所有变量可以不加入：“$”符号前缀。<br>3)    双括号可以进行逻辑运算，四则运算.eg. <code>echo $((a&gt;1?2:3))</code>;注意四则运算中仍然不支持浮点数运算<br>4)    支持多个表达式运算，各个表达式之间用“，”分开. eg:<code>((a+1,b++,c++))</code><br>5)    双括号结构 扩展了<code>for</code>，<code>while</code>,<code>if</code>条件测试运算</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>1)    取数组长度 – <code>&#39;#&#39;</code></p>\n<pre><code>arr=(1 2 3 4 5)\nlen=${#arr[@]}\n</code></pre><p>2)    打印特定索引的数组元素</p>\n<pre><code>echo ${arr[2]}        #2\n</code></pre><p>3)    打印出数组中的所有值-<code>&#39;*&#39;</code>、<code>&#39;@&#39;</code></p>\n<pre><code>echo ${arr[*]}\necho ${arr[@]}\n</code></pre><h3 id=\"关联数组\"><a href=\"#关联数组\" class=\"headerlink\" title=\"关联数组\"></a>关联数组</h3><p>在关联数组中，可以用任意的文本作为数组索引。先声明才能使用<br>1)    声明一个关联数组。</p>\n<pre><code>declare –A ass_array\n</code></pre><p>2)    赋值：</p>\n<pre><code>a)    ass_array=([index1]=val1 [index2]=val2)\nb)    ass_array[index1]=val1\nass_array[index2]=val2\n</code></pre><p>3)    <code>echo ${ass_array[index1]}</code></p>\n<p>4)    列出数组索引：<br><code>echo ${!ass_array[@]}</code></p>\n<h3 id=\"临时文件或目录\"><a href=\"#临时文件或目录\" class=\"headerlink\" title=\"临时文件或目录\"></a>临时文件或目录</h3><p>在shell脚本中经常要保存临时的数据，如果使用认为创建临时文件用户保存临时数据，则有可能出现重名的情况，导致覆盖原来的数据。</p>\n<p><code>mktemp prefile.xxx</code> 创建以prefile开头的随机文件文件，并返回文件名，指定前缀时必须包含至少3个xxx。</p>\n<p>主要参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-d : 创建一个目录，dirname=`mktemp -d`\r-u : 仅生成随机文件名，但不创建实际的文件或目录，tmpfile=`mktemp -u`</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.cnblogs.com/chengmo/archive/2010/10/19/1855577.html\" target=\"_blank\" rel=\"external\">linux shell “(())” 双括号运算符使用</a></li>\n</ul>\n<hr>\n<p>扫描二维码或在微信中搜索 KeepMovingXin<br><img src=\"/images/qrcode.jpg\" alt=\"欢迎关注微信公众号！\"></p>\n<hr>\n<p><strong>版权声明</strong><br><a href=\"http://blog.keepmovingxin.com\">KeepMoving</a> by <a href=\"http://blog.keepmovingxin.com/about\">KP_小新</a> 采用 <a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\" target=\"_blank\" rel=\"external\">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a><br>Copyright © 2016 <a href=\"http://blog.keepmovingxin.com\">KeepMoving</a>. All rights reserved.<br>原文链接：<a href=\"http://blog.keepmovingxin.com/2016/05/02/Learn-shell/\">http://blog.keepmovingxin.com/2016/05/02/Learn-shell/</a></p>\n"}