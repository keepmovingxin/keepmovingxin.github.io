{"_total":18,"_totalPage":2,"_page":1,"posts":[{"tags":[{"name":"Lua","permalink":"http://blog.keepmovingxin.com/tags/Lua/","url":"/async/tags/Lua.json","count":9},{"name":"Lua数据结构","permalink":"http://blog.keepmovingxin.com/tags/Lua数据结构/","url":"/async/tags/Lua数据结构.json","count":6}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":11}],"url":"/async/posts/2016/06/10/Lua-lua_State.json","date":1465563796000,"path":{"year":2016,"month":6,"day":10,"name":"Lua-lua_State"},"title":"Lua数据结构 — lua_State（六）","permalink":"http://blog.keepmovingxin.com/2016/06/10/Lua-lua_State/","content":"<p>前面各种Lua的数据类型基本都说得差不多了，剩下最后一个数据类型：<strong>lua_State</strong>，我们可以认为是<strong>”脚本上下文”</strong>，主要是包括当前脚本环境的运行状态信息，还会有gc相关的信息。</p>"},{"tags":[{"name":"Lua","permalink":"http://blog.keepmovingxin.com/tags/Lua/","url":"/async/tags/Lua.json","count":9},{"name":"Lua数据结构","permalink":"http://blog.keepmovingxin.com/tags/Lua数据结构/","url":"/async/tags/Lua数据结构.json","count":6}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":11}],"url":"/async/posts/2016/06/09/Lua-Udata.json","date":1465475623000,"path":{"year":2016,"month":6,"day":9,"name":"Lua-Udata"},"title":"Lua数据结构 — Udata（五）","permalink":"http://blog.keepmovingxin.com/2016/06/09/Lua-Udata/","content":"<p><strong>Udata负责存储userdata的数据</strong>，这部分其实很简单，但是为了保证系列文章的完整性，还是写一篇出来补全。</p>"},{"tags":[{"name":"Lua","permalink":"http://blog.keepmovingxin.com/tags/Lua/","url":"/async/tags/Lua.json","count":9},{"name":"Lua数据结构","permalink":"http://blog.keepmovingxin.com/tags/Lua数据结构/","url":"/async/tags/Lua数据结构.json","count":6}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":11}],"url":"/async/posts/2016/06/08/Lua-Closure.json","date":1465398377000,"path":{"year":2016,"month":6,"day":8,"name":"Lua-Closure"},"title":"Lua数据结构 — 闭包（四）","permalink":"http://blog.keepmovingxin.com/2016/06/08/Lua-Closure/","content":"<p>前面几篇文章已经说明了Lua里面很常用的几个数据结构，这次要分享的也是常用的数据结构之一 – <strong>函数的结构</strong>。函数在Lua里也是一种变量，但是它却很特殊，能存储执行语句和被执行，本章主要描述Lua是怎么实现这种函数的。</p>"},{"tags":[{"name":"Lua","permalink":"http://blog.keepmovingxin.com/tags/Lua/","url":"/async/tags/Lua.json","count":9},{"name":"Lua数据结构","permalink":"http://blog.keepmovingxin.com/tags/Lua数据结构/","url":"/async/tags/Lua数据结构.json","count":6}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":11}],"url":"/async/posts/2016/06/07/Lua-Table.json","date":1465308939000,"path":{"year":2016,"month":6,"day":7,"name":"Lua-Table"},"title":"Lua数据结构 — Table（三）","permalink":"http://blog.keepmovingxin.com/2016/06/07/Lua-Table/","content":"<p>前面（一）、（二）里面其实已经把一些常用的数据类型（数值、布尔、字符串）说明了，这次要描述的是Table，Table在Lua里是一种常用的数据类型，是Lua里的精髓之一，其效率必须得到保证，而实现这种支持任意类型key和value的Table也是较为复杂的。</p>"},{"tags":[{"name":"Lua","permalink":"http://blog.keepmovingxin.com/tags/Lua/","url":"/async/tags/Lua.json","count":9},{"name":"Lua数据结构","permalink":"http://blog.keepmovingxin.com/tags/Lua数据结构/","url":"/async/tags/Lua数据结构.json","count":6}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":11}],"url":"/async/posts/2016/06/06/Lua-TString.json","date":1465218816000,"path":{"year":2016,"month":6,"day":6,"name":"Lua-TString"},"title":"Lua数据结构 — TString（二）","permalink":"http://blog.keepmovingxin.com/2016/06/06/Lua-TString/","content":"<p>存储lua里面的字符串的<strong>TString数据结构</strong>:（lobject.h 196-207）</p>\n<p><img src=\"/images/luaTstring/lua-tstring-01.png\" alt=\"\"></p>"},{"tags":[{"name":"Lua","permalink":"http://blog.keepmovingxin.com/tags/Lua/","url":"/async/tags/Lua.json","count":9},{"name":"Lua数据结构","permalink":"http://blog.keepmovingxin.com/tags/Lua数据结构/","url":"/async/tags/Lua数据结构.json","count":6}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":11}],"url":"/async/posts/2016/06/05/Lua-TValue.json","date":1465135588000,"path":{"year":2016,"month":6,"day":5,"name":"Lua-TValue"},"title":"Lua数据结构 — TValue（一）","permalink":"http://blog.keepmovingxin.com/2016/06/05/Lua-TValue/","content":"<p>数据结构的设计，在一定程度上奠定了整个系统的设计，所以决定写一个对Lua主要数据结构的分析文章，本来打算写一篇就好了，但是每个数据类型其实都有点复杂，一篇的话篇幅太长，所以就拆开几篇来写了。</p>"},{"tags":[{"name":"Lua","permalink":"http://blog.keepmovingxin.com/tags/Lua/","url":"/async/tags/Lua.json","count":9}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":11}],"url":"/async/posts/2016/05/27/Lua-global.json","date":1464359412000,"path":{"year":2016,"month":5,"day":27,"name":"Lua-global"},"title":"Lua 全局变量的那些事儿","permalink":"http://blog.keepmovingxin.com/2016/05/27/Lua-global/","content":"<p>最近项目查了一个问题，最后发现和<code>_G[moduleName]</code>这个置为<code>nil</code>有关系，找了点资料看看里面的坑还是蛮深的，所以记录一下。</p>\n<h3 id=\"全局环境表-G\"><a href=\"#全局环境表-G\" class=\"headerlink\" title=\"全局环境表 _G\"></a>全局环境表 <code>_G</code></h3><p>Lua把所有的全局变量都放在一个称为全局环境的表_G中，这个表只是个普通的表。注意<code>_G._G == _G</code>。<br>由于<code>_G</code>是一个普通的表，所以提供了以动态名称访问全局变量的形式，这又是Lua的一种对元编程的支持。</p>\n<p>如<code>_G[varname] = value</code>，更一般的问题是允许使用动态字段名，如_G[“read.io”]默认是不会取出read模块的io字段的，但是使用下面这样实现：</p>"},{"tags":[{"name":"Lua","permalink":"http://blog.keepmovingxin.com/tags/Lua/","url":"/async/tags/Lua.json","count":9}],"categories":[{"name":"游戏开发","permalink":"http://blog.keepmovingxin.com/categories/游戏开发/","url":"/async/categories/游戏开发.json","count":11}],"url":"/async/posts/2016/05/25/Lua-metable.json","date":1464161405000,"path":{"year":2016,"month":5,"day":25,"name":"Lua-metable"},"title":"了解Lua metatable 元表","permalink":"http://blog.keepmovingxin.com/2016/05/25/Lua-metable/","content":"<p>参考lua手册，<code>metatable</code>是被译作元表，Lua 中的每个值都可以用一个 <code>metatable</code>。这个 <code>metatable</code> 就是一个原始的 Lua table，它用来定义原始值在特定操作下的行为。</p>\n<h3 id=\"metatable\"><a href=\"#metatable\" class=\"headerlink\" title=\"metatable\"></a><code>metatable</code></h3><p>一个 <code>metatable</code> 可以控制一个对象做数学运算操作、比较操作、连接操作、取长度操作、取下标操作时的行为，metatable 中还可以定义一个函数，让 <code>userdata</code> 作垃圾收集时调用它。对于这些操作，Lua 都将其关联上一个被称作事件的指定健。当 Lua 需要对一个值发起这些操作中的一个时，它会去检查值中 metatable 中是否有对应事件。如果有的话，键名对应的值（元方法）将控制 Lua 怎样做这个操作。</p>"},{"tags":[{"name":"Git","permalink":"http://blog.keepmovingxin.com/tags/Git/","url":"/async/tags/Git.json","count":2}],"categories":[{"name":"工具/效率","permalink":"http://blog.keepmovingxin.com/categories/工具-效率/","url":"/async/categories/工具/效率.json","count":7}],"url":"/async/posts/2016/05/20/Git-Workflow.json","date":1463755288000,"path":{"year":2016,"month":5,"day":20,"name":"Git-Workflow"},"title":"Git 常用命令用法：程序员的场景","permalink":"http://blog.keepmovingxin.com/2016/05/20/Git-Workflow/","content":"<p>Git 相比 Subversion，无论概念上还是使用上，复杂度其实是高出一个等级的。为什么这么说？分别看下 <code>git help -a</code> 和 <code>svn help</code> 命令清单的对比，单按这个来看，就如果要掌握所有命令的用法，Git 的学习曲线绝对是比 Subversion 高的。尽管如此，但还是有越来越多项目开始用 Git 来做源码管理了。</p>\n<p>实际中，我们用到的的 Git 命令还是很有限的，可能也就 <code>git help</code> 中那些而已。下面就类似 <a href=\"http://blog.keepmovingxin.com/2016/05/20/SVN-Workflow/\">SVN命令用法：程序员的场景</a> 一样，结合实际场景说下 Git 的常用命令用法。<br>"},{"tags":[{"name":"SVN","permalink":"http://blog.keepmovingxin.com/tags/SVN/","url":"/async/tags/SVN.json","count":1}],"categories":[{"name":"工具/效率","permalink":"http://blog.keepmovingxin.com/categories/工具-效率/","url":"/async/categories/工具/效率.json","count":7}],"url":"/async/posts/2016/05/20/SVN-Workflow.json","date":1463754719000,"path":{"year":2016,"month":5,"day":20,"name":"SVN-Workflow"},"title":"SVN命令用法：程序员的场景","permalink":"http://blog.keepmovingxin.com/2016/05/20/SVN-Workflow/","content":"<p>SVN有不少命令，其实常用的也就那么几个，可以结合下实际的使用场景，来说明下SVN的命令用法。<br>当然可能对很多人来说，最实用的熟悉方式，就是直接运行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn help (?, h)</span><br></pre></td></tr></table></figure></p>\n<p>就入门了，但为了更好的记忆，有个实际场景也是个不错的选择。<br>注解：括号中的是该命令的缩写或别名，有的可以少打几个字母，后面也有类似描述。<br>"}]}